import { A as AudioComponentProps, V as VideoComponentProps, S as SimpleViewerContext, a as SimpleViewerProps } from './index-BJveLrlu.cjs';
export { C as CanvasPanel, c as SimpleViewerActions, d as SimpleViewerActionsType, b as SimpleViewerReducerState } from './index-BJveLrlu.cjs';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as React$1 from 'react';
import React__default, { ReactNode, FunctionComponent, RefObject, Context } from 'react';
import { R as RenderingStrategy, b as StrategyActions, M as MediaStrategy, c as SingleImageStrategy, E as EmptyStrategy, C as ComplexTimelineStrategy, I as ImageWithOptionalService, T as TimelineKeyframe, U as UnknownStrategy, d as ImageServiceLoaderType } from './useRenderingStrategy-BiuSDiXu.cjs';
export { f as AnnotationPageDescription, A as AudioSequence, n as ChoiceEvents, k as Single3DModelStrategy, S as SingleAudio, a as SingleVideo, e as SingleYouTubeVideo, i as TextContent, h as TextualContentStrategy, m as UseRenderingStrategy, o as UseRenderingStrategyOptions, V as VideoSequence, l as get3dStrategy, g as getImageStrategy, j as getTextualContentStrategy, u as useLoadImageService, p as useRenderingStrategy } from './useRenderingStrategy-BiuSDiXu.cjs';
import * as _iiif_helpers from '@iiif/helpers';
import { ChoiceDescription, Paintables, ComplexChoice } from '@iiif/helpers';
import { BoxStyle, AtlasProps, Preset } from '@atlas-viewer/atlas';
import { InternationalString, ImageService as ImageService$1, ImageSize, AuthProbeService2, Auth2LocationResource, Auth2SubstituteResource, AuthAccessService2, AuthAccessTokenService2, AuthAccessToken2, SearchServiceQueryParams, SearchServiceSearchResponse, SearchService as SearchService$1, SearchServiceAutocomplete, Reference, Annotation } from '@iiif/presentation-3';
import { RegionParameter, RotationParameter, SizeParameter } from '@iiif/parser/image-3';
import * as polygon_editor from 'polygon-editor';
import { RenderState, InputShape, SlowState } from 'polygon-editor';
import * as zustand_vanilla from 'zustand/vanilla';
import { StoreApi } from 'zustand/vanilla';
import * as zustand from 'zustand';
import { StoreApi as StoreApi$1 } from 'zustand';
import * as mitt from 'mitt';
import { Emitter, EventType, Handler } from 'mitt';
import { Vault, VaultOptions, NormalizedEntity, IIIFStore } from '@iiif/helpers/vault';
import { CanvasNormalized, AnnotationNormalized, AnnotationPageNormalized, CollectionNormalized, ManifestNormalized, RangeNormalized } from '@iiif/presentation-3-normalized';
import { ImageServiceLoader, ImageCandidateRequest, ImageCandidate } from '@iiif/helpers/image-service';
import { C as CompatVault } from './utils-CvRzsfRK.cjs';
export { e as emptyActions, b as emptyStrategy, g as getParsedTargetSelector, c as getRenderingStrategy, p as parseSpecificResource, u as unknownResponse, a as unsupportedStrategy } from './utils-CvRzsfRK.cjs';
import { VaultZustandStore } from '@iiif/helpers/vault/store';
import * as _iiif_helpers_painting_annotations from '@iiif/helpers/painting-annotations';
import * as _iiif_helpers_styles from '@iiif/helpers/styles';
export * from '@iiif/helpers/annotation-targets';

interface CanvasStrategyProviderProps {
    onChoiceChange?: (choice?: ChoiceDescription) => void;
    strategies?: Array<RenderingStrategy['type']>;
    registerActions?: (actions: StrategyActions) => void;
    defaultChoices?: Array<{
        id: string;
        opacity?: number;
    }>;
    children: ReactNode;
    renderMediaControls?: (strategy: MediaStrategy) => ReactNode;
    viewControlsDeps?: any[];
    renderViewerControls?: (strategy: SingleImageStrategy | EmptyStrategy) => ReactNode;
    renderComplexTimelineControls?: (strategy: ComplexTimelineStrategy) => ReactNode;
    complexTimelineControlsDeps?: any[];
    mediaControlsDeps?: any[];
    throwOnUnknown?: boolean;
}
declare function CanvasStrategyProvider({ strategies, registerActions, defaultChoices, onChoiceChange, mediaControlsDeps, renderMediaControls, renderViewerControls, viewControlsDeps, renderComplexTimelineControls, complexTimelineControlsDeps, throwOnUnknown, children, }: CanvasStrategyProviderProps): react_jsx_runtime.JSX.Element;

interface CanvasWorldObjectProps {
    x?: number;
    y?: number;
    keepCanvasScale?: boolean;
    children?: ReactNode;
}
declare function CanvasWorldObject({ x, y, keepCanvasScale, children }: CanvasWorldObjectProps): react_jsx_runtime.JSX.Element | null;

declare function ThumbnailFallbackImage({ x, y }: {
    x?: number;
    y?: number;
}): react_jsx_runtime.JSX.Element | null;

interface RenderEmptyStrategyProps {
    backgroundStyle?: BoxStyle;
    alwaysShowBackground?: boolean;
}
declare function RenderEmptyStrategy({ backgroundStyle, alwaysShowBackground }: RenderEmptyStrategyProps): react_jsx_runtime.JSX.Element | null;

declare function RenderComplexTimelineStrategy(): react_jsx_runtime.JSX.Element | null;

interface TextualContextStrategyProps {
    onClickPaintingAnnotation?: (id: string, e: any) => void;
    children?: ReactNode;
}
declare function RenderTextualContentStrategy({ onClickPaintingAnnotation, children }: TextualContextStrategyProps): react_jsx_runtime.JSX.Element | null;

interface ImageStrategyProps {
    isStatic?: boolean;
    enableSizes?: boolean;
    onClickPaintingAnnotation?: (id: string, image: ImageWithOptionalService, e: any) => void;
    children?: ReactNode;
}
declare function RenderImageStrategy({ isStatic, enableSizes, onClickPaintingAnnotation, children, }: ImageStrategyProps): react_jsx_runtime.JSX.Element | null;

declare function Render3DModelStrategy(): react_jsx_runtime.JSX.Element | null;

interface AnnotationStrategyProps {
    children?: ReactNode;
}
declare function RenderAnnotationStrategy({ children }: AnnotationStrategyProps): react_jsx_runtime.JSX.Element | null;

interface RenderAudioStrategyProps {
    as?: React.ComponentType<AudioComponentProps>;
}
declare function RenderAudioStrategy({ as: CustomAudio, }: RenderAudioStrategyProps): react_jsx_runtime.JSX.Element | null;

declare function RenderAccompanyingCanvas(): react_jsx_runtime.JSX.Element;

interface RenderVideoStrategyProps {
    as?: React__default.ComponentType<VideoComponentProps>;
}
declare function RenderVideoStrategy({ as: CustomVideo, }: RenderVideoStrategyProps): react_jsx_runtime.JSX.Element | null;

declare function RenderYouTubeStrategy(): react_jsx_runtime.JSX.Element | null;

declare const CanvasAnnotations: React$1.ForwardRefExoticComponent<{
    canvasId?: string | undefined;
} & React$1.RefAttributes<{
    availablePageIds: string[];
    enabledPageIds: string[];
    setPageEnabled: (id: string, opt?: {
        deselectOthers?: boolean | undefined;
    }) => void;
    setPageDisabled: (deselectId: string) => void;
}>>;

type FacetConfig = {
    id: string;
    label: InternationalString;
    keys: string[];
    values?: FacetConfigValue[];
};
type FacetConfigValue = {
    id: string;
    label: InternationalString;
    values: string[];
    key: string;
};
interface MetadataProps {
    config?: FacetConfig[];
    metadata?: Array<{
        label: InternationalString;
        value: InternationalString;
    } | null>;
    labelWidth?: number;
    allowHtml?: boolean;
    showEmptyMessage?: boolean;
    separator?: string;
    classes?: {
        container?: string;
        row?: string;
        label?: string;
        value?: string;
        empty?: string;
    };
    emptyMessage?: string;
    emptyValueFallback?: string;
    emptyLabelFallback?: string;
    tableHeader?: React.ReactNode;
    tableFooter?: React.ReactNode;
    emptyFallback?: React.ReactNode;
}
declare function Metadata({ metadata, config, labelWidth, showEmptyMessage, allowHtml, emptyFallback, classes, emptyMessage, emptyValueFallback, emptyLabelFallback, separator, tableFooter, tableHeader, }: MetadataProps): react_jsx_runtime.JSX.Element;

type CombinedMetadataProps = Omit<MetadataProps, 'metadata'>;
declare function CombinedMetadata(props: CombinedMetadataProps): react_jsx_runtime.JSX.Element;

interface ImageProps {
    src: string | ImageService$1;
    alt?: string;
    size?: Partial<ImageSize>;
    region?: RegionParameter;
    className?: string;
    style?: React.CSSProperties;
    fetchImageService?: boolean;
    quality?: string;
    rotation?: number | RotationParameter;
    format?: string;
}
declare function Image(props: ImageProps): react_jsx_runtime.JSX.Element | null;

type ManifestMetadataProps = Omit<MetadataProps, 'metadata'>;
declare function ManifestMetadata(props: ManifestMetadataProps): react_jsx_runtime.JSX.Element;

interface SequenceThumbnailsProps {
    flat?: boolean;
    size?: {
        width: number;
        height?: number;
    };
    dereference?: boolean;
    classes?: {
        container?: string;
        row?: string;
        item?: string;
        figure?: string;
        imageWrapper?: string;
        img?: string;
        label?: string;
        selected?: {
            row?: string;
            item?: string;
            figure?: string;
            img?: string;
            label?: string;
            imageWrapper?: string;
        };
    };
    figure?: boolean;
    showLabel?: boolean;
    fallback?: React.ReactNode;
    scrollBehaviour?: ScrollBehavior;
}
declare function SequenceThumbnails({ scrollBehaviour, dereference, flat, size, classes, showLabel, figure, fallback }: SequenceThumbnailsProps): react_jsx_runtime.JSX.Element;

interface SingleCanvasThumbnailProps {
    canvasId?: string;
    size?: Partial<SizeParameter>;
    visible?: boolean;
    alt?: string;
    dereference?: boolean;
    figure?: boolean;
    showLabel?: boolean;
    classes?: {
        figure?: string;
        img?: string;
        label?: string;
        imageWrapper?: string;
    };
    placeholder?: React.ReactNode;
    fallback?: React.ReactNode;
}
declare function SingleCanvasThumbnail(props: SingleCanvasThumbnailProps): react_jsx_runtime.JSX.Element;

interface SvgEditorOptions {
    image: {
        height: number;
        width: number;
    };
    currentShape: InputShape | null;
    onChange: (e: InputShape) => void;
    hideShapeLines?: boolean;
}
declare function useSvgEditor(options: SvgEditorOptions, deps: any[]): {
    helper: {
        draw: {
            enable(): void;
            disable(): void;
            toggle(): void;
        };
        state: RenderState;
        modifiers: {
            reset(): void;
            getForType(type: string | null): Record<string, string>;
            set(modifier: string): void;
            unset(modifier: string): void;
        };
        stamps: {
            set(selectedStamp: InputShape | null): void;
            clear(): void;
            square(): void;
            triangle(): void;
            pentagon(): void;
            hexagon(): void;
        };
        key: {
            down(key: string): true | undefined;
            up(key: string): void;
        };
        setScale: (scale: number) => void;
        clock: {
            set: (renderFunc: polygon_editor.RenderFunc) => void;
            start: (renderFunc?: polygon_editor.RenderFunc | undefined, setStateFunc?: polygon_editor.SetState | undefined) => void;
            stop: () => void;
            step: (deltaTime?: number | undefined) => void;
        };
        pointer: (pointers: ([number, number] | [number, number, number, number, number, number])[]) => void;
        blur: () => void;
        pointerDown: () => void;
        pointerUp: () => void;
        setShape: (shape: InputShape | null) => void;
        modes: {
            toggleLineBoxMode: () => void;
            toggleLineMode: () => void;
            enableLineMode(): void;
            disableLineMode(): void;
            enableLineBoxMode(): void;
            disableLineBoxMode(): void;
        };
        label: (type: string | null) => string;
    };
    state: SlowState;
    isAddingPoint: boolean;
    isSplitting: boolean;
    isStamping: boolean | null;
    isHoveringPoint: boolean;
    transitionDirection: string | null;
    transitionRotate: boolean;
    defs: react_jsx_runtime.JSX.Element;
    editor: react_jsx_runtime.JSX.Element | null;
};

type HelperType$1 = ReturnType<typeof useSvgEditor>['helper'];
type StateType$1 = ReturnType<typeof useSvgEditor>['state'];
interface RenderSvgEditorControlsProps {
    helper: HelperType$1;
    state: StateType$1;
    showShapes: boolean;
    classNames?: Partial<{
        button: string;
    }>;
    enabled?: {
        draw?: boolean;
        polygon?: boolean;
        line?: boolean;
        lineBox?: boolean;
        square?: boolean;
        triangle?: boolean;
        hexagon?: boolean;
        circle?: boolean;
        delete?: boolean;
    };
    icons?: Partial<{
        DrawIcon: ReactNode;
        PolygonIcon: ReactNode;
        LineIcon: ReactNode;
        LineBoxIcon: ReactNode;
        ShapesIcon: ReactNode;
        SquareIcon: ReactNode;
        TriangleIcon: ReactNode;
        HexagonIcon: ReactNode;
        CircleIcon: ReactNode;
        DeleteForeverIcon: ReactNode;
    }>;
}
declare function RenderSvgEditorControls({ helper, showShapes, state, enabled, classNames, icons, }: RenderSvgEditorControlsProps): react_jsx_runtime.JSX.Element;

declare const svgThemes: ({
    name: string;
    outer: {
        borderWidth: number;
        borderColor: string;
    };
    inner: {
        borderWidth: number;
        borderColor: string;
    };
} | {
    name: string;
    outer: {
        borderWidth: string;
        borderColor: string;
    };
    inner: {
        borderWidth: string;
        borderColor: string;
    };
} | {
    name: string;
    outer: {
        borderWidth: string;
        borderColor: string;
    };
    inner: {
        borderWidth?: undefined;
        borderColor?: undefined;
    };
})[];
type HelperType = ReturnType<typeof useSvgEditor>['helper'];
type StateType = ReturnType<typeof useSvgEditor>['state'];
type SvgTheme = {
    name?: string;
    outer: BoxStyle;
    inner: BoxStyle;
};
interface CreateCustomShapeProps {
    image: {
        width: number;
        height: number;
    };
    shape?: any;
    updateShape: any;
    theme?: {
        name?: string;
        outer: BoxStyle;
        inner: BoxStyle;
    };
    controlsHtmlId?: string;
    renderControls?: (helper: HelperType, state: StateType, showShapes: boolean) => any;
}
declare function CreateCustomShape(props: CreateCustomShapeProps): react_jsx_runtime.JSX.Element;

interface PolygonSelectorProps {
    id: string;
    polygon: InputShape;
    annotationBucket?: string;
    isHighlighted?: boolean;
    updatePolygon?: (shape: InputShape) => void;
    readOnly?: boolean;
    theme?: SvgTheme;
    controlsHtmlId?: string;
    renderControls?: CreateCustomShapeProps['renderControls'];
}
declare function PolygonSelector(props: PolygonSelectorProps): react_jsx_runtime.JSX.Element | null;

interface ImageServiceProps {
    src: string;
    atlas?: AtlasProps;
    errorFallback?: React__default.FC;
    interactive?: boolean;
    skipSizes?: boolean;
    renderViewerControls?: (strategy: SingleImageStrategy | EmptyStrategy) => ReactNode;
    viewControlsDeps?: any[];
    fluid?: boolean;
    x?: number;
    y?: number;
    children?: React__default.ReactNode;
}
declare function ImageService({ src, errorFallback, interactive, skipSizes, children, renderViewerControls, viewControlsDeps, fluid, x, y, ...atlasProps }: ImageServiceProps & Omit<AtlasProps, 'children'>): react_jsx_runtime.JSX.Element | null;

declare function AnnotationContext({ annotation, children }: {
    annotation: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function AnnotationPageContext({ annotationPage, children }: {
    annotationPage: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function hasAuth(resource: any): boolean;
interface ProbeStore {
    service?: AuthProbeService2;
    status: 'unknown' | 'probing' | 'error' | 'success';
    shouldRedirect: boolean;
    redirectResource: Auth2LocationResource | null;
    shouldSubstitute: boolean;
    substituteResource: Auth2SubstituteResource | null;
    error: string | null;
    errorHeading: InternationalString | null;
    errorNote: InternationalString | null;
    shouldDisplayResource: boolean;
    token: string | null;
    probe: () => Promise<void>;
    setToken: (token: string) => void;
}
interface AuthContextState {
    currentAuth: number;
    authItems: AuthAccessState[];
}
interface AuthContextCurrentActions {
    login(): void;
    logout(): void;
    nextAuth(): void;
    previousAuth(): void;
    setAuth(index: number): void;
}
interface AuthContextActions {
    addService(service: AuthAccessService2, probeId: string): void;
    removeService(service: AuthAccessService2, probeId: string): void;
}
interface AuthAccessState {
    id: string;
    type: 'external' | 'kiosk' | 'active';
    service: AuthAccessService2;
    probeId: string;
    isPending: boolean;
    isLoggedIn: boolean;
    canAuthenticate: boolean;
    instances: number;
    error?: string;
    session: null | {
        token: string;
        expires: number;
    };
}
declare const createAuthStateStore: () => zustand_vanilla.StoreApi<AuthContextCurrentActions & AuthContextState & AuthContextActions>;
declare const createProbe: (service?: AuthProbeService2, token?: string) => zustand_vanilla.StoreApi<ProbeStore>;
declare function authDetailsForResource(resource: any): {
    hasAuth?: boolean | undefined;
    services: {
        probe?: AuthProbeService2;
        access?: AuthAccessService2;
    };
};
declare function makeAccessTokenRequest<T extends AuthAccessTokenService2>(service: T, { strict }?: {
    strict?: boolean;
}): Promise<AuthAccessToken2>;
declare function makeAccessServiceRequest<T extends AuthAccessService2>(service: T): Promise<void>;

interface AuthState {
    id: string;
    type: 'external' | 'kiosk' | 'active';
    service: AuthAccessService2;
    probeId: string;
    isPending: boolean;
    isLoggedIn: boolean;
    canAuthenticate: boolean;
    instances: number;
    error?: string;
    session: null | {
        token: string;
        expires: number;
    };
}
declare const AuthRContext: React$1.Context<StoreApi<AuthContextState & AuthContextCurrentActions & AuthContextActions> | null>;
declare const AuthReactContext: React$1.Context<(AuthContextState & AuthContextCurrentActions) | null>;
declare const AuthReactContextActions: React$1.Context<AuthContextActions | null>;
declare function AuthProvider({ children }: {
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function useIsAuthEnabled(): boolean;
declare function useAuthStore(): StoreApi<AuthContextState & AuthContextCurrentActions & AuthContextActions>;
declare function useAuthActions(): {
    login: () => void;
    logout: () => void;
    nextAuth: () => void;
    previousAuth: () => void;
    setAuth: (index: number) => void;
    addService: (service: AuthAccessService2, probeId: string) => void;
    removeService: (service: AuthAccessService2, probeId: string) => void;
};
declare function useCurrentAuth(): AuthContextState & AuthContextCurrentActions & AuthContextActions;
declare function useAuthService(id: string): AuthAccessState | undefined;
declare function useAuthTokens(id?: string): string | undefined;
declare function useAuthToken(id: string): string | null;
interface AuthProps<T, Extra> {
    resource: T;
    extra?: Extra;
    children: (service: T) => ReactNode;
    fallbackComponent?: FunctionComponent<any> | null;
    loadingComponent?: FunctionComponent<any> | null;
    errorComponent?: FunctionComponent<{
        resource: T;
        error: string;
        heading: InternationalString | null;
        note: InternationalString | null;
        extra: Extra | undefined;
    }> | null;
}
declare function Auth<Element, Extra = any>(props: AuthProps<Element, Extra>): string | number | boolean | Iterable<ReactNode> | react_jsx_runtime.JSX.Element | null | undefined;

declare function CanvasContext({ canvas, children }: {
    canvas: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function CollectionContext({ collection, children }: {
    collection: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

type MediaPlayerState = {
    isPlaying: boolean;
    isMuted: boolean;
    playRequested: boolean;
    volume: number;
    isFinished: boolean;
    duration: number;
};
type MediaPlayerActions = {
    play(): void;
    pause(): void;
    playPause(): void;
    mute(): void;
    unmute(): void;
    toggleMute(): void;
    setVolume(volume: number): void;
    setDurationPercent(percent: number): void;
    setTime(time: number | ((t: number) => number)): void;
};
declare function formatTime(time: number): string;
declare function useSimpleMediaPlayer(props: {
    duration: number;
}): readonly [
    {
        element: RefObject<HTMLAudioElement | HTMLVideoElement>;
        currentTime: RefObject<HTMLDivElement>;
        progress: RefObject<HTMLDivElement>;
    },
    MediaPlayerState,
    MediaPlayerActions
];

interface ComplexTimelineStore extends MediaPlayerActions {
    complexTimeline: ComplexTimelineStrategy;
    visibleElements: Record<string, TimelineKeyframe | null>;
    isReady: boolean;
    isBuffering: boolean;
    bufferMap: Record<string, boolean>;
    isMuted: boolean;
    playRequested: boolean;
    isPlaying: boolean;
    isFinished: boolean;
    volume: number;
    duration: number;
    primeTime: number;
    clockRunning: boolean;
    clockStartTime: number;
    currentPrime: TimelineKeyframe | null;
    clockStartRequests: number;
    startClock: () => void;
    stopClock: () => void;
    setElement: (id: string, element: HTMLVideoElement | HTMLAudioElement) => void;
    removeElement: (id: string) => void;
    applyKeyframes(newIdx: number, keyframes: TimelineKeyframe[]): void;
    nextKeyframeIndex: number;
    setProgressElement(div: HTMLDivElement): void;
    setCurrentTimeElement(div: HTMLDivElement): void;
    clearProgressElement(): void;
    clearCurrentTimeElement(): void;
}

declare function ComplexTimelineProvider({ children, store, }: {
    children: React.ReactNode;
    store: StoreApi$1<ComplexTimelineStore>;
}): react_jsx_runtime.JSX.Element;
declare function useComplexTimeline<T>(selector: (store: ComplexTimelineStore) => T): T;

interface EventContext {
    emitter: Emitter<any>;
}
declare const defaultEmitter: Emitter<Record<EventType, unknown>>;
declare const ReactEventContext: React__default.Context<{
    emitter: Emitter<Record<EventType, unknown>>;
}>;
declare function useEventEmitter<Events extends Record<EventType, unknown>>(): Emitter<Events>;
declare function EventsProvider({ emitter, children }: EventContext & {
    children: React__default.ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function ManifestContext({ manifest, children }: {
    manifest: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function useMediaState(): MediaPlayerState;
declare function useMediaActions(): MediaPlayerActions;
declare function useMediaElements(): {
    element: RefObject<HTMLAudioElement | HTMLVideoElement>;
    currentTime: RefObject<HTMLDivElement>;
    progress: RefObject<HTMLDivElement>;
};
declare function MediaPlayerProvider({ actions, state, children, currentTime, progress, element, }: {
    actions: MediaPlayerActions;
    state: MediaPlayerState;
    children: ReactNode;
    currentTime: RefObject<HTMLDivElement>;
    progress: RefObject<HTMLDivElement>;
    element: RefObject<HTMLAudioElement | HTMLVideoElement>;
}): react_jsx_runtime.JSX.Element;

declare function RangeContext({ range, children }: {
    range: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

type ResourceContextType = {
    collection?: string;
    manifest?: string;
    range?: string;
    canvas?: string;
    annotation?: string;
    annotationPage?: string;
};
declare const ResourceReactContext: React__default.Context<ResourceContextType>;
declare const useResourceContext: () => ResourceContextType;
declare function ResourceProvider({ value, children }: {
    value: ResourceContextType;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare const ReactVaultContext: React__default.Context<{
    vault: Vault | null;
    setVaultInstance: (vault: Vault) => void;
}>;
declare function VaultProvider({ vault, vaultOptions, useGlobal, resources, children, }: {
    vault?: Vault;
    useGlobal?: boolean;
    vaultOptions?: VaultOptions;
    resources?: ResourceContextType;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

type SearchService = SearchService$1 & {
    service: SearchServiceAutocomplete | SearchServiceAutocomplete[];
};
interface Search1Store {
    service: SearchService | undefined;
    lastQuery: SearchServiceQueryParams;
    resources: SearchServiceSearchResponse['resources'];
    loading: boolean;
    error: boolean;
    hasAutocomplete: boolean;
    hasSearch: boolean;
    errorMessage: string;
    highlight: SearchServiceSearchResponse['resources'][number] | null;
    search: (query: SearchServiceQueryParams, options?: {
        headers?: HeadersInit;
    }) => void;
    clearSearch: () => void;
    highlightResult: (id: string) => void;
    nextResult: () => void;
}

declare function useCustomContextBridge(): Record<string, {
    value: any;
    Provider: React__default.Provider<any>;
}>;
declare function CustomContextBridge(props: Record<string, {
    value: any;
    Provider: React__default.Provider<any>;
}> & {
    children: React__default.ReactNode;
}): ReactNode;
declare function CustomContextBridgeProvider(props: {
    providers: Record<string, Context<any>>;
    children: React__default.ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function useContextBridge(): {
    VaultContext: {
        vault: _iiif_helpers.Vault | null;
        setVaultInstance: (vault: _iiif_helpers.Vault) => void;
    };
    ResourceContext: ResourceContextType;
    SimpleViewerReactContext: SimpleViewerContext;
    VisibleCanvasReactContext: string[];
    AuthRContext: zustand.StoreApi<AuthContextState & AuthContextCurrentActions & AuthContextActions> | null;
    SearchReactContext: zustand.StoreApi<Search1Store> | null;
    ReactEventContext: {
        emitter: mitt.Emitter<Record<mitt.EventType, unknown>>;
    };
};
declare function ContextBridge(props: {
    bridge: ReturnType<typeof useContextBridge>;
    custom?: ReturnType<typeof useCustomContextBridge>;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare const VisibleCanvasReactContext: React__default.Context<string[]>;
declare function useVisibleCanvases(): CanvasNormalized[];

declare const ViewerPresetContext: React$1.Context<Preset | null | undefined>;
declare function useViewerPreset(): Preset | null | undefined;

declare const ImageServiceLoaderContext: React__default.Context<ImageServiceLoader>;
declare function useImageServiceLoader(): ImageServiceLoader;

type SelectorHelperEventTypes = 'click' | 'hover' | 'selector-updated' | 'highlight' | 'clear-highlight' | 'zoom-to' | 'event-listener' | 'remove-event-listener' | 'image-preview-request';
declare function SelectorControllerProvider({ children }: {
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function useSelectorEmitter(): mitt.Emitter<Record<mitt.EventType, unknown>>;
declare function useSelectorEvents(id: string): {
    controller: {
        withSelector(selectorId: string): {
            on<T extends {
                selectorId: string;
            } = any>(type: SelectorHelperEventTypes, handler: Handler<T>): () => void;
            emit<T_1 = any>(type: SelectorHelperEventTypes, event: T_1): void;
        };
        on<T_2 extends {
            selectorId: string;
        } = any>(type: SelectorHelperEventTypes, handler: Handler<T_2>): () => void;
        emit<T_3 extends {
            selectorId: string;
        } = any>(type: SelectorHelperEventTypes, event: T_3): void;
    };
    onClick: (e?: {
        x: number;
        y: number;
        width: number;
        height: number;
    }) => void;
    onHover: (e?: {
        x: number;
        y: number;
        width: number;
        height: number;
    }) => void;
    isHighlighted: boolean;
};
declare function useSelectorController(): {
    withSelector(selectorId: string): {
        on<T extends {
            selectorId: string;
        } = any>(type: SelectorHelperEventTypes, handler: Handler<T>): () => void;
        emit<T_1 = any>(type: SelectorHelperEventTypes, event: T_1): void;
    };
    on<T_2 extends {
        selectorId: string;
    } = any>(type: SelectorHelperEventTypes, handler: Handler<T_2>): () => void;
    emit<T_3 extends {
        selectorId: string;
    } = any>(type: SelectorHelperEventTypes, event: T_3): void;
};
declare function useSelectorHelper(): {
    withSelector(selectorId: string): {
        highlight(): void;
        clearHighlight(): void;
        zoomTo(): void;
        addEventListener(name: string, callback: () => void): () => void;
        getImagePreview(): Promise<any>;
        on<T extends {
            selectorId: string;
        } = any>(type: SelectorHelperEventTypes, handler: Handler<T>): () => void;
    };
    highlight(selectorId: string): void;
    clearHighlight(selectorId: string): void;
    zoomTo(selectorId: string): void;
    addEventListener(selectorId: string, name: string, callback: () => void): () => void;
    getImagePreview(selectorId: string): Promise<any>;
    on<T_1 extends {
        selectorId: string;
    } = any>(type: SelectorHelperEventTypes, handler: Handler<T_1>): () => void;
};

interface AnnotationStyles {
    id: number;
    name: string;
    creator?: {
        id: number;
        name: string;
    };
    createdAt: Date;
    theme: {
        default: AnnotationThemeDefinition;
        hidden: AnnotationThemeDefinition;
        highlighted: AnnotationThemeDefinition;
    } & Record<string, AnnotationThemeDefinition>;
}
type AnnotationThemeDefinition = BoxStyle & {
    hidden?: boolean;
    interactive?: boolean;
    hotspot?: boolean;
    hotspotSize?: 'lg' | 'md' | 'sm';
};
declare function getDefaultAnnotationStyles(): AnnotationStyles['theme'];
declare function useAnnotationStyles(): {
    default: AnnotationThemeDefinition;
    hidden: AnnotationThemeDefinition;
    highlighted: AnnotationThemeDefinition;
} & Record<string, AnnotationThemeDefinition>;
declare function AnnotationStyleProvider({ theme, children, }: {
    theme?: AnnotationStyles['theme'];
    children: React.ReactNode;
}): react_jsx_runtime.JSX.Element;

interface StrategyContext {
    strategy: RenderingStrategy;
    choices: ChoiceDescription | null;
}
declare const StrategyReactContext: React$1.Context<StrategyContext | null>;
declare function useStrategy(): StrategyContext;

interface ControlsContext {
    renderMediaControls?: (strategy: MediaStrategy) => ReactNode;
    viewControlsDeps: any[];
    renderViewerControls?: (strategy: SingleImageStrategy | EmptyStrategy) => ReactNode;
    mediaControlsDeps: any[];
    renderComplexTimelineControls?: (strategy: ComplexTimelineStrategy) => ReactNode;
    complexTimelineControlsDeps: any[];
}
declare const ControlsReactContext: React$1.Context<ControlsContext | null>;
declare function useRenderControls(): ControlsContext;

declare function getVideoStrategy(canvas: CanvasNormalized, paintables: Paintables, vault: CompatVault): UnknownStrategy | MediaStrategy;

declare function getComplexTimelineStrategy(canvas: CanvasNormalized, paintables: Paintables, loadImageService: ImageServiceLoaderType, vault: CompatVault): ComplexTimelineStrategy;

declare function useAnnotation(options?: {
    id: string;
}): AnnotationNormalized | undefined;
declare function useAnnotation<T>(options?: {
    id: string;
    selector: (annotation: AnnotationNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useAnnotationPage(options?: {
    id: string;
}): AnnotationPageNormalized | undefined;
declare function useAnnotationPage<T>(options?: {
    id: string;
    selector: (annotation: AnnotationPageNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useAnnotationPageManager(resourceId?: string, options?: {
    all?: boolean;
}): {
    availablePageIds: string[];
    enabledPageIds: string[];
    setPageEnabled: (id: string, opt?: {
        deselectOthers?: boolean;
    }) => void;
    setPageDisabled: (deselectId: string) => void;
};

declare function useAnnotationsAtTime(time: number, options?: {
    canvasId?: string;
}): AnnotationNormalized[];

declare function useCanvas(options?: {
    id: string;
}): CanvasNormalized | undefined;
declare function useCanvas<T>(options?: {
    id: string;
    selector: (canvas: CanvasNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useCanvasChoices({ canvasId }?: {
    canvasId?: string;
}): {
    choices: Array<{
        canvasId: string;
        choice: ComplexChoice;
    }>;
    actions: {
        makeChoice: (id: string, options?: {
            deselectOthers?: boolean;
            deselect?: boolean;
        }) => void;
    };
};

declare function useCanvasClock(canvasId?: string, autoplay?: boolean): void;

declare function useCanvasSubset(idsOrRefs?: Array<string | Reference>): Reference<'Canvas'>[];

declare function useCanvasStartTime(): {
    startTime: number;
    endTime?: number | undefined;
} | null;

declare function useCollection(options: {
    id: string;
}): CollectionNormalized | undefined;
declare function useCollection<T>(options: {
    id: string;
    selector: (collection: CollectionNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useDispatch(): VaultZustandStore['dispatch'];

type SupportedEvents = 'onClick';
declare function useEventListener<T>(resource: Reference, name: SupportedEvents, listener: (e: any, resource: T) => void, scope?: string[], deps?: any[]): void;

declare function useExistingVault(vault?: Vault): Vault;

type ResourceRequestOptions = {
    noCache?: boolean;
};
declare function useExternalResource<T extends {
    id: string;
}>(idOrRef: string | {
    id: string;
    type: string;
}, { noCache }?: ResourceRequestOptions): {
    id: string;
    requestId: string;
    isLoaded: boolean;
    error: any;
    cached: boolean;
    resource?: T;
};

declare function useExternalCollection(idOrRef: string | {
    id: string;
    type: string;
}, options?: ResourceRequestOptions): {
    id: string;
    requestId: string;
    isLoaded: boolean;
    cached?: boolean;
    error: any;
    manifest?: CollectionNormalized;
};

declare function useExternalManifest(idOrRef: string | {
    id: string;
    type: string;
}, options?: ResourceRequestOptions): {
    id: string;
    requestId: string;
    isLoaded: boolean;
    cached?: boolean;
    error: any;
    manifest?: ManifestNormalized;
};

declare function useImage(service: ImageService$1 | undefined, data?: {
    size?: Partial<ImageSize>;
    selector?: RegionParameter;
    rotation?: number | RotationParameter;
    format?: string;
    region?: RegionParameter;
    quality?: string;
}, deps?: any[]): string | null;

interface ImageServiceRequestOptions {
    cacheKey?: string;
}
/**
 * Returns the First image service on the current canvas.
 *
 * @note It is better to use the hook useRenderingStrategy for rendering.
 */
declare function useImageService({ cacheKey }?: ImageServiceRequestOptions): {
    data: ImageService$1 | undefined;
    isFetching: boolean;
    status: 'error' | 'success' | 'loading' | 'idle';
};

declare function useImageTile(): {
    isLoading: boolean;
    tile: {
        id: string | undefined;
        width: number | null | undefined;
        height: number | null | undefined;
        imageService: ImageService$1;
        thumbnail: undefined;
    } | null;
};

declare function useManifest(options?: {
    id: string;
}): ManifestNormalized | undefined;
declare function useManifest<T>(options?: {
    id: string;
    selector: (manifest: ManifestNormalized) => T;
}, deps?: any[]): T | undefined;

declare function usePaintables(options?: {
    defaultChoices?: string[];
    enableSingleAnnotation?: boolean;
}, deps?: any[]): readonly [_iiif_helpers_painting_annotations.Paintables, {
    makeChoice: (id: string, { deselectOthers, deselect }?: {
        deselectOthers?: boolean;
        deselect?: boolean;
    }) => void;
}];

declare function usePaintingAnnotations(options?: {
    canvasId?: string;
    enableSingleAnnotation?: boolean;
}): AnnotationNormalized[];

declare function useRange(options?: {
    id: string;
}): RangeNormalized | undefined;
declare function useRange<T>(options?: {
    id: string;
    selector: (range: RangeNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useResourceEvents<T extends NormalizedEntity>(resource?: Reference, scope?: string[]): any;

declare function useResources<Type>(ids: string[], type: string): Type[];

declare function useSearchService(): SearchService$1 | undefined;

declare function useStyleHelper(): _iiif_helpers_styles.StyledHelper<_iiif_helpers_styles.StyleDefinition>;

declare function useStyles<Style extends Record<string, Record<string, any>>>(resource: undefined | Reference<any>): Style;
declare function useStyles<Style extends Record<string, any>>(resource: undefined | Reference<any>, scope: string): Style;

declare function useThumbnail(request: ImageCandidateRequest, dereference?: boolean, { canvasId, manifestId }?: {
    canvasId?: string;
    manifestId?: string;
}): ImageCandidate | undefined;

declare const useVault: () => Vault;

declare const useVaultEffect: (callback: (vault: Vault) => void, deps?: any[]) => void;

declare function useVaultSelector<T>(selector: (state: IIIFStore, vault: Vault) => T, deps?: any[]): T;

interface VaultActivatedAnnotation {
    __vault?: Vault;
    bindToVault(vault: Vault): void;
    source: string | {
        id: string;
    };
}
declare function useVirtualAnnotationPage(): readonly [AnnotationPageNormalized | null, {
    readonly addAnnotation: (id: string | Annotation | VaultActivatedAnnotation | AnnotationNormalized, atIndex?: number) => void;
    readonly removeAnnotation: (id: string | Annotation | VaultActivatedAnnotation | AnnotationNormalized) => void;
}];

declare function useVirtualAnnotationPageContext(): [AnnotationPageNormalized | null, {
    addAnnotation: (id: string | Annotation | VaultActivatedAnnotation | AnnotationNormalized, atIndex?: number | undefined) => void;
    removeAnnotation: (id: string | Annotation | VaultActivatedAnnotation | AnnotationNormalized) => void;
}];
declare function VirtualAnnotationProvider({ children }: {
    children: any;
}): react_jsx_runtime.JSX.Element;

declare function usePolygonHelper(data: any, render: (t: any, s: any) => void, commitShape: (shape: InputShape) => void): {
    state: SlowState;
    helper: {
        draw: {
            enable(): void;
            disable(): void;
            toggle(): void;
        };
        state: polygon_editor.RenderState;
        modifiers: {
            reset(): void;
            getForType(type: string | null): Record<string, string>;
            set(modifier: string): void;
            unset(modifier: string): void;
        };
        stamps: {
            set(selectedStamp: InputShape | null): void;
            clear(): void;
            square(): void;
            triangle(): void;
            pentagon(): void;
            hexagon(): void;
        };
        key: {
            down(key: string): true | undefined;
            up(key: string): void;
        };
        setScale: (scale: number) => void;
        clock: {
            set: (renderFunc: polygon_editor.RenderFunc) => void;
            start: (renderFunc?: polygon_editor.RenderFunc | undefined, setStateFunc?: polygon_editor.SetState | undefined) => void;
            stop: () => void;
            step: (deltaTime?: number | undefined) => void;
        };
        pointer: (pointers: ([number, number] | [number, number, number, number, number, number])[]) => void;
        blur: () => void;
        pointerDown: () => void;
        pointerUp: () => void;
        setShape: (shape: InputShape | null) => void;
        modes: {
            toggleLineBoxMode: () => void;
            toggleLineMode: () => void;
            enableLineMode(): void;
            disableLineMode(): void;
            enableLineBoxMode(): void;
            disableLineBoxMode(): void;
        };
        label: (type: string | null) => string;
    };
};

declare function flattenAnnotationPageIds({ canvas, manifest, all, canvases, }: {
    manifest?: ManifestNormalized;
    canvas?: CanvasNormalized;
    canvases?: CanvasNormalized[];
    all?: boolean;
}): string[];

declare function TranslationProvider(props: {
    translations: Record<string, string>;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function LanguageProvider(props: {
    language: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function TransliterationProvider(props: {
    convert: null | ((input: string, targetLang: string) => string);
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function useTransliteration(): ((input: string, targetLang: string) => string) | null;
declare function useIIIFLanguage(): string;
declare function useTranslations(): Record<string, string>;
type LanguageStringProps = {
    [key: string]: any;
} & {
    as?: string | React__default.FC<any>;
    language: string;
    viewingDirection?: 'rtl' | 'rtl';
};
declare function LanguageString({ as: Component, language, children, viewingDirection, ...props }: LanguageStringProps): react_jsx_runtime.JSX.Element;
declare const useClosestLanguage: (getLanguages: () => string[], deps?: any[]) => string | undefined;
declare function useLocaleString(inputText: InternationalString | string | null | undefined, defaultText?: string, separator?: string, translations?: Record<string, string>): readonly [string, string | undefined];
declare function useCreateLocaleString(): (inputText: InternationalString | string | null | undefined, defaultText?: string, separator?: string, translations?: Record<string, string>) => string;
type LocaleStringProps = {
    as?: string | React__default.FC<any>;
    defaultText?: string;
    to?: string;
    separator?: string;
    enableDangerouslySetInnerHTML?: boolean;
    children: InternationalString | string | null | undefined;
    style?: React__default.CSSProperties;
    extraProps?: any;
} & Record<string, any>;
declare function LocaleString({ as: Component, defaultText, enableDangerouslySetInnerHTML, children, separator, ...props }: LocaleStringProps): react_jsx_runtime.JSX.Element;

declare const SimpleViewerReactContext: React__default.Context<SimpleViewerContext>;
declare function InnerViewerProvider(props: SimpleViewerProps): react_jsx_runtime.JSX.Element | null;
declare function SimpleViewerProvider(props: SimpleViewerProps): react_jsx_runtime.JSX.Element;
declare function useSimpleViewer(): SimpleViewerContext;

declare function useCanvasSequence({ startCanvas, disablePaging }: {
    startCanvas?: string;
    disablePaging?: boolean;
}): {
    visibleItems: string[];
    cursor: number;
    items: {
        type: "Canvas";
        id: string;
    }[];
    sequence: number[][];
    hasPrevious: boolean;
    hasNext: boolean;
    setSequenceIndex: React$1.Dispatch<React$1.SetStateAction<number>>;
    setCanvasIndex: (index: number) => void;
    setCanvasId: (id: string) => void;
    next: () => void;
    previous: () => void;
};

/**
 * Get visible canvases from canvas ID
 *
 * This function returns a list of canvas references that should all be displayed
 * when the passed canvasId is visible. This should work for individual items,
 * 2-up paged view and continuous (scrolls).
 *
 * The options are listed below (from IIIF docs)
 *
 * - `unordered` - Valid on Collections, Manifests and Ranges. The Canvases included in resources that have this behavior
 *    have no inherent order, and user interfaces should avoid implying an order to the user. Disjoint with individuals,
 *    continuous, and paged.
 *
 * - `individuals` - Valid on Collections, Manifests, and Ranges. For Collections that have this behavior, each of the
 *    included Manifests are distinct objects in the given order. For Manifests and Ranges, the included Canvases are
 *    distinct views, and should not be presented in a page-turning interface. This is the default layout behavior if
 *    not specified. Disjoint with unordered, continuous, and paged.
 *
 * - `continuous`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and
 *    width dimensions. Canvases included in resources that have this behavior are partial views and an appropriate
 *    rendering might display all of the Canvases virtually stitched together, such as a long scroll split into
 *    sections. This behavior has no implication for audio resources. The viewingDirection of the Manifest will
 *    determine the appropriate arrangement of the Canvases. Disjoint with unordered, individuals and paged.
 *
 * - `paged`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and width
 *    dimensions. Canvases included in resources that have this behavior represent views that should be presented in
 *    a page-turning interface if one is available. The first canvas is a single view (the first recto) and thus the
 *    second canvas likely represents the back of the object in the first canvas. If this is not the case, see the
 *    behavior value non-paged. Disjoint with unordered, individuals, continuous, facing-pages and non-paged.
 *
 */
declare function getVisibleCanvasesFromCanvasId(vault: Vault, manifestOrRange: ManifestNormalized | RangeNormalized, canvasId: string | null, preventPaged?: boolean): Reference<'Canvas'>[];
declare function getManifestSequence(vault: Vault, manifestOrRange: ManifestNormalized | RangeNormalized, { disablePaging, skipNonPaged }?: {
    disablePaging?: boolean;
    skipNonPaged?: boolean;
}): [Reference<'Canvas'>[], number[][]];

declare function findFirstCanvasFromRange(vault: Vault, range: RangeNormalized): null | Reference<'Canvas'>;
declare function findAllCanvasesInRange(vault: Vault, range: RangeNormalized): Array<Reference<'Canvas'>>;
declare function findManifestSelectedRange(vault: Vault, manifest: ManifestNormalized, canvasId: string): null | RangeNormalized;
declare function findSelectedRange(vault: Vault, range: RangeNormalized, canvasId: string): null | RangeNormalized;

export { AnnotationContext, AnnotationPageContext, type AnnotationStrategyProps, AnnotationStyleProvider, type AnnotationStyles, type AnnotationThemeDefinition, Auth, type AuthAccessState, type AuthContextActions, type AuthContextCurrentActions, type AuthContextState, AuthProvider, AuthRContext, AuthReactContext, AuthReactContextActions, type AuthState, CanvasAnnotations, CanvasContext, CanvasStrategyProvider, CanvasWorldObject, CollectionContext, CombinedMetadata, ComplexTimelineProvider, ComplexTimelineStrategy, ContextBridge, type ControlsContext, ControlsReactContext, CreateCustomShape, type CreateCustomShapeProps, CustomContextBridge, CustomContextBridgeProvider, EmptyStrategy, EventsProvider, Image, type ImageProps, ImageService, ImageServiceLoaderContext, ImageServiceLoaderType, type ImageServiceRequestOptions, type ImageStrategyProps, ImageWithOptionalService, InnerViewerProvider, LanguageProvider, LanguageString, LocaleString, ManifestContext, ManifestMetadata, type MediaPlayerActions, MediaPlayerProvider, type MediaPlayerState, MediaStrategy, Metadata, type MetadataProps, PolygonSelector, type PolygonSelectorProps, type ProbeStore, RangeContext, ReactEventContext, ReactVaultContext, Render3DModelStrategy, RenderAccompanyingCanvas, RenderAnnotationStrategy, RenderAudioStrategy, RenderComplexTimelineStrategy, RenderEmptyStrategy, RenderImageStrategy, RenderSvgEditorControls, RenderTextualContentStrategy, RenderVideoStrategy, RenderYouTubeStrategy, RenderingStrategy, type ResourceContextType, ResourceProvider, ResourceReactContext, type ResourceRequestOptions, SelectorControllerProvider, type SelectorHelperEventTypes, SequenceThumbnails, SimpleViewerContext, SimpleViewerProps, SimpleViewerProvider, SimpleViewerReactContext, SingleCanvasThumbnail, SingleImageStrategy, StrategyActions, type StrategyContext, StrategyReactContext, type SvgTheme, ThumbnailFallbackImage, TimelineKeyframe, TranslationProvider, TransliterationProvider, UnknownStrategy, type VaultActivatedAnnotation, VaultProvider, ViewerPresetContext, VirtualAnnotationProvider, VisibleCanvasReactContext, authDetailsForResource, createAuthStateStore, createProbe, defaultEmitter, findAllCanvasesInRange, findFirstCanvasFromRange, findManifestSelectedRange, findSelectedRange, flattenAnnotationPageIds, formatTime, getComplexTimelineStrategy, getDefaultAnnotationStyles, getManifestSequence, getVideoStrategy, getVisibleCanvasesFromCanvasId, hasAuth, makeAccessServiceRequest, makeAccessTokenRequest, svgThemes, useAnnotation, useAnnotationPage, useAnnotationPageManager, useAnnotationStyles, useAnnotationsAtTime, useAuthActions, useAuthService, useAuthStore, useAuthToken, useAuthTokens, useCanvas, useCanvasChoices, useCanvasClock, useCanvasSequence, useCanvasStartTime, useCanvasSubset, useClosestLanguage, useCollection, useComplexTimeline, useContextBridge, useCreateLocaleString, useCurrentAuth, useCustomContextBridge, useDispatch, useEventEmitter, useEventListener, useExistingVault, useExternalCollection, useExternalManifest, useExternalResource, useIIIFLanguage, useImage, useImageService, useImageServiceLoader, useImageTile, useIsAuthEnabled, useLocaleString, useManifest, useMediaActions, useMediaElements, useMediaState, usePaintables, usePaintingAnnotations, usePolygonHelper, useRange, useRenderControls, useResourceContext, useResourceEvents, useResources, useSearchService, useSelectorController, useSelectorEmitter, useSelectorEvents, useSelectorHelper, useSimpleMediaPlayer, useSimpleViewer, useStrategy, useStyleHelper, useStyles, useSvgEditor, useThumbnail, useTranslations, useTransliteration, useVault, useVaultEffect, useVaultSelector, useViewerPreset, useVirtualAnnotationPage, useVirtualAnnotationPageContext, useVisibleCanvases };
