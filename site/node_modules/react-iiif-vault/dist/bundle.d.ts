import * as React$1 from 'react';
import React__default, { ReactNode, FC, ComponentType, RefObject, ForwardRefExoticComponent, RefAttributes, FunctionComponent, Context } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { AtlasProps, Preset, BoxStyle, ViewerMode } from '@atlas-viewer/atlas';
import { AnnotationPage, ImageService as ImageService$1, ExternalWebResource, InternationalString, Reference, ImageSize, AuthProbeService2, Auth2LocationResource, Auth2SubstituteResource, AuthAccessService2, AuthAccessTokenService2, AuthAccessToken2, SearchServiceQueryParams, SearchServiceSearchResponse, SearchService as SearchService$1, SearchServiceAutocomplete, ContentResource, W3CAnnotationTarget, PointSelector, Annotation } from '@iiif/presentation-3';
import { AnnotationPageNormalized, AnnotationNormalized, CanvasNormalized, CollectionNormalized, ManifestNormalized, RangeNormalized } from '@iiif/presentation-3-normalized';
import * as _iiif_helpers from '@iiif/helpers';
import { ChoiceDescription, Paintables, SupportedTarget, ComplexChoice, ImageCandidate, BoxSelector as BoxSelector$1, TemporalBoxSelector as TemporalBoxSelector$1 } from '@iiif/helpers';
import { BoxSelector, TemporalBoxSelector, TemporalSelector } from '@iiif/helpers/annotation-targets';
export * from '@iiif/helpers/annotation-targets';
import * as mitt from 'mitt';
import { Emitter, EventType, Handler } from 'mitt';
import * as _iiif_helpers_vault from '@iiif/helpers/vault';
import { Vault, VaultOptions, NormalizedEntity, IIIFStore } from '@iiif/helpers/vault';
import { RegionParameter, RotationParameter, SizeParameter } from '@iiif/parser/image-3';
import * as polygon_editor from 'polygon-editor';
import { RenderState, InputShape, SlowState } from 'polygon-editor';
import * as zustand_vanilla from 'zustand/vanilla';
import { StoreApi } from 'zustand/vanilla';
import * as zustand from 'zustand';
import { StoreApi as StoreApi$1 } from 'zustand';
import { ImageServiceLoader, ImageCandidateRequest, ImageCandidate as ImageCandidate$1 } from '@iiif/helpers/image-service';
import * as _iiif_helpers_painting_annotations from '@iiif/helpers/painting-annotations';
import { Paintables as Paintables$1 } from '@iiif/helpers/painting-annotations';
import { VaultZustandStore } from '@iiif/helpers/vault/store';
import * as _iiif_helpers_styles from '@iiif/helpers/styles';

declare function Viewer({ children, errorFallback, outerContainerProps, worldScale: _worldScale, ...props }: AtlasProps & {
    height?: number | string;
    width?: number | string;
    resizeHash?: number;
    containerProps?: any;
    outerContainerProps?: any;
    aspectRatio?: number;
    errorFallback?: any;
    renderPreset?: Preset;
    worldScale?: number;
} & {
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare const RenderAnnotation: FC<{
    id: string;
    className?: string;
    style?: BoxStyle;
    interactive?: boolean;
}>;

declare const RenderAnnotationPage: FC<{
    page: AnnotationPage | AnnotationPageNormalized;
    className?: string;
}>;

type ImageWithOptionalService = {
    id: string;
    annotationId: string;
    annotation: AnnotationNormalized;
    type: 'Image';
    service?: ImageService$1;
    width?: number;
    height?: number;
    sizes?: Array<{
        width: number;
        height: number;
    }>;
    target: BoxSelector | TemporalBoxSelector;
    selector?: BoxSelector;
};
type SingleAudio = {
    type: 'Sound';
    annotationId: string;
    annotation: AnnotationNormalized;
    url: string;
    format: string;
    duration: number;
    target: TemporalSelector;
    /**
     * Which part of this audio should be used (cropping).
     */
    selector: TemporalSelector;
};
type SingleYouTubeVideo = {
    type: 'VideoYouTube';
    annotationId: string;
    annotation: AnnotationNormalized;
    url: string;
    youTubeId: string;
    duration: number;
    target: TemporalSelector | TemporalBoxSelector;
    selector: TemporalSelector | TemporalBoxSelector;
};
type SingleVideo = {
    type: 'Video';
    annotationId: string;
    annotation: AnnotationNormalized;
    url: string;
    format: string;
    duration: number;
    /**
     * Where on the canvas should this section of video be painted.
     */
    target: TemporalSelector | TemporalBoxSelector;
    /**
     * Which part of this video should be painted.
     */
    selector: TemporalSelector | TemporalBoxSelector;
};
type AudioSequence = {
    type: 'SoundSequence';
    items: SingleAudio[];
};
type VideoSequence = {
    type: 'VideoSequence';
    items: SingleVideo[];
};
type AnnotationPageDescription = {
    pages: AnnotationPageNormalized[];
};

type ImageServiceLoaderType = (imageService: any | undefined, { height, width }: {
    height: number;
    width: number;
}) => ImageService$1 | undefined;
declare function useLoadImageService(): readonly [ImageServiceLoaderType, Record<string, {
    status: "error" | "loading" | "done";
    service: ImageService$1 | null;
    error?: boolean | undefined;
    errorMesage?: string | undefined;
    real?: boolean | undefined;
}>];

type SingleImageStrategy = {
    type: 'images';
    image: ImageWithOptionalService;
    images: Array<ImageWithOptionalService>;
    choice?: ChoiceDescription;
    annotations?: AnnotationPageDescription;
};
declare function getImageStrategy(canvas: CanvasNormalized, paintables: Paintables, loadImageService: ImageServiceLoaderType): SingleImageStrategy | UnknownStrategy;

type Single3DModelStrategy = {
    type: '3d-model';
    model: ExternalWebResource;
    choice?: ChoiceDescription;
    annotations?: AnnotationPageDescription;
    annotation: AnnotationNormalized;
    annotationId: string;
};
declare function get3dStrategy(canvas: CanvasNormalized, paintables: Paintables): RenderingStrategy;

type TextualContentStrategy = {
    type: 'textual-content';
    items: TextContent[];
    choice?: ChoiceDescription;
    annotations?: AnnotationPageDescription;
};
type TextContent = {
    type: 'Text';
    text: InternationalString;
    target: SupportedTarget | null;
    annotationId: string;
    annotation: AnnotationNormalized;
};
declare function getTextualContentStrategy(canvas: CanvasNormalized, paintables: Paintables): RenderingStrategy;

type MediaStrategy = {
    type: 'media';
    media: SingleAudio | SingleVideo | AudioSequence | VideoSequence | SingleYouTubeVideo;
    choice?: ChoiceDescription;
    annotations?: AnnotationPageDescription;
    captions?: Array<{
        id: string;
        type: string;
        format: string;
        label?: InternationalString;
        language?: string;
    }>;
};
type ComplexTimelineStrategy = {
    type: 'complex-timeline';
    items: Array<SingleImageStrategy['image'] | SingleAudio | SingleVideo | SingleYouTubeVideo | TextContent>;
    keyframes: TimelineKeyframe[];
    duration: number;
    choice?: ChoiceDescription;
    annotations?: AnnotationPageDescription;
};
interface TimelineKeyframe {
    id: string;
    type: 'enter' | 'exit' | 'change';
    resourceType: 'image' | 'audio' | 'video' | 'text';
    timeDelta?: number;
    isPrime?: boolean;
    time: number;
}
type EmptyStrategy = {
    type: 'empty';
    image: null;
    images: [];
    height: number;
    width: number;
    annotations?: AnnotationPageDescription;
};
type UnknownStrategy = {
    type: 'unknown';
    reason?: string;
    annotations?: AnnotationPageDescription;
};
type RenderingStrategy = SingleImageStrategy | MediaStrategy | ComplexTimelineStrategy | Single3DModelStrategy | TextualContentStrategy | UnknownStrategy | EmptyStrategy;

type StrategyActions = {
    makeChoice: (id: string, options?: {
        deselectOthers?: boolean;
        deselect?: boolean;
    }) => void;
};
type UseRenderingStrategy = [RenderingStrategy, StrategyActions];
type ChoiceEvents = {
    'choice-change': {
        choice: ComplexChoice;
        partOf: {
            canvasId?: string;
            manifestId?: string;
        };
    };
    'make-choice': {
        choiceId: string;
        deselectOthers?: boolean;
        deselect?: boolean;
    };
};
type UseRenderingStrategyOptions = {
    strategies?: Array<RenderingStrategy['type']>;
    annotationPageManagerId?: string;
    enableSingleAnnotation?: boolean;
    defaultChoices?: string[];
    emitter?: Emitter<ChoiceEvents>;
};
declare function useRenderingStrategy(options?: UseRenderingStrategyOptions): UseRenderingStrategy;

interface AudioComponentProps {
    media: SingleAudio;
    startTime?: number | null;
    children: ReactNode;
}
declare function AudioHTML({ media, startTime, children }: AudioComponentProps): react_jsx_runtime.JSX.Element;
declare function Audio({ media, mediaControlsDeps, audioCopmonent, children, }: {
    media: SingleAudio;
    mediaControlsDeps?: any[];
    children: ReactNode;
    audioCopmonent?: ComponentType<AudioComponentProps>;
}): null;

interface VideoComponentProps {
    element: RefObject<HTMLVideoElement>;
    media: SingleVideo;
    playPause: () => void;
    canvas: CanvasNormalized;
    poster?: string;
    startTime?: number;
    captions?: MediaStrategy['captions'];
}
declare function VideoHTML({ element, media, startTime, playPause, poster, }: VideoComponentProps): react_jsx_runtime.JSX.Element;
declare function Video({ media, mediaControlsDeps, children, videoComponent, captions, }: {
    media: SingleVideo;
    mediaControlsDeps?: any[];
    children: ReactNode;
    posterCanvasId?: string;
    videoComponent?: ComponentType<VideoComponentProps>;
    captions?: MediaStrategy['captions'];
}): null;

type CanvasProps = {
    x?: number;
    y?: number;
    onCreated?: any;
    onChoiceChange?: (choice?: ChoiceDescription) => void;
    registerActions?: (actions: StrategyActions) => void;
    defaultChoices?: Array<{
        id: string;
        opacity?: number;
    }>;
    isStatic?: boolean;
    keepCanvasScale?: boolean;
    children?: ReactNode;
    renderViewerControls?: (strategy: SingleImageStrategy | EmptyStrategy) => ReactNode;
    viewControlsDeps?: any[];
    renderMediaControls?: (strategy: MediaStrategy) => ReactNode;
    renderComplexTimelineControls?: (strategy: ComplexTimelineStrategy) => ReactNode;
    complexTimelineControlsDeps?: any[];
    mediaControlsDeps?: any[];
    strategies?: Array<RenderingStrategy['type']>;
    backgroundStyle?: BoxStyle;
    alwaysShowBackground?: boolean;
    enableSizes?: boolean;
    enableYouTube?: boolean;
    ignoreSize?: boolean;
    throwOnUnknown?: boolean;
    onClickPaintingAnnotation?: (id: string, image: ImageWithOptionalService, e: any) => void;
    components?: {
        Video?: React__default.ComponentType<VideoComponentProps>;
        Audio?: React__default.ComponentType<AudioComponentProps>;
    };
};
declare function RenderCanvas({ x, y, onChoiceChange, registerActions, defaultChoices, isStatic, renderViewerControls, renderMediaControls, renderComplexTimelineControls, complexTimelineControlsDeps, viewControlsDeps, mediaControlsDeps, strategies, throwOnUnknown, backgroundStyle, alwaysShowBackground, keepCanvasScale, enableSizes, enableYouTube, onClickPaintingAnnotation, components, children, }: CanvasProps): react_jsx_runtime.JSX.Element;

declare function RenderImage({ id, image, thumbnail, isStatic, x, y, children, selector, onClick, enableSizes, }: {
    id: string;
    image: ImageWithOptionalService;
    thumbnail?: ImageCandidate;
    isStatic?: boolean;
    enableSizes?: boolean;
    selector?: BoxSelector$1;
    x?: number;
    y?: number;
    children?: ReactNode;
    onClick?: (e: any) => void;
}): react_jsx_runtime.JSX.Element;

declare function CanvasBackground({ style }: {
    style?: BoxStyle;
}): react_jsx_runtime.JSX.Element | null;

type SimpleViewerContext = {
    items: Reference<'Canvas'>[];
    sequence: number[][];
    hasNext: boolean;
    hasPrevious: boolean;
    setSequenceIndex: (newId: number) => void;
    setCurrentCanvasId: (newId: string) => void;
    setCurrentCanvasIndex: (newId: number) => void;
    currentSequenceIndex: number;
    nextCanvas: () => void;
    previousCanvas: () => void;
};
type SimpleViewerProps = {
    vault?: Vault;
    manifest: string;
    pagingEnabled?: boolean;
    children: ReactNode;
    startCanvas?: string;
    rangeId?: string;
};
type SimpleViewerReducerState = {
    sequence: number[][];
    availableCanvases: Reference<'Canvas'>[];
    visibleCanvases: Reference<'Canvas'>[];
    currentCanvas: string | null;
    isPaged: boolean;
    rangeId: string | null;
};
interface SimpleViewerActions {
    setCurrentCanvasId(newId: string): void;
    setCurrentCanvasIndex(newId: number): void;
    nextCanvas(): void;
    previousCanvas(): void;
    setCurrentRange(newId: string): void;
    clearRange(): void;
    setPagingEnabled(isEnabled: boolean): void;
}
type SimpleViewerActionsType = {
    [T in keyof SimpleViewerActions]: {
        type: T;
        payload: Parameters<SimpleViewerActions[T]>[0];
    };
}[keyof SimpleViewerActions];

declare function ModelHTML({ model }: {
    model: any;
}): react_jsx_runtime.JSX.Element;
declare function Model({ model, name }: {
    model: any;
    name?: string;
}): null;

interface PlaceholderCanvasProps {
    renderViewerControls?: (strategy: SingleImageStrategy | EmptyStrategy) => ReactNode;
}
declare function PlaceholderCanvas(props: PlaceholderCanvasProps): react_jsx_runtime.JSX.Element | null;

interface CanvasPanelProps {
    manifest: string;
    startCanvas?: string;
    rangeId?: string;
    pagingEnabled?: boolean;
    header?: ReactNode;
    children?: ReactNode;
    mode?: ViewerMode;
    reuseAtlas?: boolean;
    runtimeOptions?: any;
    renderPreset?: any;
    height?: number;
    spacing?: number;
    components?: {
        ViewerControls?: FC;
        MediaControls?: FC;
        ComplexTimelineControls?: FC;
    };
    canvasProps?: Omit<Partial<CanvasProps>, 'x'>;
    annotations?: ReactNode;
}
type CanvasPanelType = ForwardRefExoticComponent<CanvasPanelProps & RefAttributes<SimpleViewerContext>> & {
    RenderImage: typeof RenderImage;
    RenderCanvas: typeof RenderCanvas;
    RenderAnnotationPage: typeof RenderAnnotationPage;
    RenderAnnotation: typeof RenderAnnotation;
    Viewer: typeof Viewer;
    CanvasBackground: typeof CanvasBackground;
    Audio: typeof Audio;
    Video: typeof Video;
    Model: typeof Model;
    AudioHTML: typeof AudioHTML;
    VideoHTML: typeof VideoHTML;
    ModelHTML: typeof ModelHTML;
    PlaceholderCanvas: typeof PlaceholderCanvas;
};
declare const CanvasPanel: CanvasPanelType;

interface CanvasStrategyProviderProps {
    onChoiceChange?: (choice?: ChoiceDescription) => void;
    strategies?: Array<RenderingStrategy['type']>;
    registerActions?: (actions: StrategyActions) => void;
    defaultChoices?: Array<{
        id: string;
        opacity?: number;
    }>;
    children: ReactNode;
    renderMediaControls?: (strategy: MediaStrategy) => ReactNode;
    viewControlsDeps?: any[];
    renderViewerControls?: (strategy: SingleImageStrategy | EmptyStrategy) => ReactNode;
    renderComplexTimelineControls?: (strategy: ComplexTimelineStrategy) => ReactNode;
    complexTimelineControlsDeps?: any[];
    mediaControlsDeps?: any[];
    throwOnUnknown?: boolean;
}
declare function CanvasStrategyProvider({ strategies, registerActions, defaultChoices, onChoiceChange, mediaControlsDeps, renderMediaControls, renderViewerControls, viewControlsDeps, renderComplexTimelineControls, complexTimelineControlsDeps, throwOnUnknown, children, }: CanvasStrategyProviderProps): react_jsx_runtime.JSX.Element;

interface CanvasWorldObjectProps {
    x?: number;
    y?: number;
    keepCanvasScale?: boolean;
    children?: ReactNode;
}
declare function CanvasWorldObject({ x, y, keepCanvasScale, children }: CanvasWorldObjectProps): react_jsx_runtime.JSX.Element | null;

declare function ThumbnailFallbackImage({ x, y }: {
    x?: number;
    y?: number;
}): react_jsx_runtime.JSX.Element | null;

interface RenderEmptyStrategyProps {
    backgroundStyle?: BoxStyle;
    alwaysShowBackground?: boolean;
}
declare function RenderEmptyStrategy({ backgroundStyle, alwaysShowBackground }: RenderEmptyStrategyProps): react_jsx_runtime.JSX.Element | null;

declare function RenderComplexTimelineStrategy(): react_jsx_runtime.JSX.Element | null;

interface TextualContextStrategyProps {
    onClickPaintingAnnotation?: (id: string, e: any) => void;
    children?: ReactNode;
}
declare function RenderTextualContentStrategy({ onClickPaintingAnnotation, children }: TextualContextStrategyProps): react_jsx_runtime.JSX.Element | null;

interface ImageStrategyProps {
    isStatic?: boolean;
    enableSizes?: boolean;
    onClickPaintingAnnotation?: (id: string, image: ImageWithOptionalService, e: any) => void;
    children?: ReactNode;
}
declare function RenderImageStrategy({ isStatic, enableSizes, onClickPaintingAnnotation, children, }: ImageStrategyProps): react_jsx_runtime.JSX.Element | null;

declare function Render3DModelStrategy(): react_jsx_runtime.JSX.Element | null;

interface AnnotationStrategyProps {
    children?: ReactNode;
}
declare function RenderAnnotationStrategy({ children }: AnnotationStrategyProps): react_jsx_runtime.JSX.Element | null;

interface RenderAudioStrategyProps {
    as?: React.ComponentType<AudioComponentProps>;
}
declare function RenderAudioStrategy({ as: CustomAudio, }: RenderAudioStrategyProps): react_jsx_runtime.JSX.Element | null;

declare function RenderAccompanyingCanvas(): react_jsx_runtime.JSX.Element;

interface RenderVideoStrategyProps {
    as?: React__default.ComponentType<VideoComponentProps>;
}
declare function RenderVideoStrategy({ as: CustomVideo, }: RenderVideoStrategyProps): react_jsx_runtime.JSX.Element | null;

declare function RenderYouTubeStrategy(): react_jsx_runtime.JSX.Element | null;

declare const CanvasAnnotations: React$1.ForwardRefExoticComponent<{
    canvasId?: string | undefined;
} & React$1.RefAttributes<{
    availablePageIds: string[];
    enabledPageIds: string[];
    setPageEnabled: (id: string, opt?: {
        deselectOthers?: boolean | undefined;
    }) => void;
    setPageDisabled: (deselectId: string) => void;
}>>;

type FacetConfig = {
    id: string;
    label: InternationalString;
    keys: string[];
    values?: FacetConfigValue[];
};
type FacetConfigValue = {
    id: string;
    label: InternationalString;
    values: string[];
    key: string;
};
interface MetadataProps {
    config?: FacetConfig[];
    metadata?: Array<{
        label: InternationalString;
        value: InternationalString;
    } | null>;
    labelWidth?: number;
    allowHtml?: boolean;
    showEmptyMessage?: boolean;
    separator?: string;
    classes?: {
        container?: string;
        row?: string;
        label?: string;
        value?: string;
        empty?: string;
    };
    emptyMessage?: string;
    emptyValueFallback?: string;
    emptyLabelFallback?: string;
    tableHeader?: React.ReactNode;
    tableFooter?: React.ReactNode;
    emptyFallback?: React.ReactNode;
}
declare function Metadata({ metadata, config, labelWidth, showEmptyMessage, allowHtml, emptyFallback, classes, emptyMessage, emptyValueFallback, emptyLabelFallback, separator, tableFooter, tableHeader, }: MetadataProps): react_jsx_runtime.JSX.Element;

type CombinedMetadataProps = Omit<MetadataProps, 'metadata'>;
declare function CombinedMetadata(props: CombinedMetadataProps): react_jsx_runtime.JSX.Element;

interface ImageProps {
    src: string | ImageService$1;
    alt?: string;
    size?: Partial<ImageSize>;
    region?: RegionParameter;
    className?: string;
    style?: React.CSSProperties;
    fetchImageService?: boolean;
    quality?: string;
    rotation?: number | RotationParameter;
    format?: string;
}
declare function Image(props: ImageProps): react_jsx_runtime.JSX.Element | null;

type ManifestMetadataProps = Omit<MetadataProps, 'metadata'>;
declare function ManifestMetadata(props: ManifestMetadataProps): react_jsx_runtime.JSX.Element;

interface SequenceThumbnailsProps {
    flat?: boolean;
    size?: {
        width: number;
        height?: number;
    };
    dereference?: boolean;
    classes?: {
        container?: string;
        row?: string;
        item?: string;
        figure?: string;
        imageWrapper?: string;
        img?: string;
        label?: string;
        selected?: {
            row?: string;
            item?: string;
            figure?: string;
            img?: string;
            label?: string;
            imageWrapper?: string;
        };
    };
    figure?: boolean;
    showLabel?: boolean;
    fallback?: React.ReactNode;
    scrollBehaviour?: ScrollBehavior;
}
declare function SequenceThumbnails({ scrollBehaviour, dereference, flat, size, classes, showLabel, figure, fallback }: SequenceThumbnailsProps): react_jsx_runtime.JSX.Element;

interface SingleCanvasThumbnailProps {
    canvasId?: string;
    size?: Partial<SizeParameter>;
    visible?: boolean;
    alt?: string;
    dereference?: boolean;
    figure?: boolean;
    showLabel?: boolean;
    classes?: {
        figure?: string;
        img?: string;
        label?: string;
        imageWrapper?: string;
    };
    placeholder?: React.ReactNode;
    fallback?: React.ReactNode;
}
declare function SingleCanvasThumbnail(props: SingleCanvasThumbnailProps): react_jsx_runtime.JSX.Element;

interface SvgEditorOptions {
    image: {
        height: number;
        width: number;
    };
    currentShape: InputShape | null;
    onChange: (e: InputShape) => void;
    hideShapeLines?: boolean;
}
declare function useSvgEditor(options: SvgEditorOptions, deps: any[]): {
    helper: {
        draw: {
            enable(): void;
            disable(): void;
            toggle(): void;
        };
        state: RenderState;
        modifiers: {
            reset(): void;
            getForType(type: string | null): Record<string, string>;
            set(modifier: string): void;
            unset(modifier: string): void;
        };
        stamps: {
            set(selectedStamp: InputShape | null): void;
            clear(): void;
            square(): void;
            triangle(): void;
            pentagon(): void;
            hexagon(): void;
        };
        key: {
            down(key: string): true | undefined;
            up(key: string): void;
        };
        setScale: (scale: number) => void;
        clock: {
            set: (renderFunc: polygon_editor.RenderFunc) => void;
            start: (renderFunc?: polygon_editor.RenderFunc | undefined, setStateFunc?: polygon_editor.SetState | undefined) => void;
            stop: () => void;
            step: (deltaTime?: number | undefined) => void;
        };
        pointer: (pointers: ([number, number] | [number, number, number, number, number, number])[]) => void;
        blur: () => void;
        pointerDown: () => void;
        pointerUp: () => void;
        setShape: (shape: InputShape | null) => void;
        modes: {
            toggleLineBoxMode: () => void;
            toggleLineMode: () => void;
            enableLineMode(): void;
            disableLineMode(): void;
            enableLineBoxMode(): void;
            disableLineBoxMode(): void;
        };
        label: (type: string | null) => string;
    };
    state: SlowState;
    isAddingPoint: boolean;
    isSplitting: boolean;
    isStamping: boolean | null;
    isHoveringPoint: boolean;
    transitionDirection: string | null;
    transitionRotate: boolean;
    defs: react_jsx_runtime.JSX.Element;
    editor: react_jsx_runtime.JSX.Element | null;
};

type HelperType$1 = ReturnType<typeof useSvgEditor>['helper'];
type StateType$1 = ReturnType<typeof useSvgEditor>['state'];
interface RenderSvgEditorControlsProps {
    helper: HelperType$1;
    state: StateType$1;
    showShapes: boolean;
    classNames?: Partial<{
        button: string;
    }>;
    enabled?: {
        draw?: boolean;
        polygon?: boolean;
        line?: boolean;
        lineBox?: boolean;
        square?: boolean;
        triangle?: boolean;
        hexagon?: boolean;
        circle?: boolean;
        delete?: boolean;
    };
    icons?: Partial<{
        DrawIcon: ReactNode;
        PolygonIcon: ReactNode;
        LineIcon: ReactNode;
        LineBoxIcon: ReactNode;
        ShapesIcon: ReactNode;
        SquareIcon: ReactNode;
        TriangleIcon: ReactNode;
        HexagonIcon: ReactNode;
        CircleIcon: ReactNode;
        DeleteForeverIcon: ReactNode;
    }>;
}
declare function RenderSvgEditorControls({ helper, showShapes, state, enabled, classNames, icons, }: RenderSvgEditorControlsProps): react_jsx_runtime.JSX.Element;

declare const svgThemes: ({
    name: string;
    outer: {
        borderWidth: number;
        borderColor: string;
    };
    inner: {
        borderWidth: number;
        borderColor: string;
    };
} | {
    name: string;
    outer: {
        borderWidth: string;
        borderColor: string;
    };
    inner: {
        borderWidth: string;
        borderColor: string;
    };
} | {
    name: string;
    outer: {
        borderWidth: string;
        borderColor: string;
    };
    inner: {
        borderWidth?: undefined;
        borderColor?: undefined;
    };
})[];
type HelperType = ReturnType<typeof useSvgEditor>['helper'];
type StateType = ReturnType<typeof useSvgEditor>['state'];
type SvgTheme = {
    name?: string;
    outer: BoxStyle;
    inner: BoxStyle;
};
interface CreateCustomShapeProps {
    image: {
        width: number;
        height: number;
    };
    shape?: any;
    updateShape: any;
    theme?: {
        name?: string;
        outer: BoxStyle;
        inner: BoxStyle;
    };
    controlsHtmlId?: string;
    renderControls?: (helper: HelperType, state: StateType, showShapes: boolean) => any;
}
declare function CreateCustomShape(props: CreateCustomShapeProps): react_jsx_runtime.JSX.Element;

interface PolygonSelectorProps {
    id: string;
    polygon: InputShape;
    annotationBucket?: string;
    isHighlighted?: boolean;
    updatePolygon?: (shape: InputShape) => void;
    readOnly?: boolean;
    theme?: SvgTheme;
    controlsHtmlId?: string;
    renderControls?: CreateCustomShapeProps['renderControls'];
}
declare function PolygonSelector(props: PolygonSelectorProps): react_jsx_runtime.JSX.Element | null;

interface ImageServiceProps {
    src: string;
    atlas?: AtlasProps;
    errorFallback?: React__default.FC;
    interactive?: boolean;
    skipSizes?: boolean;
    renderViewerControls?: (strategy: SingleImageStrategy | EmptyStrategy) => ReactNode;
    viewControlsDeps?: any[];
    fluid?: boolean;
    x?: number;
    y?: number;
    children?: React__default.ReactNode;
}
declare function ImageService({ src, errorFallback, interactive, skipSizes, children, renderViewerControls, viewControlsDeps, fluid, x, y, ...atlasProps }: ImageServiceProps & Omit<AtlasProps, 'children'>): react_jsx_runtime.JSX.Element | null;

declare function AnnotationContext({ annotation, children }: {
    annotation: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function AnnotationPageContext({ annotationPage, children }: {
    annotationPage: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function hasAuth(resource: any): boolean;
interface ProbeStore {
    service?: AuthProbeService2;
    status: 'unknown' | 'probing' | 'error' | 'success';
    shouldRedirect: boolean;
    redirectResource: Auth2LocationResource | null;
    shouldSubstitute: boolean;
    substituteResource: Auth2SubstituteResource | null;
    error: string | null;
    errorHeading: InternationalString | null;
    errorNote: InternationalString | null;
    shouldDisplayResource: boolean;
    token: string | null;
    probe: () => Promise<void>;
    setToken: (token: string) => void;
}
interface AuthContextState {
    currentAuth: number;
    authItems: AuthAccessState[];
}
interface AuthContextCurrentActions {
    login(): void;
    logout(): void;
    nextAuth(): void;
    previousAuth(): void;
    setAuth(index: number): void;
}
interface AuthContextActions {
    addService(service: AuthAccessService2, probeId: string): void;
    removeService(service: AuthAccessService2, probeId: string): void;
}
interface AuthAccessState {
    id: string;
    type: 'external' | 'kiosk' | 'active';
    service: AuthAccessService2;
    probeId: string;
    isPending: boolean;
    isLoggedIn: boolean;
    canAuthenticate: boolean;
    instances: number;
    error?: string;
    session: null | {
        token: string;
        expires: number;
    };
}
declare const createAuthStateStore: () => zustand_vanilla.StoreApi<AuthContextCurrentActions & AuthContextState & AuthContextActions>;
declare const createProbe: (service?: AuthProbeService2, token?: string) => zustand_vanilla.StoreApi<ProbeStore>;
declare function authDetailsForResource(resource: any): {
    hasAuth?: boolean | undefined;
    services: {
        probe?: AuthProbeService2;
        access?: AuthAccessService2;
    };
};
declare function makeAccessTokenRequest<T extends AuthAccessTokenService2>(service: T, { strict }?: {
    strict?: boolean;
}): Promise<AuthAccessToken2>;
declare function makeAccessServiceRequest<T extends AuthAccessService2>(service: T): Promise<void>;

interface AuthState {
    id: string;
    type: 'external' | 'kiosk' | 'active';
    service: AuthAccessService2;
    probeId: string;
    isPending: boolean;
    isLoggedIn: boolean;
    canAuthenticate: boolean;
    instances: number;
    error?: string;
    session: null | {
        token: string;
        expires: number;
    };
}
declare const AuthRContext: React$1.Context<StoreApi<AuthContextState & AuthContextCurrentActions & AuthContextActions> | null>;
declare const AuthReactContext: React$1.Context<(AuthContextState & AuthContextCurrentActions) | null>;
declare const AuthReactContextActions: React$1.Context<AuthContextActions | null>;
declare function AuthProvider({ children }: {
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function useIsAuthEnabled(): boolean;
declare function useAuthStore(): StoreApi<AuthContextState & AuthContextCurrentActions & AuthContextActions>;
declare function useAuthActions(): {
    login: () => void;
    logout: () => void;
    nextAuth: () => void;
    previousAuth: () => void;
    setAuth: (index: number) => void;
    addService: (service: AuthAccessService2, probeId: string) => void;
    removeService: (service: AuthAccessService2, probeId: string) => void;
};
declare function useCurrentAuth(): AuthContextState & AuthContextCurrentActions & AuthContextActions;
declare function useAuthService(id: string): AuthAccessState | undefined;
declare function useAuthTokens(id?: string): string | undefined;
declare function useAuthToken(id: string): string | null;
interface AuthProps<T, Extra> {
    resource: T;
    extra?: Extra;
    children: (service: T) => ReactNode;
    fallbackComponent?: FunctionComponent<any> | null;
    loadingComponent?: FunctionComponent<any> | null;
    errorComponent?: FunctionComponent<{
        resource: T;
        error: string;
        heading: InternationalString | null;
        note: InternationalString | null;
        extra: Extra | undefined;
    }> | null;
}
declare function Auth<Element, Extra = any>(props: AuthProps<Element, Extra>): string | number | boolean | Iterable<ReactNode> | react_jsx_runtime.JSX.Element | null | undefined;

declare function CanvasContext({ canvas, children }: {
    canvas: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function CollectionContext({ collection, children }: {
    collection: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

type MediaPlayerState = {
    isPlaying: boolean;
    isMuted: boolean;
    playRequested: boolean;
    volume: number;
    isFinished: boolean;
    duration: number;
};
type MediaPlayerActions = {
    play(): void;
    pause(): void;
    playPause(): void;
    mute(): void;
    unmute(): void;
    toggleMute(): void;
    setVolume(volume: number): void;
    setDurationPercent(percent: number): void;
    setTime(time: number | ((t: number) => number)): void;
};
declare function formatTime(time: number): string;
declare function useSimpleMediaPlayer(props: {
    duration: number;
}): readonly [
    {
        element: RefObject<HTMLAudioElement | HTMLVideoElement>;
        currentTime: RefObject<HTMLDivElement>;
        progress: RefObject<HTMLDivElement>;
    },
    MediaPlayerState,
    MediaPlayerActions
];

interface ComplexTimelineStore extends MediaPlayerActions {
    complexTimeline: ComplexTimelineStrategy;
    visibleElements: Record<string, TimelineKeyframe | null>;
    isReady: boolean;
    isBuffering: boolean;
    bufferMap: Record<string, boolean>;
    isMuted: boolean;
    playRequested: boolean;
    isPlaying: boolean;
    isFinished: boolean;
    volume: number;
    duration: number;
    primeTime: number;
    clockRunning: boolean;
    clockStartTime: number;
    currentPrime: TimelineKeyframe | null;
    clockStartRequests: number;
    startClock: () => void;
    stopClock: () => void;
    setElement: (id: string, element: HTMLVideoElement | HTMLAudioElement) => void;
    removeElement: (id: string) => void;
    applyKeyframes(newIdx: number, keyframes: TimelineKeyframe[]): void;
    nextKeyframeIndex: number;
    setProgressElement(div: HTMLDivElement): void;
    setCurrentTimeElement(div: HTMLDivElement): void;
    clearProgressElement(): void;
    clearCurrentTimeElement(): void;
}

declare function ComplexTimelineProvider({ children, store, }: {
    children: React.ReactNode;
    store: StoreApi$1<ComplexTimelineStore>;
}): react_jsx_runtime.JSX.Element;
declare function useComplexTimeline<T>(selector: (store: ComplexTimelineStore) => T): T;

interface EventContext {
    emitter: Emitter<any>;
}
declare const defaultEmitter: Emitter<Record<EventType, unknown>>;
declare const ReactEventContext: React__default.Context<{
    emitter: Emitter<Record<EventType, unknown>>;
}>;
declare function useEventEmitter<Events extends Record<EventType, unknown>>(): Emitter<Events>;
declare function EventsProvider({ emitter, children }: EventContext & {
    children: React__default.ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function ManifestContext({ manifest, children }: {
    manifest: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare function useMediaState(): MediaPlayerState;
declare function useMediaActions(): MediaPlayerActions;
declare function useMediaElements(): {
    element: RefObject<HTMLAudioElement | HTMLVideoElement>;
    currentTime: RefObject<HTMLDivElement>;
    progress: RefObject<HTMLDivElement>;
};
declare function MediaPlayerProvider({ actions, state, children, currentTime, progress, element, }: {
    actions: MediaPlayerActions;
    state: MediaPlayerState;
    children: ReactNode;
    currentTime: RefObject<HTMLDivElement>;
    progress: RefObject<HTMLDivElement>;
    element: RefObject<HTMLAudioElement | HTMLVideoElement>;
}): react_jsx_runtime.JSX.Element;

declare function RangeContext({ range, children }: {
    range: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

type ResourceContextType = {
    collection?: string;
    manifest?: string;
    range?: string;
    canvas?: string;
    annotation?: string;
    annotationPage?: string;
};
declare const ResourceReactContext: React__default.Context<ResourceContextType>;
declare const useResourceContext: () => ResourceContextType;
declare function ResourceProvider({ value, children }: {
    value: ResourceContextType;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare const ReactVaultContext: React__default.Context<{
    vault: Vault | null;
    setVaultInstance: (vault: Vault) => void;
}>;
declare function VaultProvider({ vault, vaultOptions, useGlobal, resources, children, }: {
    vault?: Vault;
    useGlobal?: boolean;
    vaultOptions?: VaultOptions;
    resources?: ResourceContextType;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

type SearchService = SearchService$1 & {
    service: SearchServiceAutocomplete | SearchServiceAutocomplete[];
};
interface Search1Store {
    service: SearchService | undefined;
    lastQuery: SearchServiceQueryParams;
    resources: SearchServiceSearchResponse['resources'];
    loading: boolean;
    error: boolean;
    hasAutocomplete: boolean;
    hasSearch: boolean;
    errorMessage: string;
    highlight: SearchServiceSearchResponse['resources'][number] | null;
    search: (query: SearchServiceQueryParams, options?: {
        headers?: HeadersInit;
    }) => void;
    clearSearch: () => void;
    highlightResult: (id: string) => void;
    nextResult: () => void;
}

declare function useCustomContextBridge(): Record<string, {
    value: any;
    Provider: React__default.Provider<any>;
}>;
declare function CustomContextBridge(props: Record<string, {
    value: any;
    Provider: React__default.Provider<any>;
}> & {
    children: React__default.ReactNode;
}): ReactNode;
declare function CustomContextBridgeProvider(props: {
    providers: Record<string, Context<any>>;
    children: React__default.ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function useContextBridge(): {
    VaultContext: {
        vault: _iiif_helpers.Vault | null;
        setVaultInstance: (vault: _iiif_helpers.Vault) => void;
    };
    ResourceContext: ResourceContextType;
    SimpleViewerReactContext: SimpleViewerContext;
    VisibleCanvasReactContext: string[];
    AuthRContext: zustand.StoreApi<AuthContextState & AuthContextCurrentActions & AuthContextActions> | null;
    SearchReactContext: zustand.StoreApi<Search1Store> | null;
    ReactEventContext: {
        emitter: mitt.Emitter<Record<mitt.EventType, unknown>>;
    };
};
declare function ContextBridge(props: {
    bridge: ReturnType<typeof useContextBridge>;
    custom?: ReturnType<typeof useCustomContextBridge>;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;

declare const VisibleCanvasReactContext: React__default.Context<string[]>;
declare function useVisibleCanvases(): CanvasNormalized[];

declare const ViewerPresetContext: React$1.Context<Preset | null | undefined>;
declare function useViewerPreset(): Preset | null | undefined;

declare const ImageServiceLoaderContext: React__default.Context<ImageServiceLoader>;
declare function useImageServiceLoader(): ImageServiceLoader;

type SelectorHelperEventTypes = 'click' | 'hover' | 'selector-updated' | 'highlight' | 'clear-highlight' | 'zoom-to' | 'event-listener' | 'remove-event-listener' | 'image-preview-request';
declare function SelectorControllerProvider({ children }: {
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function useSelectorEmitter(): mitt.Emitter<Record<mitt.EventType, unknown>>;
declare function useSelectorEvents(id: string): {
    controller: {
        withSelector(selectorId: string): {
            on<T extends {
                selectorId: string;
            } = any>(type: SelectorHelperEventTypes, handler: Handler<T>): () => void;
            emit<T_1 = any>(type: SelectorHelperEventTypes, event: T_1): void;
        };
        on<T_2 extends {
            selectorId: string;
        } = any>(type: SelectorHelperEventTypes, handler: Handler<T_2>): () => void;
        emit<T_3 extends {
            selectorId: string;
        } = any>(type: SelectorHelperEventTypes, event: T_3): void;
    };
    onClick: (e?: {
        x: number;
        y: number;
        width: number;
        height: number;
    }) => void;
    onHover: (e?: {
        x: number;
        y: number;
        width: number;
        height: number;
    }) => void;
    isHighlighted: boolean;
};
declare function useSelectorController(): {
    withSelector(selectorId: string): {
        on<T extends {
            selectorId: string;
        } = any>(type: SelectorHelperEventTypes, handler: Handler<T>): () => void;
        emit<T_1 = any>(type: SelectorHelperEventTypes, event: T_1): void;
    };
    on<T_2 extends {
        selectorId: string;
    } = any>(type: SelectorHelperEventTypes, handler: Handler<T_2>): () => void;
    emit<T_3 extends {
        selectorId: string;
    } = any>(type: SelectorHelperEventTypes, event: T_3): void;
};
declare function useSelectorHelper(): {
    withSelector(selectorId: string): {
        highlight(): void;
        clearHighlight(): void;
        zoomTo(): void;
        addEventListener(name: string, callback: () => void): () => void;
        getImagePreview(): Promise<any>;
        on<T extends {
            selectorId: string;
        } = any>(type: SelectorHelperEventTypes, handler: Handler<T>): () => void;
    };
    highlight(selectorId: string): void;
    clearHighlight(selectorId: string): void;
    zoomTo(selectorId: string): void;
    addEventListener(selectorId: string, name: string, callback: () => void): () => void;
    getImagePreview(selectorId: string): Promise<any>;
    on<T_1 extends {
        selectorId: string;
    } = any>(type: SelectorHelperEventTypes, handler: Handler<T_1>): () => void;
};

interface AnnotationStyles {
    id: number;
    name: string;
    creator?: {
        id: number;
        name: string;
    };
    createdAt: Date;
    theme: {
        default: AnnotationThemeDefinition;
        hidden: AnnotationThemeDefinition;
        highlighted: AnnotationThemeDefinition;
    } & Record<string, AnnotationThemeDefinition>;
}
type AnnotationThemeDefinition = BoxStyle & {
    hidden?: boolean;
    interactive?: boolean;
    hotspot?: boolean;
    hotspotSize?: 'lg' | 'md' | 'sm';
};
declare function getDefaultAnnotationStyles(): AnnotationStyles['theme'];
declare function useAnnotationStyles(): {
    default: AnnotationThemeDefinition;
    hidden: AnnotationThemeDefinition;
    highlighted: AnnotationThemeDefinition;
} & Record<string, AnnotationThemeDefinition>;
declare function AnnotationStyleProvider({ theme, children, }: {
    theme?: AnnotationStyles['theme'];
    children: React.ReactNode;
}): react_jsx_runtime.JSX.Element;

interface StrategyContext {
    strategy: RenderingStrategy;
    choices: ChoiceDescription | null;
}
declare const StrategyReactContext: React$1.Context<StrategyContext | null>;
declare function useStrategy(): StrategyContext;

interface ControlsContext {
    renderMediaControls?: (strategy: MediaStrategy) => ReactNode;
    viewControlsDeps: any[];
    renderViewerControls?: (strategy: SingleImageStrategy | EmptyStrategy) => ReactNode;
    mediaControlsDeps: any[];
    renderComplexTimelineControls?: (strategy: ComplexTimelineStrategy) => ReactNode;
    complexTimelineControlsDeps: any[];
}
declare const ControlsReactContext: React$1.Context<ControlsContext | null>;
declare function useRenderControls(): ControlsContext;

/**
 * Parse specific resource.
 *
 * This could be expanded to support pulling out more from the specific resource.
 *
 * @param resource
 */
declare function parseSpecificResource(resource: ContentResource): any[];
declare function getParsedTargetSelector(canvas: CanvasNormalized, target: W3CAnnotationTarget | W3CAnnotationTarget[]): [TemporalBoxSelector$1 | BoxSelector$1 | PointSelector | null, SupportedTarget['source']];
declare const emptyActions: {
    makeChoice: () => void;
};
declare const unknownResponse: UseRenderingStrategy[0];
declare const unsupportedStrategy: (reason: string) => UnknownStrategy;
declare const emptyStrategy: (width: number, height: number) => UseRenderingStrategy[0];

type CompatVault = {
    get: _iiif_helpers_vault.Vault['get'];
    setMetaValue: _iiif_helpers_vault.Vault['setMetaValue'];
    getResourceMeta: _iiif_helpers_vault.Vault['getResourceMeta'];
    load: _iiif_helpers_vault.Vault['load'];
    requestStatus: _iiif_helpers_vault.Vault['requestStatus'];
};

declare function getVideoStrategy(canvas: CanvasNormalized, paintables: Paintables, vault: CompatVault): UnknownStrategy | MediaStrategy;

interface GetRenderStrategyOptions {
    canvas: CanvasNormalized | null | undefined;
    paintables: Paintables$1;
    supports: string[];
    loadImageService: ImageServiceLoaderType;
    vault?: CompatVault;
}
declare function getRenderingStrategy({ canvas, paintables, supports, loadImageService, vault, }: GetRenderStrategyOptions): RenderingStrategy;

declare function getComplexTimelineStrategy(canvas: CanvasNormalized, paintables: Paintables, loadImageService: ImageServiceLoaderType, vault: CompatVault): ComplexTimelineStrategy;

declare function useAnnotation(options?: {
    id: string;
}): AnnotationNormalized | undefined;
declare function useAnnotation<T>(options?: {
    id: string;
    selector: (annotation: AnnotationNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useAnnotationPage(options?: {
    id: string;
}): AnnotationPageNormalized | undefined;
declare function useAnnotationPage<T>(options?: {
    id: string;
    selector: (annotation: AnnotationPageNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useAnnotationPageManager(resourceId?: string, options?: {
    all?: boolean;
}): {
    availablePageIds: string[];
    enabledPageIds: string[];
    setPageEnabled: (id: string, opt?: {
        deselectOthers?: boolean;
    }) => void;
    setPageDisabled: (deselectId: string) => void;
};

declare function useAnnotationsAtTime(time: number, options?: {
    canvasId?: string;
}): AnnotationNormalized[];

declare function useCanvas(options?: {
    id: string;
}): CanvasNormalized | undefined;
declare function useCanvas<T>(options?: {
    id: string;
    selector: (canvas: CanvasNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useCanvasChoices({ canvasId }?: {
    canvasId?: string;
}): {
    choices: Array<{
        canvasId: string;
        choice: ComplexChoice;
    }>;
    actions: {
        makeChoice: (id: string, options?: {
            deselectOthers?: boolean;
            deselect?: boolean;
        }) => void;
    };
};

declare function useCanvasClock(canvasId?: string, autoplay?: boolean): void;

declare function useCanvasSubset(idsOrRefs?: Array<string | Reference>): Reference<'Canvas'>[];

declare function useCanvasStartTime(): {
    startTime: number;
    endTime?: number | undefined;
} | null;

declare function useCollection(options: {
    id: string;
}): CollectionNormalized | undefined;
declare function useCollection<T>(options: {
    id: string;
    selector: (collection: CollectionNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useDispatch(): VaultZustandStore['dispatch'];

type SupportedEvents = 'onClick';
declare function useEventListener<T>(resource: Reference, name: SupportedEvents, listener: (e: any, resource: T) => void, scope?: string[], deps?: any[]): void;

declare function useExistingVault(vault?: Vault): Vault;

type ResourceRequestOptions = {
    noCache?: boolean;
};
declare function useExternalResource<T extends {
    id: string;
}>(idOrRef: string | {
    id: string;
    type: string;
}, { noCache }?: ResourceRequestOptions): {
    id: string;
    requestId: string;
    isLoaded: boolean;
    error: any;
    cached: boolean;
    resource?: T;
};

declare function useExternalCollection(idOrRef: string | {
    id: string;
    type: string;
}, options?: ResourceRequestOptions): {
    id: string;
    requestId: string;
    isLoaded: boolean;
    cached?: boolean;
    error: any;
    manifest?: CollectionNormalized;
};

declare function useExternalManifest(idOrRef: string | {
    id: string;
    type: string;
}, options?: ResourceRequestOptions): {
    id: string;
    requestId: string;
    isLoaded: boolean;
    cached?: boolean;
    error: any;
    manifest?: ManifestNormalized;
};

declare function useImage(service: ImageService$1 | undefined, data?: {
    size?: Partial<ImageSize>;
    selector?: RegionParameter;
    rotation?: number | RotationParameter;
    format?: string;
    region?: RegionParameter;
    quality?: string;
}, deps?: any[]): string | null;

interface ImageServiceRequestOptions {
    cacheKey?: string;
}
/**
 * Returns the First image service on the current canvas.
 *
 * @note It is better to use the hook useRenderingStrategy for rendering.
 */
declare function useImageService({ cacheKey }?: ImageServiceRequestOptions): {
    data: ImageService$1 | undefined;
    isFetching: boolean;
    status: 'error' | 'success' | 'loading' | 'idle';
};

declare function useImageTile(): {
    isLoading: boolean;
    tile: {
        id: string | undefined;
        width: number | null | undefined;
        height: number | null | undefined;
        imageService: ImageService$1;
        thumbnail: undefined;
    } | null;
};

declare function useManifest(options?: {
    id: string;
}): ManifestNormalized | undefined;
declare function useManifest<T>(options?: {
    id: string;
    selector: (manifest: ManifestNormalized) => T;
}, deps?: any[]): T | undefined;

declare function usePaintables(options?: {
    defaultChoices?: string[];
    enableSingleAnnotation?: boolean;
}, deps?: any[]): readonly [_iiif_helpers_painting_annotations.Paintables, {
    makeChoice: (id: string, { deselectOthers, deselect }?: {
        deselectOthers?: boolean;
        deselect?: boolean;
    }) => void;
}];

declare function usePaintingAnnotations(options?: {
    canvasId?: string;
    enableSingleAnnotation?: boolean;
}): AnnotationNormalized[];

declare function useRange(options?: {
    id: string;
}): RangeNormalized | undefined;
declare function useRange<T>(options?: {
    id: string;
    selector: (range: RangeNormalized) => T;
}, deps?: any[]): T | undefined;

declare function useResourceEvents<T extends NormalizedEntity>(resource?: Reference, scope?: string[]): any;

declare function useResources<Type>(ids: string[], type: string): Type[];

declare function useSearchService(): SearchService$1 | undefined;

declare function useStyleHelper(): _iiif_helpers_styles.StyledHelper<_iiif_helpers_styles.StyleDefinition>;

declare function useStyles<Style extends Record<string, Record<string, any>>>(resource: undefined | Reference<any>): Style;
declare function useStyles<Style extends Record<string, any>>(resource: undefined | Reference<any>, scope: string): Style;

declare function useThumbnail(request: ImageCandidateRequest, dereference?: boolean, { canvasId, manifestId }?: {
    canvasId?: string;
    manifestId?: string;
}): ImageCandidate$1 | undefined;

declare const useVault: () => Vault;

declare const useVaultEffect: (callback: (vault: Vault) => void, deps?: any[]) => void;

declare function useVaultSelector<T>(selector: (state: IIIFStore, vault: Vault) => T, deps?: any[]): T;

interface VaultActivatedAnnotation {
    __vault?: Vault;
    bindToVault(vault: Vault): void;
    source: string | {
        id: string;
    };
}
declare function useVirtualAnnotationPage(): readonly [AnnotationPageNormalized | null, {
    readonly addAnnotation: (id: string | Annotation | VaultActivatedAnnotation | AnnotationNormalized, atIndex?: number) => void;
    readonly removeAnnotation: (id: string | Annotation | VaultActivatedAnnotation | AnnotationNormalized) => void;
}];

declare function useVirtualAnnotationPageContext(): [AnnotationPageNormalized | null, {
    addAnnotation: (id: string | Annotation | VaultActivatedAnnotation | AnnotationNormalized, atIndex?: number | undefined) => void;
    removeAnnotation: (id: string | Annotation | VaultActivatedAnnotation | AnnotationNormalized) => void;
}];
declare function VirtualAnnotationProvider({ children }: {
    children: any;
}): react_jsx_runtime.JSX.Element;

declare function usePolygonHelper(data: any, render: (t: any, s: any) => void, commitShape: (shape: InputShape) => void): {
    state: SlowState;
    helper: {
        draw: {
            enable(): void;
            disable(): void;
            toggle(): void;
        };
        state: polygon_editor.RenderState;
        modifiers: {
            reset(): void;
            getForType(type: string | null): Record<string, string>;
            set(modifier: string): void;
            unset(modifier: string): void;
        };
        stamps: {
            set(selectedStamp: InputShape | null): void;
            clear(): void;
            square(): void;
            triangle(): void;
            pentagon(): void;
            hexagon(): void;
        };
        key: {
            down(key: string): true | undefined;
            up(key: string): void;
        };
        setScale: (scale: number) => void;
        clock: {
            set: (renderFunc: polygon_editor.RenderFunc) => void;
            start: (renderFunc?: polygon_editor.RenderFunc | undefined, setStateFunc?: polygon_editor.SetState | undefined) => void;
            stop: () => void;
            step: (deltaTime?: number | undefined) => void;
        };
        pointer: (pointers: ([number, number] | [number, number, number, number, number, number])[]) => void;
        blur: () => void;
        pointerDown: () => void;
        pointerUp: () => void;
        setShape: (shape: InputShape | null) => void;
        modes: {
            toggleLineBoxMode: () => void;
            toggleLineMode: () => void;
            enableLineMode(): void;
            disableLineMode(): void;
            enableLineBoxMode(): void;
            disableLineBoxMode(): void;
        };
        label: (type: string | null) => string;
    };
};

declare function flattenAnnotationPageIds({ canvas, manifest, all, canvases, }: {
    manifest?: ManifestNormalized;
    canvas?: CanvasNormalized;
    canvases?: CanvasNormalized[];
    all?: boolean;
}): string[];

declare function TranslationProvider(props: {
    translations: Record<string, string>;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function LanguageProvider(props: {
    language: string;
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function TransliterationProvider(props: {
    convert: null | ((input: string, targetLang: string) => string);
    children: ReactNode;
}): react_jsx_runtime.JSX.Element;
declare function useTransliteration(): ((input: string, targetLang: string) => string) | null;
declare function useIIIFLanguage(): string;
declare function useTranslations(): Record<string, string>;
type LanguageStringProps = {
    [key: string]: any;
} & {
    as?: string | React__default.FC<any>;
    language: string;
    viewingDirection?: 'rtl' | 'rtl';
};
declare function LanguageString({ as: Component, language, children, viewingDirection, ...props }: LanguageStringProps): react_jsx_runtime.JSX.Element;
declare const useClosestLanguage: (getLanguages: () => string[], deps?: any[]) => string | undefined;
declare function useLocaleString(inputText: InternationalString | string | null | undefined, defaultText?: string, separator?: string, translations?: Record<string, string>): readonly [string, string | undefined];
declare function useCreateLocaleString(): (inputText: InternationalString | string | null | undefined, defaultText?: string, separator?: string, translations?: Record<string, string>) => string;
type LocaleStringProps = {
    as?: string | React__default.FC<any>;
    defaultText?: string;
    to?: string;
    separator?: string;
    enableDangerouslySetInnerHTML?: boolean;
    children: InternationalString | string | null | undefined;
    style?: React__default.CSSProperties;
    extraProps?: any;
} & Record<string, any>;
declare function LocaleString({ as: Component, defaultText, enableDangerouslySetInnerHTML, children, separator, ...props }: LocaleStringProps): react_jsx_runtime.JSX.Element;

declare const SimpleViewerReactContext: React__default.Context<SimpleViewerContext>;
declare function InnerViewerProvider(props: SimpleViewerProps): react_jsx_runtime.JSX.Element | null;
declare function SimpleViewerProvider(props: SimpleViewerProps): react_jsx_runtime.JSX.Element;
declare function useSimpleViewer(): SimpleViewerContext;

declare function useCanvasSequence({ startCanvas, disablePaging }: {
    startCanvas?: string;
    disablePaging?: boolean;
}): {
    visibleItems: string[];
    cursor: number;
    items: {
        type: "Canvas";
        id: string;
    }[];
    sequence: number[][];
    hasPrevious: boolean;
    hasNext: boolean;
    setSequenceIndex: React$1.Dispatch<React$1.SetStateAction<number>>;
    setCanvasIndex: (index: number) => void;
    setCanvasId: (id: string) => void;
    next: () => void;
    previous: () => void;
};

/**
 * Get visible canvases from canvas ID
 *
 * This function returns a list of canvas references that should all be displayed
 * when the passed canvasId is visible. This should work for individual items,
 * 2-up paged view and continuous (scrolls).
 *
 * The options are listed below (from IIIF docs)
 *
 * - `unordered` - Valid on Collections, Manifests and Ranges. The Canvases included in resources that have this behavior
 *    have no inherent order, and user interfaces should avoid implying an order to the user. Disjoint with individuals,
 *    continuous, and paged.
 *
 * - `individuals` - Valid on Collections, Manifests, and Ranges. For Collections that have this behavior, each of the
 *    included Manifests are distinct objects in the given order. For Manifests and Ranges, the included Canvases are
 *    distinct views, and should not be presented in a page-turning interface. This is the default layout behavior if
 *    not specified. Disjoint with unordered, continuous, and paged.
 *
 * - `continuous`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and
 *    width dimensions. Canvases included in resources that have this behavior are partial views and an appropriate
 *    rendering might display all of the Canvases virtually stitched together, such as a long scroll split into
 *    sections. This behavior has no implication for audio resources. The viewingDirection of the Manifest will
 *    determine the appropriate arrangement of the Canvases. Disjoint with unordered, individuals and paged.
 *
 * - `paged`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and width
 *    dimensions. Canvases included in resources that have this behavior represent views that should be presented in
 *    a page-turning interface if one is available. The first canvas is a single view (the first recto) and thus the
 *    second canvas likely represents the back of the object in the first canvas. If this is not the case, see the
 *    behavior value non-paged. Disjoint with unordered, individuals, continuous, facing-pages and non-paged.
 *
 */
declare function getVisibleCanvasesFromCanvasId(vault: Vault, manifestOrRange: ManifestNormalized | RangeNormalized, canvasId: string | null, preventPaged?: boolean): Reference<'Canvas'>[];
declare function getManifestSequence(vault: Vault, manifestOrRange: ManifestNormalized | RangeNormalized, { disablePaging, skipNonPaged }?: {
    disablePaging?: boolean;
    skipNonPaged?: boolean;
}): [Reference<'Canvas'>[], number[][]];

declare function findFirstCanvasFromRange(vault: Vault, range: RangeNormalized): null | Reference<'Canvas'>;
declare function findAllCanvasesInRange(vault: Vault, range: RangeNormalized): Array<Reference<'Canvas'>>;
declare function findManifestSelectedRange(vault: Vault, manifest: ManifestNormalized, canvasId: string): null | RangeNormalized;
declare function findSelectedRange(vault: Vault, range: RangeNormalized, canvasId: string): null | RangeNormalized;

export { AnnotationContext, AnnotationPageContext, type AnnotationPageDescription, type AnnotationStrategyProps, AnnotationStyleProvider, type AnnotationStyles, type AnnotationThemeDefinition, type AudioSequence, Auth, type AuthAccessState, type AuthContextActions, type AuthContextCurrentActions, type AuthContextState, AuthProvider, AuthRContext, AuthReactContext, AuthReactContextActions, type AuthState, CanvasAnnotations, CanvasContext, CanvasPanel, CanvasStrategyProvider, CanvasWorldObject, type ChoiceEvents, CollectionContext, CombinedMetadata, ComplexTimelineProvider, type ComplexTimelineStrategy, ContextBridge, type ControlsContext, ControlsReactContext, CreateCustomShape, type CreateCustomShapeProps, CustomContextBridge, CustomContextBridgeProvider, type EmptyStrategy, EventsProvider, Image, type ImageProps, ImageService, ImageServiceLoaderContext, type ImageServiceLoaderType, type ImageServiceRequestOptions, type ImageStrategyProps, type ImageWithOptionalService, InnerViewerProvider, LanguageProvider, LanguageString, LocaleString, ManifestContext, ManifestMetadata, type MediaPlayerActions, MediaPlayerProvider, type MediaPlayerState, type MediaStrategy, Metadata, type MetadataProps, PolygonSelector, type PolygonSelectorProps, type ProbeStore, RangeContext, ReactEventContext, ReactVaultContext, Render3DModelStrategy, RenderAccompanyingCanvas, RenderAnnotationStrategy, RenderAudioStrategy, RenderComplexTimelineStrategy, RenderEmptyStrategy, RenderImageStrategy, RenderSvgEditorControls, RenderTextualContentStrategy, RenderVideoStrategy, RenderYouTubeStrategy, type RenderingStrategy, type ResourceContextType, ResourceProvider, ResourceReactContext, type ResourceRequestOptions, SelectorControllerProvider, type SelectorHelperEventTypes, SequenceThumbnails, type SimpleViewerActions, type SimpleViewerActionsType, type SimpleViewerContext, type SimpleViewerProps, SimpleViewerProvider, SimpleViewerReactContext, type SimpleViewerReducerState, type Single3DModelStrategy, type SingleAudio, SingleCanvasThumbnail, type SingleImageStrategy, type SingleVideo, type SingleYouTubeVideo, type StrategyActions, type StrategyContext, StrategyReactContext, type SvgTheme, type TextContent, type TextualContentStrategy, ThumbnailFallbackImage, type TimelineKeyframe, TranslationProvider, TransliterationProvider, type UnknownStrategy, type UseRenderingStrategy, type UseRenderingStrategyOptions, type VaultActivatedAnnotation, VaultProvider, type VideoSequence, ViewerPresetContext, VirtualAnnotationProvider, VisibleCanvasReactContext, authDetailsForResource, createAuthStateStore, createProbe, defaultEmitter, emptyActions, emptyStrategy, findAllCanvasesInRange, findFirstCanvasFromRange, findManifestSelectedRange, findSelectedRange, flattenAnnotationPageIds, formatTime, get3dStrategy, getComplexTimelineStrategy, getDefaultAnnotationStyles, getImageStrategy, getManifestSequence, getParsedTargetSelector, getRenderingStrategy, getTextualContentStrategy, getVideoStrategy, getVisibleCanvasesFromCanvasId, hasAuth, makeAccessServiceRequest, makeAccessTokenRequest, parseSpecificResource, svgThemes, unknownResponse, unsupportedStrategy, useAnnotation, useAnnotationPage, useAnnotationPageManager, useAnnotationStyles, useAnnotationsAtTime, useAuthActions, useAuthService, useAuthStore, useAuthToken, useAuthTokens, useCanvas, useCanvasChoices, useCanvasClock, useCanvasSequence, useCanvasStartTime, useCanvasSubset, useClosestLanguage, useCollection, useComplexTimeline, useContextBridge, useCreateLocaleString, useCurrentAuth, useCustomContextBridge, useDispatch, useEventEmitter, useEventListener, useExistingVault, useExternalCollection, useExternalManifest, useExternalResource, useIIIFLanguage, useImage, useImageService, useImageServiceLoader, useImageTile, useIsAuthEnabled, useLoadImageService, useLocaleString, useManifest, useMediaActions, useMediaElements, useMediaState, usePaintables, usePaintingAnnotations, usePolygonHelper, useRange, useRenderControls, useRenderingStrategy, useResourceContext, useResourceEvents, useResources, useSearchService, useSelectorController, useSelectorEmitter, useSelectorEvents, useSelectorHelper, useSimpleMediaPlayer, useSimpleViewer, useStrategy, useStyleHelper, useStyles, useSvgEditor, useThumbnail, useTranslations, useTransliteration, useVault, useVaultEffect, useVaultSelector, useViewerPreset, useVirtualAnnotationPage, useVirtualAnnotationPageContext, useVisibleCanvases };
