{"version":3,"file":"content-state-DHk1Ajip.js","names":["motivation: AnyMotivation[]","target"],"sources":["../src/content-state.ts"],"sourcesContent":["import { Annotation, AnyMotivation } from '@iiif/presentation-3';\nimport { expandTarget } from './annotation-targets/expand-target';\nimport { SupportedTarget } from './annotation-targets/target-types';\n\nexport type ContentState =\n  | string\n  | (Annotation & { '@context'?: string })\n  | (StateSource & { '@context'?: string })\n  | Array<string | (Annotation & { '@context'?: string }) | (StateSource & { '@context'?: string })>;\n\nexport type StateSource = {\n  id: string;\n  type: 'Manifest' | 'Canvas' | 'Range';\n  partOf?:\n    | string\n    | { id: string; type: string }\n    | Array<{\n        id: string;\n        type: string;\n      }>;\n};\n\n// Normalised content state?\nexport type NormalisedContentState = {\n  id: string;\n  type: 'Annotation';\n  motivation: ['contentState', ...string[]];\n  target: Array<SupportedTarget>;\n  extensions: Record<string, any>;\n};\n\ntype ValidationResponse = readonly [false, { reason?: string }] | readonly [true];\n\nexport function validateContentState(annotation: ContentState, strict = false): ValidationResponse {\n  // Valid content state.\n  if (typeof annotation === 'string') {\n    if (annotation.startsWith('{')) {\n      try {\n        const parsed = JSON.parse(annotation);\n        return validateContentState(parsed);\n      } catch (err) {\n        return [false, { reason: 'Invalid JSON' }];\n      }\n    }\n    return [true];\n  }\n\n  if (Array.isArray(annotation)) {\n    for (const anno of annotation) {\n      const [valid, reason] = validateContentState(anno);\n      if (!valid && reason) {\n        return [valid, reason] as const;\n      }\n    }\n\n    return [true];\n  }\n\n  if (annotation.type === 'Annotation') {\n    // We are validating the annotation.\n    return [true];\n  }\n\n  if (strict && annotation.type === 'Canvas' && !annotation.partOf) {\n    return [false, { reason: 'Canvas without partOf cannot be loaded' }];\n  }\n\n  return [true];\n}\n\nexport function serialiseContentState(annotation: ContentState): string {\n  return encodeContentState(typeof annotation === 'string' ? annotation : JSON.stringify(annotation));\n}\n\nexport function parseContentState(state: string): ContentState;\nexport function parseContentState(state: string, async: false): ContentState;\nexport async function parseContentState(state: string, async: true): Promise<ContentState>;\nexport function parseContentState(state: string, asyncOrFetcher?: boolean): ContentState | Promise<ContentState> {\n  state = state.trim();\n\n  if (state[0] === '{') {\n    // we might have json.\n    return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);\n  }\n\n  if (state.startsWith('http')) {\n    if (!asyncOrFetcher) {\n      throw new Error('Cannot fetch remote fetch with async=false in parseContentState');\n    }\n    // resolve.\n    return fetch(state).then((r) => r.json());\n  }\n\n  return parseContentState(decodeContentState(state), asyncOrFetcher as any);\n}\n\nexport function encodeContentState(state: string): string {\n  const uriEncoded = encodeURIComponent(state); // using built in function\n  const base64 = typeof btoa === 'undefined' ? Buffer.from(uriEncoded, 'utf-8').toString('base64') : btoa(uriEncoded); // using built in function\n  const base64url = base64.replace(/\\+/g, '-').replace(/\\//g, '_');\n  return base64url.replace(/=/g, '');\n}\n\nexport function decodeContentState(encodedContentState: string): string {\n  const base64url = restorePadding(encodedContentState);\n  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');\n  const base64Decoded = typeof atob === 'undefined' ? Buffer.from(base64, 'base64').toString('utf-8') : atob(base64); // using built in function\n  return decodeURIComponent(base64Decoded).trim(); // using built in function\n}\n\nfunction restorePadding(s: string) {\n  // The length of the restored string must be a multiple of 4\n  const pad = s.length % 4;\n\n  if (pad === 1) {\n    throw new Error('InvalidLengthError: Input base64url string is the wrong length to determine padding');\n  }\n\n  return s + (pad ? '===='.slice(0, 4 - pad) : '');\n}\n\nexport function normaliseContentState(state: ContentState): NormalisedContentState {\n  if (!state) {\n    throw new Error('Content state is empty');\n  }\n\n  if (!Array.isArray(state)) {\n    // We have multiples.\n    // throw new Error('Content state is an [Array] and not yet supported');\n    state = [state];\n  }\n\n  let annoId = 'vault://virtual-annotation/' + new Date().getTime(); // <-- need a virtual id\n  const motivation: AnyMotivation[] = ['contentState'];\n  const targets = [];\n\n  for (const source of state) {\n    if (typeof source === 'string') {\n      // Note: this is unlikely to happen in conjunction with parseContentState()\n      throw new Error('Content state is a [String] type and cannot be inferred');\n    }\n\n    // If we DO have annotation, then this is all we should be returning.\n    if (source.type === 'Annotation') {\n      annoId = source.id;\n      if (Array.isArray(source.motivation)) {\n        for (const singleMotivation of source.motivation) {\n          if (motivation.indexOf(singleMotivation) === -1) {\n            motivation.push(singleMotivation);\n          }\n        }\n      }\n\n      if (Array.isArray(source.target)) {\n        for (const target of source.target) {\n          const expanded = expandTarget(target as any);\n          targets.push(expanded);\n        }\n      } else {\n        const expanded = expandTarget(source.target as any);\n        targets.push(expanded);\n      }\n\n      continue;\n    }\n\n    const target = expandTarget(source as any);\n    targets.push(target);\n  }\n\n  return {\n    id: annoId,\n    type: 'Annotation',\n    motivation: ['contentState', ...((state as any).motivation || [])],\n    target: targets,\n    extensions: {},\n  };\n}\n"],"mappings":"2DAiCA,SAAgB,EAAqB,EAA0B,EAAS,GAA2B,CAEjG,GAAI,OAAO,GAAe,SAAU,CAClC,GAAI,EAAW,WAAW,KACxB,GAAI,CACF,IAAM,EAAS,KAAK,MAAM,GAC1B,OAAO,EAAqB,QAChB,CACZ,MAAO,CAAC,GAAO,CAAE,OAAQ,iBAG7B,MAAO,CAAC,IAGV,GAAI,MAAM,QAAQ,GAAa,CAC7B,IAAK,IAAM,KAAQ,EAAY,CAC7B,GAAM,CAAC,EAAO,GAAU,EAAqB,GAC7C,GAAI,CAAC,GAAS,EACZ,MAAO,CAAC,EAAO,GAInB,MAAO,CAAC,IAYV,OATI,EAAW,OAAS,aAEf,CAAC,IAGN,GAAU,EAAW,OAAS,UAAY,CAAC,EAAW,OACjD,CAAC,GAAO,CAAE,OAAQ,2CAGpB,CAAC,IAGV,SAAgB,EAAsB,EAAkC,CACtE,OAAO,EAAmB,OAAO,GAAe,SAAW,EAAa,KAAK,UAAU,IAMzF,SAAgB,EAAkB,EAAe,EAAgE,CAG/G,GAFA,EAAQ,EAAM,OAEV,EAAM,KAAO,IAEf,OAAO,EAAiB,QAAQ,QAAQ,KAAK,MAAM,IAAU,KAAK,MAAM,GAG1E,GAAI,EAAM,WAAW,QAAS,CAC5B,GAAI,CAAC,EACH,MAAU,MAAM,mEAGlB,OAAO,MAAM,GAAO,KAAM,GAAM,EAAE,QAGpC,OAAO,EAAkB,EAAmB,GAAQ,GAGtD,SAAgB,EAAmB,EAAuB,CACxD,IAAM,EAAa,mBAAmB,GAChC,EAAS,OAAO,KAAS,IAAc,OAAO,KAAK,EAAY,SAAS,SAAS,UAAY,KAAK,GAClG,EAAY,EAAO,QAAQ,MAAO,KAAK,QAAQ,MAAO,KAC5D,OAAO,EAAU,QAAQ,KAAM,IAGjC,SAAgB,EAAmB,EAAqC,CACtE,IAAM,EAAY,EAAe,GAC3B,EAAS,EAAU,QAAQ,KAAM,KAAK,QAAQ,KAAM,KACpD,EAAgB,OAAO,KAAS,IAAc,OAAO,KAAK,EAAQ,UAAU,SAAS,SAAW,KAAK,GAC3G,OAAO,mBAAmB,GAAe,OAG3C,SAAS,EAAe,EAAW,CAEjC,IAAM,EAAM,EAAE,OAAS,EAEvB,GAAI,IAAQ,EACV,MAAU,MAAM,uFAGlB,OAAO,GAAK,EAAM,OAAO,MAAM,EAAG,EAAI,GAAO,IAG/C,SAAgB,EAAsB,EAA6C,CACjF,GAAI,CAAC,EACH,MAAU,MAAM,0BAGb,MAAM,QAAQ,KAGjB,EAAQ,CAAC,IAGX,IAAI,EAAS,8BAAgC,IAAI,OAAO,UAClDA,EAA8B,CAAC,gBAC/B,EAAU,GAEhB,IAAK,IAAM,KAAU,EAAO,CAC1B,GAAI,OAAO,GAAW,SAEpB,MAAU,MAAM,2DAIlB,GAAI,EAAO,OAAS,aAAc,CAEhC,GADA,EAAS,EAAO,GACZ,MAAM,QAAQ,EAAO,gBAClB,IAAM,KAAoB,EAAO,WAChC,EAAW,QAAQ,KAAsB,IAC3C,EAAW,KAAK,GAKtB,GAAI,MAAM,QAAQ,EAAO,QACvB,IAAK,IAAMC,KAAU,EAAO,OAAQ,CAClC,IAAM,EAAW,EAAaA,GAC9B,EAAQ,KAAK,OAEV,CACL,IAAM,EAAW,EAAa,EAAO,QACrC,EAAQ,KAAK,GAGf,SAGF,IAAM,EAAS,EAAa,GAC5B,EAAQ,KAAK,GAGf,MAAO,CACL,GAAI,EACJ,KAAM,aACN,WAAY,CAAC,eAAgB,GAAK,EAAc,YAAc,IAC9D,OAAQ,EACR,WAAY"}