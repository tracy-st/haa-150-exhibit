{"version":3,"file":"image-service-BvY9CGnV.js","names":["newTiles: ImageTile[]","log: string[]","request: Required<ImageCandidateRequest>","lastResorts: UnknownSizeImage[]","fallback: Array<FixedSizeImage | VariableSizeImage>","currentChoice: ImageCandidate | null","imagesSizes: ImageCandidate[]","candidates: ImageCandidate[]","candidates: ImageCandidate[]","imageServices","request: ImageServiceRequest","imageServices","request: ImageServiceRequest","service","mitt","handler: Handler<ImageServiceStoreEvents['image-service.loaded']>","error: any"],"sources":["../src/image-service/get-image-server-from-id.ts","../src/image-service/sampled-tiles-to-tiles.ts","../src/image-service/get-image-from-tile-source.ts","../src/image-service/is-best-match.ts","../src/image-service/pick-best-from-candidates.ts","../src/image-service/is-image-3.ts","../src/image-service/get-fixed-sizes-from-service.ts","../src/image-service/get-custom-size-from-service.ts","../src/image-service/get-image-candidates-from-service.ts","../src/image-service/infer-size-from-url.ts","../src/image-service/get-fixed-size-from-image.ts","../src/image-service/get-image-candidates.ts","../src/image-service/image-sizes-match.ts","../src/image-service/image-service-loader.ts","../src/image-service/image-service-store.ts","../src/image-service/get-smallest-scale-factor-as-single-image.ts"],"sourcesContent":["/**\n * Get image server from ID.\n *\n * Normalises image service URLs to extract identity of the image server.\n *\n * @param url\n */\nexport function getImageServerFromId(url: string): string {\n  // Strip off the protocol + www\n  const id = url.replace(/(https?:\\/\\/)?(www.)?/i, '');\n\n  // Strip off the path.\n  if (id.indexOf('/') !== -1) {\n    return id.split('/')[0]!;\n  }\n\n  // Return the id.\n  return id;\n}\n","import { ImageTile } from '@iiif/presentation-3';\n\nexport function sampledTilesToTiles(width: number, height: number, sampledTiles: ImageTile[]): ImageTile[] {\n  const maxDim = width > height ? width : height;\n  const len = sampledTiles.length;\n  const newTiles: ImageTile[] = [];\n\n  for (let i = 0; i < len; i++) {\n    const tile = sampledTiles[i];\n    if (!tile) continue;\n    if (tile.scaleFactors.length === 0) continue;\n\n    let lastSize = tile.scaleFactors[0];\n    if (!lastSize) continue;\n\n    let curWidth = maxDim / lastSize;\n    const scaleFactors = [lastSize];\n    while (curWidth >= tile.width) {\n      lastSize = lastSize * 2;\n      scaleFactors.push(lastSize);\n      curWidth = curWidth / 2;\n    }\n\n    newTiles.push({\n      ...tile,\n      scaleFactors,\n    });\n  }\n\n  return newTiles;\n}\n","import {\n  canonicalServiceUrl,\n  createImageServiceRequest,\n  getId,\n  imageServiceRequestToString,\n} from '@iiif/parser/image-3';\nimport { FixedSizeImage, FixedSizeImageService } from './types';\nimport { ImageProfile } from '@iiif/presentation-3';\n\nexport function getImageFromTileSource(\n  image: FixedSizeImageService,\n  targetWidth: number,\n  targetHeight?: number\n): FixedSizeImage {\n  // @todo this needs to determine levels 0, 1 + 2.\n  const req = createImageServiceRequest({\n    '@context':\n      image.version === 3 ? 'http://iiif.io/api/image/3/context.json' : 'http://iiif.io/api/image/2/context.json',\n    id: canonicalServiceUrl(getId(image)),\n    profile:\n      image.level === null || typeof image.level === 'undefined'\n        ? ('level0' as ImageProfile)\n        : (`level${image.level}` as ImageProfile),\n    type: image.version === 3 ? 'ImageService3' : 'ImageService2',\n  });\n\n  if (req.type !== 'image') {\n    throw new Error('Invalid service');\n  }\n\n  req.size.max = false;\n  req.size.width = targetWidth;\n  req.size.height = targetHeight;\n\n  const url = imageServiceRequestToString(req);\n\n  return {\n    id: url,\n    type: 'fixed',\n    width: targetWidth,\n    height: targetHeight || (image.height / (image.width || 1)) * targetWidth,\n    unsafe: image.width > targetWidth,\n  };\n}\n","import { FixedSizeImage, ImageCandidateRequest } from './types';\n\nexport function isBestMatch(\n  request: Required<ImageCandidateRequest>,\n  current: FixedSizeImage | null,\n  candidate: FixedSizeImage\n) {\n  const width = !request.width ? request.maxWidth : request.width;\n\n  return (\n    candidate.height <= request.maxHeight &&\n    candidate.width <= request.maxWidth &&\n    candidate.height >= request.minHeight &&\n    candidate.width >= request.minWidth &&\n    (!current || Math.abs(candidate.width - width) < Math.abs(current.width - width))\n  );\n}\n","import { getImageFromTileSource } from './get-image-from-tile-source';\nimport { isBestMatch } from './is-best-match';\nimport { FixedSizeImage, ImageCandidate, ImageCandidateRequest, UnknownSizeImage, VariableSizeImage } from './types';\n\n/**\n * Pick best from candidates\n *\n * Takes in a list of candidate lists. The order should be in preference. This algorithm will try to pick\n * from the first list, with a best fit size. If not it will fallback to the other lists. It may come back\n * around to the first list and provide a fallback.\n *\n * @param inputRequest\n * @param candidates\n */\nexport function pickBestFromCandidates(\n  inputRequest: ImageCandidateRequest,\n  candidates: Array<() => ImageCandidate[]>\n): { best: ImageCandidate | null; fallback: ImageCandidate[]; log: string[] } {\n  const log: string[] = [];\n  const request: Required<ImageCandidateRequest> = Object.assign(\n    {\n      unsafeImageService: false,\n      atAnyCost: true,\n      fallback: true,\n      minHeight: 64,\n      minWidth: 64,\n      maxHeight: Infinity,\n      maxWidth: Infinity,\n      returnAllOptions: false,\n      preferFixedSize: false,\n      allowUnsafe: false,\n      explain: false,\n      height: 0,\n      width: 0,\n    },\n    inputRequest\n  );\n  const explain = (text: () => string, indent = 0) =>\n    request.explain\n      ? log.push(\n          new Array(indent)\n            .fill(0)\n            .map((e) => '    ')\n            .join('') + text().trim()\n        )\n      : undefined;\n  const lastResorts: UnknownSizeImage[] = [];\n  const fallback: Array<FixedSizeImage | VariableSizeImage> = [];\n  let currentChoice: ImageCandidate | null = null;\n\n  explain(() => `Using configuration: ${JSON.stringify(request, null, 2)}`);\n\n  const swapChoice = (candidate: FixedSizeImage, current: FixedSizeImage | null) => {\n    explain(() => 'Swapping choice', 3);\n\n    if (isBestMatch(request, current, candidate)) {\n      // If we prefer a fixed size, we'll push it onto the fallback. But a fixed size will be looked for\n      // from all of the candidates.\n      if (request.preferFixedSize && candidate.unsafe) {\n        explain(() => `We found an image that was marked as unsafe, but it was the best size. (${candidate.id})`, 4);\n        fallback.push(candidate);\n        return;\n      }\n\n      if (request.returnAllOptions && current) {\n        fallback.push(current);\n      }\n      explain(() => `We found a new image that was the best size. (${candidate.id})`, 4);\n      // We have a new candidate.\n      currentChoice = candidate;\n    } else if (request.returnAllOptions) {\n      fallback.push(candidate);\n    }\n  };\n\n  explain(() => `The input shows we have ${candidates.length} list(s) of candidates to choose from.`);\n  const candidateGroups = candidates.length;\n  for (let x = 0; x < candidateGroups; x++) {\n    const group = candidates[x]!();\n\n    explain(() => `Candidate group ${x}: ${JSON.stringify(group, null, 2)}`, 1);\n\n    const candidatesLength = group.length;\n    explain(\n      () => `Checking candidate list number ${x} and found ${candidatesLength} potential ways of creating image(s)`,\n      1\n    );\n    for (let y = 0; y < candidatesLength; y++) {\n      const candidate = group[y]!;\n      explain(() => `-> Checking candidate ${y}`, 1);\n      if (candidate.type === 'unknown' && request.atAnyCost) {\n        explain(() => `We've found an unknown image type, adding this to the \"last resort\" list`, 2);\n        lastResorts.push(candidate);\n      }\n      if (candidate.type === 'fixed') {\n        if (candidate.unsafe) {\n          explain(() => `We've found an unsafe fixed image type, adding this to the \"last resort\" list`, 2);\n          lastResorts.push(candidate as any);\n        } else {\n          explain(() => `We've found a fixed size image, checking if it matches the request`, 2);\n          swapChoice(candidate, currentChoice);\n        }\n      }\n      if (candidate.type === 'fixed-service') {\n        if (request.unsafeImageService) {\n          // @todo fit within on request height/width based on candidate.\n          explain(\n            () =>\n              `Checking for an image from the tile source, without calculating the right height and width (unsafeImageService)`,\n            2\n          );\n          const choice = getImageFromTileSource(candidate, request.width, request.height);\n          swapChoice(choice, currentChoice);\n        } else {\n          explain(() => `Checking for an image from the tile source 3`, 2);\n          const choice = getImageFromTileSource(candidate, candidate.width, candidate.height);\n\n          swapChoice(choice, currentChoice);\n        }\n      }\n      if (candidate.type === 'variable') {\n        if (candidate.maxWidth) {\n          const choice = getImageFromTileSource(\n            {\n              id: candidate.id,\n              type: 'fixed-service',\n              width: candidate.maxWidth,\n              height: candidate.maxWidth,\n              level: candidate.level,\n              version: candidate.version,\n            },\n            candidate.maxWidth\n          );\n\n          swapChoice(choice, currentChoice);\n        }\n      }\n    }\n    if (currentChoice && !request.returnAllOptions) {\n      if ((currentChoice as any).unsafe || request.allowUnsafe) {\n        continue;\n      }\n\n      explain(() => `We found a match in choice list number ${x}, no searching any more`);\n      break;\n    }\n  }\n\n  if (request.atAnyCost && fallback.length === 0) {\n    explain(() =>\n      currentChoice\n        ? `We found an image! ${currentChoice.id} of type ${currentChoice.type}`\n        : `We found no images, but \"atAnyCost\" is set, so returning that`\n    );\n    return {\n      best: currentChoice || lastResorts[0] || null,\n      fallback: lastResorts.slice(1),\n      log,\n    };\n  }\n\n  if (request.returnAllOptions) {\n    explain(() => `Returning all options that we have found`);\n    return {\n      best: (request.atAnyCost ? currentChoice || fallback[0] || lastResorts[0] : currentChoice || fallback[0]) || null,\n      fallback: [...fallback, ...lastResorts],\n      log,\n    };\n  }\n\n  explain(() => `Returning the best image that we found, and a fallback`);\n\n  return {\n    best: currentChoice || fallback[0] || null,\n    fallback: currentChoice ? fallback : fallback.slice(1),\n    log,\n  };\n}\n","export function isImage3(service: any) {\n  const context = service['@context']\n    ? Array.isArray(service['@context'])\n      ? service['@context']\n      : [service['@context']]\n    : [];\n  return context.indexOf('http://iiif.io/api/image/3/context.json') !== -1;\n}\n","import { Service } from '@iiif/presentation-3';\nimport { FixedSizeImageService } from './types';\nimport { getId, isImageService, getImageServiceLevel } from '@iiif/parser/image-3';\nimport { isImage3 } from './is-image-3';\n\n/**\n * Get fixed sizes from service.\n *\n * Given an image service, this will extract the images from the sizes field of\n * the service. These are usually cached and great options for thumbnails.\n *\n * @param service\n */\nexport function getFixedSizesFromService(service: Service): FixedSizeImageService[] {\n  if (!isImageService(service)) {\n    return [];\n  }\n  return (service && service.sizes ? service.sizes : []).map((size: any) => {\n    return {\n      id: getId(service),\n      type: 'fixed-service',\n      height: size.height,\n      width: size.width,\n      level: getImageServiceLevel(service),\n      version: isImage3(service) ? 3 : 2,\n    };\n  });\n}\n","import { ImageCandidate } from './types';\nimport { isImage3 } from './is-image-3';\nimport { ImageService } from '@iiif/presentation-3';\nimport { getId, supportsCustomSizes, getImageServiceLevel } from '@iiif/parser/image-3';\n\n/**\n * Get custom size from service\n *\n * Given an image service – usually a full one, de-referenced or embedded – this\n * will return a list of available image sizes (min and max width and height) that\n * can be used to construct a IIIF query to get an image at any size within those\n * bounds. This is only supported by some image services. If unsupported, this will\n * return an empty list.\n *\n * @param service\n */\nexport function getCustomSizeFromService(service: ImageService): ImageCandidate[] {\n  if (!supportsCustomSizes(service)) {\n    return [];\n  }\n\n  const imagesSizes: ImageCandidate[] = [];\n\n  // Check for max width in profile.\n  const profiles = Array.isArray(service.profile) ? service.profile : [service.profile];\n\n  const pLen = profiles.length;\n  for (let x = 0; x < pLen; x++) {\n    const profile = profiles[x];\n    if (profile && typeof profile !== 'string') {\n      if (profile.maxHeight || profile.maxWidth) {\n        return [\n          {\n            id: getId(service),\n            type: 'variable',\n            minWidth: 0,\n            minHeight: 0,\n            maxHeight: (profile.maxHeight || profile.maxWidth) as number,\n            maxWidth: (profile.maxWidth || profile.maxHeight) as number,\n            level: getImageServiceLevel(service),\n            version: service['@context'] === 'http://iiif.io/api/image/3/context.json' ? 3 : 2,\n          },\n        ];\n      }\n    }\n  }\n\n  if (service.tiles) {\n    const len = service.tiles.length;\n    for (let y = 0; y < len; y++) {\n      const tile = service.tiles[y];\n      if (tile && (tile.height || tile.width)) {\n        imagesSizes.push({\n          id: getId(service),\n          type: 'variable',\n          minHeight: 0,\n          minWidth: 0,\n          maxHeight: tile.height || tile.width,\n          maxWidth: tile.width,\n          level: getImageServiceLevel(service),\n          version: isImage3(service) ? 3 : 2,\n        });\n      }\n    }\n  }\n\n  return imagesSizes;\n}\n","import { ImageService } from '@iiif/presentation-3';\nimport { ImageCandidate } from './types';\nimport { getFixedSizesFromService } from './get-fixed-sizes-from-service';\nimport { getCustomSizeFromService } from './get-custom-size-from-service';\n\nexport function getImageCandidatesFromService(service: ImageService[]): ImageCandidate[] {\n  const candidates: ImageCandidate[] = [];\n\n  const totalServices = service.length;\n  for (let s = 0; s < totalServices; s++) {\n    const single = service[s];\n    if (!single) continue;\n    // - x.2 embedded service - fixed sizes\n    const fixedSizes = getFixedSizesFromService(single);\n    if (fixedSizes.length) {\n      candidates.push(...fixedSizes);\n    }\n    // - x.3 embedded service - profile 1 / 2 (custom size)\n    const customSizes = getCustomSizeFromService(single);\n    if (customSizes.length) {\n      candidates.push(...customSizes);\n    }\n  }\n\n  return candidates;\n}\n","import { ImageCandidate } from './types';\n\n/**\n * Extracts the height and width from an image URL\n *\n * @param image\n */\nexport function inferImageSizeFromUrl(image: string): ImageCandidate {\n  const regex = /^.*\\/(full)\\/(((\\d+),(\\d+)?)|max)\\/(\\d+)\\/default\\.(jpg|png|jpeg)$/;\n  const match = image.match(regex);\n\n  if (match && match[4] && match[5]) {\n    const region = match[1];\n    const width = parseInt(match[4], 10);\n    const height = parseInt(match[5], 10);\n    // const rotation = parseInt(match[6], 10);\n    const format = match[7];\n\n    if ((region === 'max' || region === 'full') && width && height && format) {\n      return {\n        type: 'fixed',\n        id: image,\n        height,\n        width,\n      };\n    }\n  }\n\n  return { type: 'unknown', id: image };\n}\n","import { ContentResource, IIIFExternalWebResource } from '@iiif/presentation-3';\nimport { ImageCandidate } from './types';\nimport { inferImageSizeFromUrl } from './infer-size-from-url';\nimport { getId, getType } from '@iiif/parser/image-3';\n\n/**\n * Get fixed size from image\n *\n * Given a content resource, usually the body of a painting annotation, this will\n * return the URL to the image, and the height and width. The resource may also\n * be a string / direct link to the image. The height and width may be inferred from\n * a IIIF Image API endpoint, otherwise the return image candidate will have a type\n * of unknown.\n *\n * @param contentResource\n */\nexport function getFixedSizeFromImage(contentResource: ContentResource | string): ImageCandidate | null {\n  if (typeof contentResource === 'string') {\n    // Might not even be an image.\n    return inferImageSizeFromUrl(contentResource);\n  }\n\n  const type = getType(contentResource);\n  if (type !== 'Image' && type !== 'sc:Image') {\n    return null;\n  }\n\n  const image = contentResource as IIIFExternalWebResource;\n  const id = getId(image);\n\n  if (!id) {\n    return null;\n  }\n\n  if (id && image.width && image.height) {\n    return {\n      id: id,\n      type: 'fixed',\n      width: image.width,\n      height: image.height,\n      unsafe: true,\n    };\n  }\n\n  return inferImageSizeFromUrl(id);\n}\n","import { ContentResource, IIIFExternalWebResource } from '@iiif/presentation-3';\nimport { ImageServiceLoader, ImageServiceRequest } from './image-service-loader';\nimport { ImageCandidate } from './types';\nimport { getImageCandidatesFromService } from './get-image-candidates-from-service';\nimport { getFixedSizeFromImage } from './get-fixed-size-from-image';\nimport { getId, getImageServices } from '@iiif/parser/image-3';\n\n/**\n * Get image candidates\n *\n * Given an unknown resource, and optionally an image service loader, it will\n * try to get all of the possible options for images at a specific size.\n *\n * Note: if you are wanting to depend on external web resources, then you have\n * to either preload these, or prepare the image loader for predicting them.\n *\n * @param unknownResource\n * @param dereference\n * @param loader\n */\nexport function getImageCandidates(\n  unknownResource: ContentResource,\n  dereference = true,\n  loader: ImageServiceLoader\n): ImageCandidate[] {\n  const candidates: ImageCandidate[] = [];\n  const fixedSizeFromImage = getFixedSizeFromImage(unknownResource);\n  if (fixedSizeFromImage === null) {\n    return candidates;\n  }\n  // Cast to IIIF resource, assuming we are working in that context.\n  const resource = unknownResource as IIIFExternalWebResource;\n\n  // - x.1 fixed size\n  // - x.4 ID of thumbnail (without width/height)\n  candidates.push(fixedSizeFromImage);\n\n  // We will try to dereference if available (cache or prediction).\n  if (dereference && resource && resource.width && resource.height) {\n    const refCandidates = [];\n    const imageServices = getImageServices(resource);\n    for (const service of imageServices) {\n      const request: ImageServiceRequest = {\n        id: getId(service),\n        width: resource.width,\n        height: resource.height,\n      };\n      if (loader.canLoadSync(request)) {\n        const externalService = loader.loadServiceSync(request);\n        if (externalService) {\n          if (!externalService.height) {\n            externalService.height = resource.height;\n          }\n          if (!externalService.width) {\n            externalService.width = resource.width;\n          }\n          refCandidates.push(...getImageCandidatesFromService([externalService]));\n        }\n      }\n    }\n\n    if (refCandidates.length) {\n      candidates.push(...refCandidates);\n      return candidates;\n    }\n  }\n\n  // Embedded service.\n  if (resource.service) {\n    candidates.push(...getImageCandidatesFromService(resource.service as any));\n  }\n\n  return candidates;\n}\n","import { ImageSize } from '@iiif/presentation-3';\n\nexport function imageSizesMatch(sizesA: ImageSize[], sizesB: ImageSize[]): boolean {\n  if (sizesA.length !== sizesB.length) {\n    return false;\n  }\n\n  if (sizesA.length === 0 && sizesB.length === 0) {\n    return true;\n  }\n\n  const len = sizesA.length;\n  let matchOrder = true;\n  for (let i = 0; i < len; i++) {\n    const a = sizesA[i]!;\n    const b = sizesB[i]!;\n    if (a.width !== b.width || a.height !== b.height) {\n      matchOrder = false;\n      break;\n    }\n  }\n  if (matchOrder) {\n    return true;\n  }\n\n  let matching = 0;\n  for (let a = 0; a < len; a++) {\n    for (let b = 0; b < len; b++) {\n      if (sizesA[a]!.width === sizesB[b]!.width && sizesA[a]!.height === sizesB[b]!.height) {\n        matching++;\n        break;\n      }\n    }\n  }\n\n  return matching === len;\n}\n","import {\n  isLevel0,\n  getId,\n  canonicalServiceUrl,\n  extractFixedSizeScales,\n  fixedSizesFromScales,\n  getImageServices,\n} from '@iiif/parser/image-3';\nimport {\n  ContentResource,\n  IIIFExternalWebResource,\n  ImageProfile,\n  ImageSize,\n  ImageTile,\n  ImageService,\n} from '@iiif/presentation-3';\nimport { getImageServerFromId } from './get-image-server-from-id';\nimport { sampledTilesToTiles } from './sampled-tiles-to-tiles';\nimport { ImageCandidate, ImageCandidateRequest } from './types';\nimport { pickBestFromCandidates } from './pick-best-from-candidates';\nimport { getImageCandidates } from './get-image-candidates';\nimport { imageSizesMatch } from './image-sizes-match';\n\nexport type ImageServer = {\n  root: string;\n  server: string | null; // @todo future enhancement (e.g. iipsrv, dlcs)\n  sampledId: string;\n  verifications: number;\n  verified: boolean;\n  preLoaded: boolean;\n  malformed: boolean;\n  result: {\n    context: string | string[];\n    resourceServiceRatio: number;\n    sampledSizes: ImageSize[];\n    sizeRatios: number[];\n    sampledTiles: ImageTile[];\n    sampledProfile: ImageProfile | ImageProfile[];\n  };\n};\n\nexport type ImageServiceRequest = {\n  id: string;\n  width: number;\n  height: number;\n  source?: ImageService;\n};\n\ntype LoadedImageService = ImageService & {\n  real: boolean;\n};\n\nexport type ImageServiceLoaderConfig = {\n  verificationsRequired: number;\n  approximateServices: boolean;\n  enableFetching: boolean;\n  disableThrottling: boolean;\n};\n\nexport class ImageServiceLoader {\n  constructor(options: Partial<ImageServiceLoaderConfig> = {}) {\n    this.config = Object.assign(this.config, options);\n  }\n\n  config: ImageServiceLoaderConfig = {\n    verificationsRequired: 1,\n    approximateServices: false,\n    enableFetching: true,\n    disableThrottling: false,\n  };\n\n  fetchingCount = 0;\n\n  imageServices: {\n    [k: string]: LoadedImageService;\n  } = {};\n\n  knownImageServers: {\n    [k: string]: ImageServer;\n  } = {};\n\n  /**\n   * Preload image service\n   *\n   * This will preload an image service, fetching details and recording the image server that served\n   * the request. Based on this it will make a template for predicting other image sources from this\n   * server. You can optionally pass in other ids to verify that the prediction is accurate.\n   *\n   */\n  // async preload(id: string, verify?: string[]): Promise<void> {}\n\n  setConfig(config: Partial<ImageServiceLoaderConfig>) {\n    Object.assign(this.config, config);\n  }\n\n  /**\n   * Sample pre-fetched service\n   *\n   * If you have already fetched an image service, or are creating a viewer that only talks to a single\n   * image server and want to avoid calls, you can sample a service up-front. This will allow you to make\n   * completely synchronous calls to `loadServiceSync` and avoid any network calls for image services.\n   *\n   * @param service\n   * @param preLoaded Mark this as being pre-loaded (default: true)\n   */\n  sample(service: ImageService, imageServiceRequest?: ImageServiceRequest, preLoaded = true) {\n    const server = getImageServerFromId(getId(service));\n    const serviceUrl = canonicalServiceUrl(getId(service));\n    const existing = this.knownImageServers[server];\n\n    this.imageServices[serviceUrl] = Object.assign(service, { real: true });\n\n    if (!existing && service.tiles && !isLevel0(service)) {\n      // Add new prediction.\n      this.knownImageServers[server] = {\n        verifications: 0,\n        malformed: false,\n        root: server,\n        preLoaded,\n        sampledId: getId(service),\n        verified: false,\n        server: null,\n        result: {\n          context: service['@context'] || [],\n          sampledProfile: service.profile,\n          resourceServiceRatio: imageServiceRequest && service.height ? imageServiceRequest.height / service.height : 1,\n          sampledSizes: service.sizes || [],\n          sizeRatios: extractFixedSizeScales(service.width as number, service.height as number, service.sizes || []),\n          sampledTiles: service.tiles || [],\n        },\n      };\n      return true;\n    }\n\n    return this.verify(service as ImageServiceRequest);\n  }\n\n  /**\n   * Preload an image server\n   *\n   * Similar to sample, but faster. This will bypass any checks and the logic contained in this implementation\n   * allowing you to correct mistakes this implementation might have made.\n   *\n   * @param server\n   * @param forceVerify\n   */\n  preLoad(server: ImageServer, forceVerify = true) {\n    this.knownImageServers[server.root] = server;\n    if (forceVerify) {\n      this.knownImageServers[server.root]!.malformed = false;\n      this.knownImageServers[server.root]!.verifications = this.config.verificationsRequired;\n    }\n  }\n\n  /**\n   * Predict\n   *\n   * Predicts what the image service will be for a content resource.\n   *\n   * @param resource\n   * @param verify\n   * @param force\n   */\n  predict(resource: ImageServiceRequest, verify = false, force = false): ImageService | null {\n    const source = resource?.source;\n    const serverId = getImageServerFromId(getId(resource));\n    const imageServer = this.knownImageServers[serverId];\n    const serviceUrl = canonicalServiceUrl(getId(resource));\n\n    if (this.imageServices[serviceUrl]) {\n      return this.imageServices[serviceUrl] || null;\n    }\n\n    if (!this.config.approximateServices) {\n      return null;\n    }\n\n    // No known image server.\n    if (\n      !imageServer ||\n      !imageServer.result ||\n      !(source?.height || resource.height) ||\n      !(source?.width || resource.width) ||\n      (!force && (imageServer.malformed || imageServer.verifications < this.config.verificationsRequired)) ||\n      (resource.source && isLevel0(resource.source))\n    ) {\n      return null;\n    }\n\n    if (!this.imageServices[serviceUrl]) {\n      this.imageServices[serviceUrl] = {\n        '@context': imageServer.result.context,\n        '@id': getId(resource),\n        id: getId(resource),\n        protocol: 'http://iiif.io/api/image',\n        tiles: source?.tiles || sampledTilesToTiles(resource.width, resource.height, imageServer.result.sampledTiles),\n        sizes:\n          source?.sizes ||\n          fixedSizesFromScales(\n            Math.round(resource.width / imageServer.result.resourceServiceRatio),\n            Math.round(resource.height / imageServer.result.resourceServiceRatio),\n            imageServer.result.sizeRatios\n          ),\n        profile: source?.profile || imageServer.result.sampledProfile,\n        height: source?.height || resource.height,\n        width: source?.width || resource.width,\n        real: false,\n      } as any;\n    }\n\n    return this.imageServices[serviceUrl] || null;\n  }\n\n  async getThumbnailFromResource(\n    unknownResource: ContentResource | undefined,\n    request: ImageCandidateRequest,\n    dereference = true,\n    otherCandidates: ImageCandidate[] = []\n  ) {\n    const candidates = unknownResource ? await this.getImageCandidates(unknownResource, dereference) : [];\n\n    return pickBestFromCandidates(request, [() => otherCandidates, () => candidates]);\n  }\n\n  async getImageCandidates(unknownResource: ContentResource, dereference = true): Promise<ImageCandidate[]> {\n    const resource = unknownResource as IIIFExternalWebResource;\n    if (dereference && resource && resource.height && resource.width) {\n      const imageServices = getImageServices(resource);\n      for (const service of imageServices) {\n        const request: ImageServiceRequest = {\n          id: getId(service),\n          width: service.width ? service.width : resource.width,\n          height: service.height ? service.height : resource.height,\n          source: service,\n        };\n        await this.loadService(request);\n      }\n    }\n\n    return getImageCandidates(unknownResource, dereference, this);\n  }\n\n  /**\n   * Verify approximation\n   *\n   * Given an image service, it will dereference that image service and compare the result with what\n   * would have been generated if we used internal guessing.\n   *\n   * @param resource\n   * @return Promise<boolean>\n   */\n  async verify(resource: ImageServiceRequest): Promise<boolean> {\n    const prediction = this.predict(resource, false, true);\n    const imageService = await this.fetchService(getId(resource));\n\n    if (!prediction) {\n      return false;\n    }\n\n    const isValid =\n      prediction.height === imageService.height &&\n      prediction.width === imageService.width &&\n      prediction['@context'] === imageService['@context'] &&\n      imageSizesMatch(prediction.sizes || [], imageService.sizes || []);\n    // @todo profiles match.\n\n    if (isValid) {\n      const serverId = getImageServerFromId(getId(resource));\n      const server = this.knownImageServers[serverId];\n      if (server) {\n        server.verifications += 1;\n        if (server.verifications >= this.config.verificationsRequired) {\n          server.verified = true;\n        }\n      }\n    }\n\n    return isValid;\n  }\n\n  canLoadSync(service: ImageServiceRequest | ImageService | string): boolean {\n    const serviceId = typeof service === 'string' ? service : getId(service);\n    const canonical = canonicalServiceUrl(serviceId);\n    if (this.imageServices[canonical]) {\n      return true;\n    }\n    const server = this.knownImageServers[getImageServerFromId(serviceId)];\n    return !!(server && !server.malformed && server.verifications >= this.config.verificationsRequired);\n  }\n\n  /**\n   * Mark image service as malformed\n   *\n   * If you run into issues requesting images, you can mark an image service as malformed, and it will\n   * return you a new one. Future image services will also be requested fresh, and the system will have\n   * failed. Report a bug if this happens.\n   *\n   * @param resource\n   */\n  async markAsMalformed(resource: ImageServiceRequest): Promise<ImageService> {\n    this.knownImageServers[getImageServerFromId(getId(resource))]!.malformed = true;\n    return this.loadService(resource, true);\n  }\n\n  /**\n   * Fetch an image service (use loadService instead)\n   *\n   * @param serviceId\n   * @param forceFresh\n   */\n  async fetchService(serviceId: string, forceFresh = false): Promise<ImageService & { real: boolean }> {\n    const serviceUrl = canonicalServiceUrl(serviceId);\n    const service = this.imageServices[serviceUrl];\n\n    if (service && (!forceFresh || service!.real)) {\n      return service;\n    }\n\n    if (!this.config.enableFetching) {\n      throw new Error('Fetching is not enabled');\n    }\n\n    const json = (await this.fetch(serviceUrl).then((service) => service.json())) as ImageService;\n\n    if (!json.id && (json as any)['@id']) {\n      json.id = (json as any)['@id'];\n    }\n\n    if (json.id !== serviceId) {\n      json.id = serviceId;\n      if (json['@id']) {\n        json['@id'] = serviceId;\n      }\n    }\n\n    this.imageServices[serviceUrl] = Object.assign(json, { real: true });\n\n    return this.imageServices[serviceUrl]!;\n  }\n\n  async fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n    return fetch(input, init);\n  }\n\n  /**\n   * Load an image service\n   *\n   * @param resource\n   * @param forceFresh\n   *\n   * @todo make this batched, so only the maximum required can be done at once, to allow\n   *       for the prediction engine to kick in.\n   */\n  async loadService(resource: ImageServiceRequest, forceFresh = false): Promise<ImageService> {\n    if (!this.config.disableThrottling) {\n      let running = true;\n      while (running) {\n        if (this.fetchingCount >= this.config.verificationsRequired) {\n          await new Promise((resolve) => setTimeout(resolve, 500));\n        } else {\n          running = false;\n          break;\n        }\n      }\n    }\n\n    const imageServer = this.knownImageServers[getImageServerFromId(getId(resource))];\n    if (imageServer && !imageServer.malformed && !forceFresh) {\n      // We have a known image server, let wait for it.\n      await imageServer.result;\n      // We should have a result at this point.\n      const service = this.loadServiceSync(resource);\n      if (service) {\n        return service;\n      }\n      // Unlikely path, but we will fall through to just load it again.\n    }\n\n    this.fetchingCount++;\n    // Fetch a real copy of the image service.\n    const serviceJson = await this.fetchService(getId(resource), forceFresh);\n    this.fetchingCount--;\n\n    if (serviceJson.real) {\n      this.sample(serviceJson, resource);\n    }\n\n    return serviceJson;\n  }\n\n  /**\n   * Load service synchronously\n   *\n   * If you know that the image service you are\n   * @param resource\n   */\n  loadServiceSync(resource: ImageServiceRequest): ImageService | null {\n    const serviceId = canonicalServiceUrl(getId(resource));\n\n    if (this.imageServices[serviceId]) {\n      return this.imageServices[serviceId]!;\n    }\n\n    if (!this.config.approximateServices) {\n      return null;\n    }\n\n    // Other-wise we do the magic.\n    return this.predict(resource);\n  }\n}\n","import { ImageServiceLoader } from './image-service-loader';\nimport { createStore } from 'zustand/vanilla';\nimport mitt, { Emitter, Handler } from 'mitt';\nimport { ImageService } from '@iiif/presentation-3';\nimport { getId } from '@iiif/parser/image-3';\n\nexport type LoadImageServiceDetail = {\n  width: number;\n  height: number;\n  force?: boolean;\n};\n\nexport interface ImageServiceStore {\n  loaded: Record<\n    string,\n    {\n      status: 'loading' | 'done' | 'error';\n      service: ImageService | null;\n      error?: boolean;\n      errorMesage?: string;\n      real?: boolean;\n    }\n  >;\n\n  loadServiceSync: (\n    service: ImageService,\n    detail?: LoadImageServiceDetail,\n    backgroundRequest?: boolean\n  ) => ImageService | null;\n  loadService: (service: ImageService, detail?: LoadImageServiceDetail) => Promise<ImageService | null>;\n}\n\nexport interface ImageServiceStoreOptions {\n  loader?: ImageServiceLoader;\n  events?: Emitter<ImageServiceStoreEvents>;\n}\n\nexport type ImageServiceStoreEvents = {\n  'image-service.loaded': {\n    id: string;\n    service: ImageService | null;\n  };\n  'image-service.loading': {\n    id: string;\n  };\n  'image-service.error': {\n    id: string;\n    error: Error;\n  };\n};\n\nexport function createImageServiceStore(options: ImageServiceStoreOptions = {}) {\n  const events = options.events || mitt<ImageServiceStoreEvents>();\n  const loader = options.loader || new ImageServiceLoader();\n\n  const store = createStore<ImageServiceStore>((set, get) => ({\n    loaded: {},\n\n    loadServiceSync: (service, detail, backgroundRequest) => {\n      const id = service.id || (service['@id'] as string);\n      const existing = get().loaded[id];\n\n      if (existing && existing.status === 'done') {\n        return existing.service;\n      }\n\n      if (existing && existing.status === 'loading') {\n        return null;\n      }\n\n      if (existing && existing.status === 'error') {\n        throw new Error('Failed to load image service');\n      }\n\n      const request = {\n        id: getId(service),\n        width: service.width || detail?.width || 0,\n        height: service.height || detail?.height || 0,\n        source: service,\n      };\n\n      const loaded = loader.loadServiceSync(request);\n      if (loaded) {\n        set((state) => ({\n          loaded: {\n            ...state.loaded,\n            [id]: {\n              status: 'done',\n              service: loaded,\n              real: true,\n            },\n          },\n        }));\n\n        events.emit('image-service.loaded', { id, service: loaded });\n      } else {\n        if (backgroundRequest) {\n          get()\n            .loadService(service, detail)\n            .then(() => {\n              // ?\n            });\n        }\n      }\n\n      return loaded;\n    },\n\n    loadService: async (service: ImageService, detail) => {\n      const id = service.id || (service['@id'] as string);\n      const existing = get().loaded[id];\n\n      if (existing && existing.status === 'done') {\n        return existing.service;\n      }\n\n      if (existing && existing.status === 'loading') {\n        return new Promise<ImageService>((resolve, reject) => {\n          const handler: Handler<ImageServiceStoreEvents['image-service.loaded']> = (e) => {\n            if (e.id === id) {\n              events.off('image-service.loaded', handler);\n              resolve(e.service || service);\n            }\n          };\n          events.on('image-service.loaded', handler);\n        });\n      }\n\n      if (existing && existing.status === 'error' && !detail?.force) {\n        throw new Error('Failed to load image service');\n      }\n\n      events.emit('image-service.loading', { id });\n      try {\n        const request = {\n          id: getId(service),\n          width: service.width || 0,\n          height: service.height || 0,\n          source: service,\n        };\n\n        const loaded = await loader.loadService(request, detail?.force);\n\n        set((state) => ({\n          loaded: {\n            ...state.loaded,\n            [id]: {\n              status: 'done',\n              service: loaded,\n              real: (loaded as any).real,\n            },\n          },\n        }));\n\n        events.emit('image-service.loaded', { id, service: loaded });\n\n        return loaded;\n      } catch (error: any) {\n        events.emit('image-service.error', { id, error });\n        throw error;\n      }\n    },\n  }));\n\n  return {\n    store,\n    events,\n  };\n}\n\nexport const imageServices = createImageServiceStore();\n","import { ImageService } from '@iiif/presentation-3';\nimport { isImage3 } from './is-image-3';\nimport { FixedSizeImageService } from './types';\nimport { getId, getImageServiceLevel } from '@iiif/parser/image-3';\n\n/**\n * Returns a fixed size image using the tile using the largest available size,\n * or the smallest scale factor.\n *\n * @param service\n */\nexport function getSmallestScaleFactorAsSingleImage(service: ImageService): FixedSizeImageService | null {\n  if (!service.width || !service.height) {\n    return null;\n  }\n\n  if (service.tiles) {\n    const tiles = service.tiles.sort((a, b) => {\n      return Math.max(...b.scaleFactors) - Math.max(...a.scaleFactors);\n    });\n    const len = tiles.length;\n    for (let i = 0; i < len; i++) {\n      const tile = tiles[i];\n      if (!tile) continue;\n      // @todo possible refinement.\n      // const targetSize = tile.width > (tile.height || 0) ? tile.width : tile.height;\n      const targetSize = tile.width;\n      if (!targetSize) {\n        continue;\n      }\n      const sizeLen = tile.scaleFactors.length;\n      const sortedScales = tile.scaleFactors.sort();\n      for (let j = 0; j < sizeLen; j++) {\n        const size = sortedScales[j];\n        if (!size) continue;\n        if (service.width / size <= targetSize && service.height / size <= targetSize) {\n          return {\n            id: getId(service),\n            type: 'fixed-service',\n            width: (service.width / size) | 0,\n            height: (service.height / size) | 0,\n            level: getImageServiceLevel(service)!,\n            version: isImage3(service) ? 3 : 2,\n          };\n        }\n      }\n    }\n  }\n  return null;\n}\n"],"mappings":"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"}