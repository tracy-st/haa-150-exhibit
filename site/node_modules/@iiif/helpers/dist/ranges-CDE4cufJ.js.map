{"version":3,"file":"ranges-CDE4cufJ.js","names":["found: Reference<'Canvas'>[]","virtualRoot: Range","toc: RangeTableOfContentsNode","foundCanvas: RangeTableOfContentsNode","canvases: Array<{ canvas: Canvas; path: string[] }>","details: IsRangeContiguousDetail","result: IsRangeContiguousDetail"],"sources":["../src/shared-utilities.ts","../src/ranges.ts"],"sourcesContent":["/**\n * A string hashing function based on Daniel J. Bernstein's popular 'times 33' hash algorithm.\n * @author MatthewBarker <mrjbarker@hotmail.com>\n */\nexport function hash(object: any): string {\n  const text = JSON.stringify(object);\n\n  let numHash = 5381,\n    index = text.length;\n\n  while (index) {\n    numHash = (numHash * 33) ^ text.charCodeAt(--index);\n  }\n\n  const num = numHash >>> 0;\n\n  const hexString = num.toString(16);\n  if (hexString.length % 2) {\n    return '0' + hexString;\n  }\n  return hexString;\n}\n","import { compressSpecificResource } from '@iiif/parser';\nimport type { Canvas, InternationalString, Manifest, Range, Reference, SpecificResource } from '@iiif/presentation-3';\nimport type { CanvasNormalized, ManifestNormalized, RangeNormalized } from '@iiif/presentation-3-normalized';\nimport { type CompatVault, compatVault } from './compat';\nimport { hash } from './shared-utilities';\n\nexport function createRangeHelper(vault: CompatVault = compatVault) {\n  return {\n    findFirstCanvasFromRange: (range: RangeNormalized) => findFirstCanvasFromRange(vault, range),\n    findAllCanvasesInRange: (range: RangeNormalized) => findAllCanvasesInRange(vault, range),\n    findManifestSelectedRange: (manifest: ManifestNormalized, canvasId: string) =>\n      findManifestSelectedRange(vault, manifest, canvasId),\n    findSelectedRange: (range: RangeNormalized, canvasId: string) => findSelectedRange(vault, range, canvasId),\n    rangesToTableOfContentsTree: (\n      rangeRefs: RangeNormalized[],\n      label?: InternationalString | null,\n      options: { showNoNav?: boolean } = {}\n    ) => rangesToTableOfContentsTree(vault, rangeRefs, label, options),\n    rangeToTableOfContentsTree: (\n      rangeRef: RangeNormalized | Reference<'Range'>,\n      options: { showNoNav?: boolean } = {}\n    ) => rangeToTableOfContentsTree(vault, rangeRef, [], options),\n    isContiguous: (\n      rangeRef: RangeNormalized | Reference<'Range'>,\n      canvasesRef: Canvas[] | CanvasNormalized[] | Reference<'Canvas'>[],\n      options: Partial<{ allowGaps: boolean; allowSubset: boolean; detail?: boolean }> = {}\n    ) => isRangeContiguous(vault, rangeRef, canvasesRef, options),\n  };\n}\n\nexport function findFirstCanvasFromRange(vault: CompatVault, range: RangeNormalized): null | Reference<'Canvas'> {\n  for (const inner of range.items) {\n    if (typeof inner === 'string') {\n      return { id: inner, type: 'Canvas' };\n    }\n    if ((inner as any).type === 'Canvas') {\n      return inner as any as Reference<'Canvas'>;\n    }\n    if (inner.type === 'SpecificResource') {\n      if (inner.source?.type === 'Canvas') {\n        return inner.source as Reference<'Canvas'>;\n      }\n    }\n    if (inner.type === 'Range') {\n      const found = findFirstCanvasFromRange(vault, vault.get(inner));\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n\nexport function findFirstCanvasFromRangeWithSelector(\n  vault: CompatVault,\n  range: RangeNormalized\n): null | SpecificResource<Reference<'Canvas'>> {\n  for (const inner of range.items) {\n    if (typeof inner === 'string') {\n      return {\n        type: 'SpecificResource',\n        source: { id: inner, type: 'Canvas' } as Reference<'Canvas'>,\n      };\n    }\n    if ((inner as any).type === 'Canvas') {\n      return {\n        type: 'SpecificResource',\n        source: inner as any as Reference<'Canvas'>,\n      };\n    }\n    if (inner.type === 'SpecificResource') {\n      if (inner.source?.type === 'Canvas') {\n        return inner as SpecificResource<Reference<'Canvas'>>;\n      }\n    }\n    if (inner.type === 'Range') {\n      const found = findFirstCanvasFromRangeWithSelector(vault, vault.get(inner));\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n\nexport function findAllCanvasesInRange(vault: CompatVault, range: RangeNormalized): Array<Reference<'Canvas'>> {\n  const found: Reference<'Canvas'>[] = [];\n  for (const inner of range.items) {\n    if (inner.type === 'SpecificResource' && inner.source?.type === 'Canvas') {\n      if (inner.source.id.indexOf('#') !== -1) {\n        found.push({ id: inner.source.id.split('#')[0], type: 'Canvas' });\n      } else {\n        found.push(inner.source as Reference<'Canvas'>);\n      }\n    }\n    if (inner.type === 'Range') {\n      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));\n    }\n    if ((inner as any).type === 'SpecificResource') {\n      const sourceId = typeof (inner as any).source === 'string' ? (inner as any).source : (inner as any).source.id;\n      found.push({ id: sourceId, type: 'Canvas' });\n    }\n  }\n  return found;\n}\n\nexport function findManifestSelectedRange(\n  vault: CompatVault,\n  manifest: ManifestNormalized,\n  canvasId: string\n): null | RangeNormalized {\n  for (const range of manifest.structures) {\n    const found = findSelectedRange(vault, vault.get(range), canvasId);\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\nexport function findSelectedRange(\n  vault: CompatVault,\n  range: RangeNormalized,\n  canvasId: string\n): null | RangeNormalized {\n  for (const inner of range.items) {\n    const parsedId = (inner as any)?.source?.id?.split('#')[0];\n    if ((inner as any).type === 'SpecificResource' && (inner as any).source === canvasId) {\n      return range;\n    }\n    if (inner.type === 'SpecificResource' && inner.source?.type === 'Canvas' && canvasId === parsedId) {\n      return range;\n    }\n    if (inner.type === 'Range') {\n      const found = findSelectedRange(vault, vault.get(inner), canvasId);\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n\nexport interface RangeTableOfContentsNode {\n  id: string;\n  type: 'Canvas' | 'Range';\n  label: InternationalString | null;\n  resource?: SpecificResource;\n  untitled?: boolean;\n  isCanvasLeaf: boolean;\n  isRangeLeaf: boolean;\n  isVirtual?: boolean;\n  isNoNav?: boolean;\n  firstCanvas?: SpecificResource<Reference<'Canvas'>> | null;\n  items?: Array<RangeTableOfContentsNode>;\n}\n\nexport function rangesToTableOfContentsTree(\n  vault: CompatVault,\n  rangeRefs: RangeNormalized[] | Range[] | Reference<'Range'>[],\n  label?: InternationalString | null,\n  options: { showNoNav?: boolean } = {}\n): RangeTableOfContentsNode | null {\n  if (rangeRefs.length === 0) {\n    return null;\n  }\n\n  const ranges = vault.get(rangeRefs);\n\n  if (ranges.length === 1) {\n    return rangeToTableOfContentsTree(vault, ranges[0] as any, [], options);\n  }\n\n  const virtualRoot: Range = {\n    id: `vault://virtual-root/${hash(ranges)}`,\n    type: 'Range',\n    label: label || { en: ['Table of Contents'] },\n    items: ranges as any,\n  };\n\n  return rangeToTableOfContentsTree(vault, virtualRoot, [], options);\n}\n\nexport function rangeToTableOfContentsTree(\n  vault: CompatVault,\n  rangeRef: undefined | null | Range | RangeNormalized | Reference<'Range'>,\n  seenIds: string[] = [],\n  options: { showNoNav?: boolean } = {}\n): RangeTableOfContentsNode | null {\n  if (!rangeRef) return null;\n\n  const range = vault.get(rangeRef, { skipSelfReturn: false });\n  const toc: RangeTableOfContentsNode = {\n    id: range.id,\n    type: 'Range',\n    label: range.label,\n    untitled: !range.label,\n    isCanvasLeaf: false,\n    isRangeLeaf: false,\n    isVirtual: range.id.startsWith('vault://virtual-root/'),\n    items: [],\n  };\n\n  if (seenIds.indexOf(toc.id) !== -1) {\n    toc.id = `vault://${hash(range)}`;\n  }\n\n  if (range.behavior && range.behavior.includes('no-nav')) {\n    if (options.showNoNav) {\n      toc.isNoNav = true;\n    } else {\n      return null;\n    }\n  }\n\n  if (!range.items) {\n    return toc;\n  }\n\n  for (const inner of range.items) {\n    if (typeof inner === 'string') {\n      const maybeCanvas = vault.get({ id: inner, type: 'Canvas' }, { skipSelfReturn: false });\n      const foundCanvas: RangeTableOfContentsNode = {\n        id: inner,\n        type: 'Canvas',\n        isCanvasLeaf: true,\n        isRangeLeaf: false,\n        isNoNav: range.behavior && range.behavior.includes('no-nav'),\n        label: maybeCanvas.label || { none: ['Untitled'] },\n        untitled: !maybeCanvas.label,\n        resource: {\n          type: 'SpecificResource',\n          source: { id: inner, type: 'Canvas' },\n        },\n      };\n\n      if (seenIds.indexOf(foundCanvas.id) !== -1) {\n        foundCanvas.id = `vault://${hash(inner)}`;\n      }\n\n      seenIds.push(foundCanvas.id);\n\n      toc.items!.push(foundCanvas);\n      continue;\n    }\n    if (inner.type === 'SpecificResource' && inner.source?.type === 'Canvas') {\n      const maybeCanvas = vault.get(inner.source);\n      const compressed = compressSpecificResource(inner);\n\n      if (!maybeCanvas) {\n        continue;\n      }\n\n      const foundCanvas: RangeTableOfContentsNode = {\n        id: compressed.type === 'Canvas' ? compressed.id : inner.source.id,\n        type: 'Canvas',\n        isCanvasLeaf: true,\n        isRangeLeaf: false,\n        label: maybeCanvas.label || { none: ['Untitled'] },\n        untitled: !maybeCanvas.label,\n        resource: inner,\n      };\n      if (seenIds.indexOf(foundCanvas.id) !== -1) {\n        foundCanvas.id = `vault://${hash(inner)}`;\n      }\n\n      seenIds.push(foundCanvas.id);\n\n      toc.items!.push(foundCanvas);\n      continue;\n    }\n    if ((inner as any).type === 'Canvas') {\n      const foundCanvas: RangeTableOfContentsNode = {\n        id: (inner as any).id,\n        type: 'Canvas',\n        label: (inner as any).label,\n        isCanvasLeaf: true,\n        isRangeLeaf: false,\n        resource: {\n          type: 'SpecificResource',\n          source: inner as any,\n        },\n      };\n\n      if (seenIds.indexOf(foundCanvas.id) !== -1) {\n        foundCanvas.id = `vault://${hash(inner)}`;\n      }\n\n      seenIds.push(foundCanvas.id);\n\n      toc.items!.push(foundCanvas);\n      continue;\n    }\n    if ((inner as any).type === 'Range') {\n      const foundRange = rangeToTableOfContentsTree(vault, inner as any, seenIds, options);\n      if (foundRange) {\n        toc.items!.push(foundRange);\n      }\n    }\n  }\n\n  toc.firstCanvas = findFirstCanvasFromRangeWithSelector(vault, range);\n  toc.isRangeLeaf = toc.items ? toc.items.filter((i) => i.type === 'Range').length === 0 : true;\n\n  return toc;\n}\n\nfunction getCanvasesFromRange(\n  vault: CompatVault,\n  rangeRef: Range | RangeNormalized | Reference<'Range'>,\n  path: string[] = []\n): Array<{ canvas: Canvas; path: string[] }> {\n  const range = vault.get(rangeRef);\n  const canvases: Array<{ canvas: Canvas; path: string[] }> = [];\n  const currentPath = range.id ? [...path, range.id] : path;\n\n  if (!range.items) {\n    return canvases;\n  }\n\n  for (const item of range.items) {\n    if (typeof item === 'string') {\n      canvases.push({ canvas: { id: item, type: 'Canvas' }, path: currentPath });\n    } else if (item.type === 'SpecificResource') {\n      const canvas = item.source;\n      if (canvas?.type === 'Canvas') {\n        canvases.push({ canvas: canvas as Canvas, path: currentPath });\n      } else {\n        // Unknown resource type.\n      }\n    } else if (item.type === 'Range') {\n      canvases.push(...getCanvasesFromRange(vault, item as Range, currentPath));\n    }\n  }\n  return canvases;\n}\n\ntype IsRangeContiguousDetail = {\n  isContiguous: boolean;\n  startIndex: number;\n  endIndex: number;\n  gaps: Array<{\n    startIndex: number;\n    endIndex: number;\n    canvasIds: string[];\n  }>;\n  invalidRanges: Array<{ id: string; reasons: string[] }>;\n  invalidCanvases: string[];\n  reason: string | null;\n};\n\nexport function isRangeContiguous(\n  vault: CompatVault,\n  rangeRef: Range | RangeNormalized | Reference<'Range'>,\n  canvasesRef: Canvas[] | CanvasNormalized[] | Reference<'Canvas'>[],\n  options: Partial<{ allowGaps: boolean; allowSubset: boolean; detail?: boolean }> = {}\n): [boolean, IsRangeContiguousDetail | null] {\n  const canvases = canvasesRef.map((c) => vault.get(c, { skipSelfReturn: false }));\n  const range = vault.get(rangeRef);\n  const allCanvasIds = canvases.map((c) => c.id);\n  const rangeCanvases = getCanvasesFromRange(vault, range);\n  const details: IsRangeContiguousDetail = {\n    isContiguous: true,\n    startIndex: -1,\n    endIndex: -1,\n    gaps: [],\n    invalidRanges: [],\n    invalidCanvases: [],\n    reason: null,\n  };\n\n  if (rangeCanvases.length === 0) {\n    if (options.detail) {\n      return [true, details];\n    }\n    return [true, null];\n  }\n\n  const indices = rangeCanvases.map(({ canvas }) => allCanvasIds.indexOf(canvas.id));\n\n  let isContiguous = true;\n\n  let lastIndex = -1;\n  const rangeInvalidReasons = new Map<string, string[]>();\n\n  const markRangeInvalid = (id: string, reason: string) => {\n    if (!rangeInvalidReasons.has(id)) {\n      rangeInvalidReasons.set(id, []);\n    }\n    const currentInvalid = rangeInvalidReasons.get(id)!;\n    if (currentInvalid.includes(reason)) {\n      return;\n    }\n    currentInvalid.push(reason);\n  };\n\n  for (let i = 0; i < indices.length; i++) {\n    const currentIndex = indices[i];\n    const canvasInfo = rangeCanvases[i];\n    const parentRangeId = canvasInfo.path[canvasInfo.path.length - 1];\n\n    if (currentIndex === -1) {\n      isContiguous = false;\n      if (parentRangeId) {\n        markRangeInvalid(parentRangeId, 'Canvas not found');\n      }\n      details.invalidCanvases.push(canvasInfo.canvas.id);\n      continue;\n    }\n\n    if (i > 0 && lastIndex !== -1) {\n      if (currentIndex <= lastIndex) {\n        isContiguous = false;\n        if (parentRangeId) {\n          markRangeInvalid(parentRangeId, 'Canvas out of order');\n        }\n        // Don't update last index.\n      } else {\n        const diff = currentIndex - lastIndex;\n        if (diff > 1) {\n          if (!options.allowGaps) {\n            isContiguous = false;\n          }\n          if (options.detail) {\n            details.gaps.push({\n              startIndex: lastIndex,\n              endIndex: currentIndex,\n              canvasIds: allCanvasIds.slice(lastIndex + 1, currentIndex),\n            });\n          }\n        }\n        lastIndex = currentIndex;\n      }\n    } else {\n      lastIndex = currentIndex;\n    }\n  }\n\n  if (!options.allowSubset) {\n    if (rangeCanvases.length !== allCanvasIds.length) {\n      isContiguous = false;\n    } else {\n      const allFound = allCanvasIds.every((id) => rangeCanvases.some((rc) => rc.canvas.id === id));\n      if (!allFound) {\n        isContiguous = false;\n      }\n    }\n  }\n\n  if (!options.detail) {\n    return [isContiguous, null];\n  }\n\n  const invalidRangeIds = Array.from(rangeInvalidReasons.keys());\n  if (invalidRangeIds.length > 0) {\n    details.invalidRanges = invalidRangeIds.map((id) => ({\n      id,\n      reasons: rangeInvalidReasons.get(id) || [],\n    }));\n  }\n\n  const result: IsRangeContiguousDetail = { ...details, isContiguous };\n\n  const validIndices = indices.filter((i) => i !== -1);\n  if (validIndices.length > 0) {\n    result.startIndex = validIndices[0];\n    result.endIndex = validIndices[validIndices.length - 1];\n  }\n\n  return [isContiguous, result];\n}\n"],"mappings":"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"}