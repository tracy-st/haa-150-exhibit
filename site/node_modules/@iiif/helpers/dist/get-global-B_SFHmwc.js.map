{"version":3,"file":"get-global-B_SFHmwc.js","names":["prototype: WrappedObject<OG> & {\n    id: string;\n    type: string;\n    [REFS]: Record<string, any>;\n    [DEFINED]: any[];\n    [PARENT]: null | string;\n    [REACTIVE]: null | (() => void);\n  }","parent","mitt","state","_type: any","_type","fn: any","fn","initialState: PaginationState","newState: PaginationState","errState: PaginationState","resource","successState: PaginationState"],"sources":["../src/vault/utility/objects.ts","../src/vault/utility/resolve-type.ts","../src/vault/vault.ts","../src/vault/utility/get-global.ts"],"sourcesContent":["import { Vault } from '../vault';\n\nfunction defineProperty(name: string, prototype: any, vault: Vault, enumerable = true) {\n  prototype[DEFINED] = prototype[DEFINED] || [];\n  prototype[DEFINED].push(name);\n\n  const cache = new Map();\n\n  Object.defineProperty(prototype, name, {\n    enumerable,\n    get(): any {\n      if (typeof prototype[REFS][name] === 'undefined') {\n        return undefined;\n      }\n\n      const ref = prototype[REFS][name];\n      if (!ref) {\n        return ref;\n      }\n      const object = vault.get(prototype[REFS][name], {\n        parent: this.id ? { id: this.id, type: this.type } : undefined,\n      });\n      if (!cache.has(object)) {\n        cache.clear();\n        cache.set(object, wrapObject(object, vault));\n      }\n      return cache.get(object);\n    },\n    set(items: any) {\n      const existing = prototype[REFS][name];\n      if (existing !== items) {\n        // This was a hack, but a much more clever implementation here could make very flexible editing.\n        // For example - manifest.label = \"Something\" -> manifest.label = {none: \"something\"}; etc.\n        // Although this might be better in a different library completely.\n        if (this[REACTIVE]) {\n          // Note: this should NOT be used for setting nested items. Only values.\n          vault.modifyEntityField({ id: this.id, type: this.type }, name, unwrapObject(items));\n        } else {\n          this[REFS][name] = items;\n        }\n      }\n    },\n  });\n}\n\nexport const REFS = Symbol.for('_refs_');\nexport const REACTIVE = Symbol.for('_reactive_');\nexport const DEFINED = Symbol.for('_defined_');\nexport const PARENT = Symbol.for('_parent_');\n\nexport type WrappedObject<OG = any> = {\n  subscribe(subscription: (object: any, vault: Vault) => void, skipInitial?: boolean): () => void;\n  reactive(): void;\n  unreactive(): void;\n  refresh(): void;\n  unwrap(): OG;\n  valueOf(): OG;\n  toPresentation3(): any;\n  toPresentation2(): any;\n  is(refOrObject: any): boolean;\n  toJSON(): any;\n};\n\nexport type ReactiveWrapped<Full = any, T = any> = {} & WrappedObject<Full> &\n  Omit<\n    Full,\n    | 'items'\n    | 'annotations'\n    | 'structures'\n    | 'seeAlso'\n    | 'rendering'\n    | 'partOf'\n    | 'start'\n    | 'supplementary'\n    | 'homepage'\n    | 'thumbnail'\n    | 'placeholderCanvas'\n    | 'accompanyingCanvas'\n    | 'provider'\n    | 'body'\n    | 'logo'\n  > & {\n    items: Full extends { items: (infer A)[] }\n      ? (Full['items'][number] & ReactiveWrapped<any, Full['items'][number]>)[]\n      : never;\n    annotations: Full extends { annotations: (infer A)[] }\n      ? ReactiveWrapped<any, Full['annotations'][number]>[]\n      : never;\n    structures: Full extends { structures: (infer A)[] } ? ReactiveWrapped<any, Full['structures'][number]>[] : never;\n    seeAlso: Full extends { seeAlso: (infer A)[] } ? ReactiveWrapped<any, Full['seeAlso'][number]>[] : never;\n    rendering: Full extends { rendering: (infer A)[] } ? ReactiveWrapped<any, Full['rendering'][number]>[] : never;\n    partOf: Full extends { partOf: (infer A)[] } ? ReactiveWrapped<any, Full['partOf'][number]>[] : never;\n    start: Full extends { start: (infer A)[] } ? ReactiveWrapped<any, Full['start'][number]>[] : never;\n    supplementary: Full extends { supplementary: (infer A)[] }\n      ? ReactiveWrapped<any, Full['supplementary'][number]>[]\n      : never;\n    homepage: Full extends { homepage: (infer A)[] } ? ReactiveWrapped<any, Full['homepage'][number]>[] : never;\n    thumbnail: Full extends { thumbnail: (infer A)[] } ? ReactiveWrapped<any, Full['thumbnail'][number]>[] : never;\n    placeholderCanvas: Full extends { placeholderCanvas: (infer A)[] }\n      ? ReactiveWrapped<any, Full['placeholderCanvas'][number]>[]\n      : never;\n    accompanyingCanvas: Full extends { accompanyingCanvas: (infer A)[] }\n      ? ReactiveWrapped<any, Full['accompanyingCanvas'][number]>[]\n      : never;\n    provider: Full extends { provider: (infer A)[] } ? ReactiveWrapped<any, Full['provider'][number]>[] : never;\n    body: Full extends { body: (infer A)[] } ? ReactiveWrapped<any, Full['body'][number]>[] : never;\n    logo: Full extends { logo: (infer A)[] } ? ReactiveWrapped<any, Full['logo'][number]>[] : never;\n  };\n\nfunction createPrototype<T, OG>(vault: Vault, reactive = false, parent?: string): ReactiveWrapped<T, OG> {\n  const prototype: WrappedObject<OG> & {\n    id: string;\n    type: string;\n    [REFS]: Record<string, any>;\n    [DEFINED]: any[];\n    [PARENT]: null | string;\n    [REACTIVE]: null | (() => void);\n  } = {\n    id: '',\n    type: 'unknown',\n    [DEFINED]: [],\n    [REFS]: {},\n    [PARENT]: parent || null,\n    [REACTIVE]: null,\n\n    is(refOrObject: any) {\n      if (typeof refOrObject === 'string') {\n        return this.id === refOrObject;\n      }\n\n      if (refOrObject.id) {\n        return refOrObject.id === this.id;\n      }\n\n      return false;\n    },\n\n    reactive() {\n      if (this[REACTIVE]) {\n        return;\n      }\n\n      this[REACTIVE] = this.subscribe(() => this.refresh(), true);\n\n      return () => {\n        this.unreactive();\n      };\n    },\n\n    refresh() {\n      if (this.id) {\n        const fresh = this.unwrap();\n        for (const key of Object.keys(fresh || {})) {\n          if (this[DEFINED].includes(key)) {\n            (this as any)[REFS][key] = (fresh as any)[key as any];\n          } else {\n            (this as any)[key] = (fresh as any)[key as any];\n          }\n        }\n      }\n    },\n\n    unreactive() {\n      if (this[REACTIVE]) {\n        this[REACTIVE]();\n        this[REACTIVE] = null;\n      }\n    },\n\n    unwrap() {\n      if (!this.id) {\n        throw new Error('Invalid object');\n      }\n      const parent = this[PARENT];\n      return vault.get(this.id, { parent: parent ? { id: parent, type: 'unknown' } : undefined });\n    },\n\n    toPresentation3() {\n      return vault.toPresentation3(this.unwrap() as any);\n    },\n\n    toPresentation2() {\n      return vault.toPresentation2(this.unwrap() as any);\n    },\n\n    valueOf() {\n      return this.unwrap() as any;\n    },\n\n    toJSON() {\n      const that = this as any;\n      return {\n        ...that,\n        items: that.items,\n        annotations: that.annotations,\n        structures: that.structures,\n        seeAlso: that.seeAlso,\n        service: that.service,\n        services: that.services,\n        rendering: that.rendering,\n        partOf: that.partOf,\n        start: that.start,\n        supplementary: that.supplementary,\n        homepage: that.homepage,\n        thumbnail: that.thumbnail,\n        placeholderCanvas: that.placeholderCanvas,\n        accompanyingCanvas: that.accompanyingCanvas,\n        provider: that.provider,\n      };\n    },\n    subscribe(subscription: (object: any, vault: Vault) => void, skipInitial = true) {\n      return vault.subscribe(\n        () => {\n          return this.id ? vault.get(this.id) : null;\n        },\n        subscription,\n        skipInitial\n      );\n    },\n  };\n\n  // Structural\n  defineProperty('items', prototype, vault);\n  defineProperty('annotations', prototype, vault);\n  defineProperty('structures', prototype, vault);\n\n  // Linking\n  defineProperty('seeAlso', prototype, vault);\n  // defineProperty('service', prototype, vault);\n  // defineProperty('services', prototype, vault);\n  defineProperty('rendering', prototype, vault);\n  defineProperty('partOf', prototype, vault);\n  defineProperty('start', prototype, vault, false);\n  defineProperty('supplementary', prototype, vault);\n  defineProperty('homepage', prototype, vault);\n\n  // Descriptive\n  defineProperty('thumbnail', prototype, vault);\n  defineProperty('placeholderCanvas', prototype, vault, false);\n  defineProperty('accompanyingCanvas', prototype, vault, false);\n  defineProperty('provider', prototype, vault);\n\n  // Annotation\n  defineProperty('body', prototype, vault);\n  defineProperty('logo', prototype, vault);\n\n  return prototype as any;\n}\n\nexport function isWrapped(object: any): object is WrappedObject {\n  return !!object[DEFINED];\n}\n\nexport function unwrapObject(object: any): any {\n  if (Array.isArray(object)) {\n    return object.map((o) => unwrapObject(o)) as any;\n  }\n\n  if (!object || !object.type) {\n    return object;\n  }\n\n  return { id: object.id, type: object.type };\n}\n\nexport function wrapObject<Type, NormalizedType = any>(\n  object: any,\n  vault: Vault,\n  reactive = false,\n  parent?: string\n): ReactiveWrapped<Type, NormalizedType> {\n  if (Array.isArray(object)) {\n    return object.map((o) => wrapObject(o, vault, reactive)) as any;\n  }\n  if (!object || !object.type || !object.id) {\n    return object;\n  }\n\n  const prototype = createPrototype(vault, reactive);\n  const newObject = Object.create(prototype);\n\n  const wrapped = Object.assign(newObject, object) as any;\n\n  if (reactive) {\n    wrapped.reactive();\n  }\n\n  return wrapped;\n}\n","import { Entities } from '../types';\n\nexport function resolveType(type: string): keyof Entities {\n  switch (type) {\n    case 'Image':\n    case 'Video':\n    case 'Sound':\n    case 'Dataset':\n    case 'Text':\n    case 'Composite':\n    case 'List':\n    case 'Independents':\n    case 'Audience':\n      return 'ContentResource';\n    case 'ImageService1':\n    case 'ImageService2':\n    case 'ImageService3':\n      return 'Service';\n  }\n\n  return type as any;\n}\n","/// <reference types=\"geojson\" />\n\nimport {\n  ActionFromType,\n  AllActions,\n  Entities,\n  IIIFStore,\n  NormalizedEntity,\n  PaginationState,\n  RefToNormalized,\n  RequestState,\n} from './types';\nimport { Collection, Manifest, Reference, SpecificResource } from '@iiif/presentation-3';\nimport {\n  frameResource,\n  HAS_PART,\n  isSpecificResource,\n  PART_OF,\n  serialize,\n  SerializeConfig,\n  serializeConfigPresentation2,\n  serializeConfigPresentation3,\n} from '@iiif/parser';\nimport { BATCH_ACTIONS, BatchAction, batchActions, entityActions, metaActions } from './actions';\nimport { createFetchHelper, areInputsEqual } from './utility';\nimport { createStore, VaultZustandStore } from './store';\nimport mitt, { Emitter } from 'mitt';\nimport { CollectionNormalized, ManifestNormalized } from '@iiif/presentation-3-normalized';\nimport { isWrapped, ReactiveWrapped, wrapObject } from './utility/objects';\nimport { resolveType } from './utility/resolve-type';\n\nexport type VaultOptions = {\n  reducers: Record<string, any>;\n  defaultState?: IIIFStore;\n  customFetcher: <T>(url: string, options: T) => unknown | Promise<unknown>;\n  enableDevtools: boolean;\n};\n\nexport type GetOptions = {\n  skipSelfReturn?: boolean;\n  parent?: Reference<any> | string;\n  preserveSpecificResources?: boolean;\n  skipPartOfCheck?: boolean;\n};\nexport type GetObjectOptions = GetOptions & { reactive?: boolean };\n\ntype AllActionsType = AllActions['type'];\n\nexport type EntityRef<Ref extends keyof Entities> = IIIFStore['iiif']['entities'][Ref][string];\n\nexport class Vault {\n  private readonly options: VaultOptions;\n  private readonly store: VaultZustandStore;\n  private readonly emitter: Emitter<any>;\n  private isBatching = false;\n  private batchQueue: AllActions[] = [];\n  remoteFetcher: (str: string, options?: any, mapper?: (resource: any) => any) => Promise<NormalizedEntity | undefined>;\n  staticFetcher: (str: string, json: any, mapper?: (resource: any) => any) => Promise<NormalizedEntity | undefined> | NormalizedEntity | undefined;\n\n  constructor(options?: Partial<VaultOptions>, store?: VaultZustandStore) {\n    this.options = Object.assign(\n      {\n        reducers: {},\n        customFetcher: this.defaultFetcher,\n        enableDevtools: true,\n      },\n      options || {}\n    );\n    this.store =\n      store ||\n      createStore({\n        customReducers: this.options.reducers,\n        defaultState: this.options.defaultState,\n        enableDevtools: this.options.enableDevtools,\n      });\n    this.emitter = mitt();\n    this.remoteFetcher = createFetchHelper(this, this.options.customFetcher) as any;\n    this.staticFetcher = createFetchHelper(this, (id: string, json: any) => json);\n  }\n\n  defaultFetcher = (url: string) => {\n    return fetch(url).then((r) => {\n      if (r.status === 200) {\n        return r.json();\n      } else {\n        const err = new Error(`${r.status} ${r.statusText}`);\n        err.name = `HTTPError`;\n        throw err;\n      }\n    });\n  };\n\n  batch(cb: (vault: this) => void) {\n    this.isBatching = true;\n    try {\n      cb(this);\n      this.isBatching = false;\n      this.dispatch(batchActions({ actions: this.batchQueue }));\n    } catch (e) {\n      // Even if we error, we still need to reset the queue.\n      this.batchQueue = [];\n      this.isBatching = false;\n      // And then rethrow.\n      throw e;\n    }\n    this.batchQueue = [];\n  }\n\n  async asyncBatch(cb: (vault: this) => Promise<void> | void) {\n    this.isBatching = true;\n    try {\n      await cb(this);\n      this.isBatching = false;\n      this.dispatch(batchActions({ actions: this.batchQueue }));\n    } catch (e) {\n      // Even if we error, we still need to reset the queue.\n      this.batchQueue = [];\n      this.isBatching = false;\n      // And then rethrow.\n      throw e;\n    }\n    this.batchQueue = [];\n  }\n\n  modifyEntityField(entity: Reference<keyof Entities>, key: string, value: any) {\n    this.dispatch(\n      entityActions.modifyEntityField({\n        id: entity.id,\n        type: entity.type,\n        key,\n        value,\n      })\n    );\n  }\n\n  dispatch(action: AllActions | BatchAction) {\n    if (!this.isBatching) {\n      if (action.type === BATCH_ACTIONS) {\n        for (const realAction of action.payload.actions) {\n          this.emitter.emit(realAction.type, { action: realAction, state: this.store.getState() });\n        }\n        this.store.dispatch(action);\n        const state = this.getState();\n        for (const realAction of action.payload.actions) {\n          this.emitter.emit(`after:${realAction.type}`, { action: realAction, state });\n        }\n        return;\n      }\n\n      this.emitter.emit(action.type, { action, state: this.store.getState() });\n      this.store.dispatch(action);\n      const state = this.store.getState();\n      this.emitter.emit(`after:${action.type}`, { action, state });\n      return;\n    } else {\n      this.batchQueue.push(action as AllActions);\n    }\n  }\n\n  on<Type extends AllActions['type']>(\n    event: Type | `after:${Type}`,\n    handler: (ctx: { action: ActionFromType<Type>; state: IIIFStore }) => void\n  ) {\n    this.emitter.on(event, handler);\n    return () => {\n      this.emitter.off(event, handler);\n    };\n  }\n\n  serialize<Return>(entity: Reference<keyof Entities>, config: SerializeConfig) {\n    return serialize<Return>(this.getState().iiif, entity, config);\n  }\n\n  toPresentation2<Return>(entity: Reference<keyof Entities>) {\n    return this.serialize<Return>(entity, serializeConfigPresentation2);\n  }\n\n  toPresentation3<Return>(entity: Reference<keyof Entities>) {\n    return this.serialize<Return>(entity, serializeConfigPresentation3);\n  }\n\n  hydrate<R extends { type?: string }>(\n    reference: string | Partial<R>,\n    type?: string | GetOptions,\n    options?: GetOptions\n  ): RefToNormalized<R>;\n  hydrate<R extends { type?: string }>(\n    reference: string[] | Partial<R>[],\n    type?: string | GetOptions,\n    options?: GetOptions\n  ): RefToNormalized<R>[];\n  hydrate<R extends { type?: string }>(\n    reference: string | R | NormalizedEntity | string[] | R[] | NormalizedEntity[],\n    type?: string | GetOptions,\n    options: GetOptions = {}\n  ): RefToNormalized<R> | RefToNormalized<R>[] {\n    return this.get<R>(reference as any, type as any, { ...options, skipSelfReturn: false });\n  }\n\n  get<R extends { type?: string }>(\n    reference: string | Partial<R> | Reference<R['type']> | SpecificResource<R>,\n    type?: string | GetOptions,\n    options?: GetOptions\n  ): RefToNormalized<R>;\n  get<R extends { type?: string }>(\n    reference: string[] | Partial<R>[] | Reference<R['type']>[] | SpecificResource<R>[],\n    type?: string | GetOptions,\n    options?: GetOptions\n  ): RefToNormalized<R>[];\n  get<R extends { type?: string }>(\n    reference:\n      | string\n      | R\n      | NormalizedEntity\n      | string[]\n      | R[]\n      | NormalizedEntity[]\n      | SpecificResource<R>\n      | SpecificResource<R>[],\n    type?: string | GetOptions,\n    options: GetOptions = {}\n  ): RefToNormalized<R> | RefToNormalized<R>[] {\n    if (typeof type !== 'string') {\n      options = type || {};\n      type = undefined;\n    }\n\n    const { skipSelfReturn = true } = options || {};\n    let parent = options.parent ? (typeof options.parent === 'string' ? options.parent : options.parent.id) : undefined;\n\n    // Multiples.\n    if (Array.isArray(reference)) {\n      return (reference as any[]).map((i) => this.get(i, options)) as EntityRef<any>[];\n    }\n\n    const state = this.getState();\n\n    if (isSpecificResource(reference) && !options.preserveSpecificResources) {\n      reference = reference.source;\n    }\n\n    // String IDs.\n    if (typeof reference === 'string') {\n      const _type: any = resolveType(type ? type : state.iiif.mapping[reference]);\n      if (!_type) {\n        if (skipSelfReturn) {\n          return null as any;\n        }\n        return { id: reference, type: 'unknown' } as any;\n      }\n      reference = { id: reference, type: _type };\n    }\n\n    if (reference && (reference as any).partOf && !parent && !options.skipPartOfCheck) {\n      const first = Array.isArray((reference as any).partOf) ? (reference as any).partOf[0] : (reference as any).partOf;\n      if (first) {\n        if (typeof first === 'string') {\n          parent = first;\n        }\n        if (typeof first.id === 'string') {\n          parent = first.id;\n        }\n      }\n    }\n\n    const _type = resolveType(type ? type : (reference as any)?.type);\n    const _id = (reference as any)?.id;\n    const entities = (state.iiif.entities as any)[_type];\n    if (!entities) {\n      const request = state.iiif.requests[_id];\n      if (request && request.resourceUri !== _id) {\n        return this.get(request.resourceUri, options);\n      }\n\n      if (skipSelfReturn) {\n        return null as any;\n      }\n      return reference as any;\n    }\n\n    const found = entities[(reference as any).id];\n    if (found && found[HAS_PART]) {\n      const framing = found[HAS_PART].find((t: any) => {\n        return parent ? t[PART_OF] === parent : t[PART_OF] === found.id;\n      });\n      return frameResource(found, framing);\n    }\n\n    return entities[(reference as any).id] || (skipSelfReturn ? null : reference);\n  }\n\n  select<R>(selector: (state: IIIFStore) => R): R {\n    return selector(this.getState());\n  }\n\n  getStore(): VaultZustandStore {\n    return this.store;\n  }\n\n  getState(): IIIFStore {\n    return this.store.getState();\n  }\n\n  deep(input?: any, prev?: any) {\n    if (typeof input === 'undefined') {\n      return this.get(prev, { skipSelfReturn: false });\n    }\n    if (typeof input === 'function') {\n      try {\n        const next = input(this.get(prev, { skipSelfReturn: false }));\n        const fn: any = (newInput: any) => this.deep(newInput, next);\n        fn.size = Array.isArray(next) ? next.length : 1;\n        return fn;\n      } catch (e) {\n        const fn: any = (newInput: any) => this.deep(newInput, undefined);\n        fn.size = 0;\n        return fn;\n      }\n    }\n    const fn: any = (newInput: any) => this.deep(newInput, input);\n    fn.size = Array.isArray(input) ? input.length : 1;\n    return fn;\n  }\n\n  loadManifest(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<ManifestNormalized | undefined> {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.load<ManifestNormalized>(_id, json, mapper);\n  }\n\n  loadCollection(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<CollectionNormalized | undefined> {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.load<CollectionNormalized>(_id, json, mapper);\n  }\n\n  load<T>(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<T | undefined> {\n    const _id = typeof id === 'string' ? id : id.id;\n    if (json) {\n      return Promise.resolve(this.staticFetcher(_id, json, mapper)) as Promise<T | undefined>;\n    }\n    return Promise.resolve(this.remoteFetcher(_id, {}, mapper)) as Promise<T | undefined>;\n  }\n\n  loadSync<T>(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): T | undefined {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.staticFetcher(_id, json, mapper) as T | undefined;\n  }\n\n  loadManifestSync(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): ManifestNormalized | undefined {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.loadSync<ManifestNormalized>(_id, json, mapper);\n  }\n\n  loadCollectionSync(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): CollectionNormalized | undefined {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.loadSync<CollectionNormalized>(_id, json, mapper);\n  }\n\n  areInputsEqual(newInputs: readonly unknown[] | unknown, lastInputs: readonly unknown[] | unknown) {\n    return areInputsEqual(newInputs, lastInputs);\n  }\n\n  subscribe<T>(\n    selector: (state: IIIFStore) => T,\n    subscription: (state: T, vault: Vault) => void,\n    skipInitial: boolean\n  ): () => void;\n  subscribe<T>(subscription: (state: T, vault: Vault) => void, skipInitial?: boolean): () => void;\n  subscribe<T>(\n    selector: ((state: IIIFStore) => T) | ((state: T, vault: Vault) => void),\n    subscription?: ((state: T, vault: Vault) => void) | boolean,\n    skipInitial?: boolean\n  ): () => void {\n    if (\n      typeof skipInitial === 'undefined' &&\n      (typeof subscription === 'undefined' || subscription === false || subscription === true)\n    ) {\n      skipInitial = subscription;\n      subscription = selector as any;\n      selector = (a: any) => a;\n    }\n\n    return this.store.subscribe(selector as any, (s: any) => (subscription as any)(s, this), {\n      equalityFn: areInputsEqual,\n      fireImmediately: !skipInitial,\n    });\n  }\n\n  async ensureLoaded(_id: string | Reference<any>): Promise<void> {\n    const id = typeof _id === 'string' ? _id : _id.id;\n    if (!this.requestStatus(id)) {\n      await this.load(id);\n    }\n  }\n\n  requestStatus(id: string): RequestState[any] | undefined {\n    return this.select<RequestState[any]>((state) => {\n      return state.iiif.requests[id];\n    });\n  }\n\n\n  // Pagination built on \"meta\".\n  getPaginationState<T = any>(resource: string | Reference): PaginationState | null {\n    // This will return the pagination state of a resource from it's meta.\n    // If there is no pagination state, it will create it if needed.\n    const id = typeof resource === 'string' ? resource : resource.id;\n    if (!id) return null;\n\n    const existing = this.getResourceMeta(id, '@vault/pagination');\n    if (existing?.state) {\n      return existing.state;\n    }\n\n    const fullResource = this.get(resource);\n    if (fullResource.first) {\n      const initialState: PaginationState = {\n        currentPage: null,\n        currentPageIndex: null,\n        isFetching: false,\n        isFullyLoaded: false,\n        next: fullResource.first,\n        page: 1,\n        pages: [],\n        previous: null,\n        totalItems: fullResource.total,\n        currentLength: 0,\n      };\n\n      this.setMetaValue([id, '@vault/pagination', 'state'], initialState)\n\n      return initialState;\n    }\n\n    // @todo generate from resource.\n\n    return null;\n  }\n\n  async loadNextPage(resource: string | Reference, json?: any): Promise<[PaginationState | null, CollectionNormalized | null]> {\n    const id = typeof resource === 'string' ? resource : resource.id;\n    if (!id) return [null, null];\n\n    // This will get the pagination state and fetch the next page and load it into the vault.\n    const state = this.getPaginationState(resource);\n    if (!state || state.isFullyLoaded || !state.next) {\n      return [null, null];\n    }\n\n    if (state.isFetching) {\n      return [state, null];\n    }\n\n    const nextPage = typeof state.next === 'string' ? state.next : (state.next as any).id;\n    const previousPage = state.currentPage;\n\n    // 1. Update the meta state.\n    const newState: PaginationState = {\n      ...state,\n      isFetching: true,\n    };\n    this.setMetaValue([id, '@vault/pagination', 'state'], newState);\n\n    // 2. Make the fetch request.\n    let collectionPage;\n    try {\n      collectionPage = await this.loadCollection(nextPage, json, mapped => {\n        // This is required because the page MIGHT have the same id.\n        const { id, ['@id']: _id, ...properties } = mapped || {};\n\n        if (_id) {\n          return { ['@id']: nextPage, ...properties };\n        }\n\n        return { id: nextPage, ...properties };\n      })\n    } catch (err) {\n      const errState: PaginationState = {\n        ...state,\n        isFetching: false,\n        error: err,\n      };\n      this.setMetaValue([id, '@vault/pagination', 'state'], errState);\n      return [errState, null];\n    }\n\n    if (!collectionPage) {\n      const errState: PaginationState = {\n        ...state,\n        isFetching: false,\n        error: new Error(\"Collection not found\"),\n      };\n      this.setMetaValue([id, '@vault/pagination', 'state'], errState);\n      return [errState, null];\n    }\n\n    const fullCollection = this.get(id);\n    const combinedItems = [\n        ...(fullCollection.items || []),\n        ...(collectionPage.items || []),\n      ].map(resource => ({\n        id: resource.id, type: resource.type\n      }));\n\n    this.modifyEntityField({ id, type: \"Collection\" }, \"items\", combinedItems);\n    const latestState = this.getPaginationState(resource);\n    if (!latestState) throw new Error(\"Pagination state not found\");\n    const successState: PaginationState = {\n      ...latestState,\n      isFetching: false,\n      error: null,\n      currentPage: collectionPage.id,\n      next: (collectionPage as any).next?.id || null,\n      currentPageIndex: latestState.pages.length,\n      currentLength: combinedItems.length,\n      pages: [\n        ...latestState.pages,\n        {\n          id: collectionPage.id,\n          type: \"Collection\",\n          startIndex: fullCollection.items.length,\n          pageLength: collectionPage.items.length,\n          order: typeof latestState.currentPageIndex === 'number' ? latestState.currentPageIndex + 1 : 0,\n        }\n      ],\n      isFullyLoaded: !(collectionPage as any).next,\n      previous: previousPage,\n      page: latestState.pages.length + 1,\n    };\n\n    this.setMetaValue([id, '@vault/pagination', 'state'], successState);\n\n    return [successState, collectionPage];\n  }\n\n\n  getResourceMeta<T = any>(resource: string): Partial<T> | undefined;\n  getResourceMeta<T = any, Key extends keyof T = keyof T>(resource: string, metaKey: Key): T[Key] | undefined;\n  getResourceMeta<T = any, Key extends keyof T = keyof T>(\n    resource: string,\n    metaKey?: Key\n  ): Partial<T> | T[Key] | undefined {\n    const resourceMeta = this.getState().iiif.meta[resource as any] as any;\n\n    if (!resourceMeta) {\n      return undefined;\n    }\n    if (!metaKey) {\n      return resourceMeta as Partial<T>;\n    }\n\n    return resourceMeta[metaKey] as T[Key];\n  }\n\n  getObject<R extends { type?: string }>(\n    reference: string | Partial<R>,\n    type?: string | GetObjectOptions,\n    options?: GetObjectOptions\n  ): RefToNormalized<R>;\n  getObject<R extends { type?: string }>(\n    reference: string | R | NormalizedEntity,\n    type?: string | GetObjectOptions,\n    options: GetObjectOptions = {}\n  ): RefToNormalized<R> {\n    const { reactive, ...otherOptions } = options;\n    return wrapObject(this.get(reference as any, type, otherOptions), this, reactive) as any;\n  }\n\n  async loadObject<Type, NormalizedType = any>(\n    id: string | Reference<any>,\n    json?: any\n  ): Promise<ReactiveWrapped<Type, NormalizedType>> {\n    return wrapObject<Type, NormalizedType>(await this.load(id, json), this);\n  }\n  async loadManifestObject(\n    id: string | Reference<any>,\n    json?: any\n  ): Promise<ReactiveWrapped<Manifest, ManifestNormalized>> {\n    return wrapObject<Manifest, ManifestNormalized>(await this.loadManifest(id, json), this);\n  }\n  async loadCollectionObject(\n    id: string | Reference<any>,\n    json?: any\n  ): Promise<ReactiveWrapped<Collection, CollectionNormalized>> {\n    return wrapObject<Collection, CollectionNormalized>(await this.loadCollection(id, json), this);\n  }\n  wrapObject<T extends string>(objectType: Reference<T>) {\n    return wrapObject(this.get(objectType, { skipSelfReturn: false }), this);\n  }\n  isWrapped(object: any) {\n    return isWrapped(object);\n  }\n  setMetaValue<Value = any>(\n    [id, meta, key]: [string, string, string],\n    newValueOrUpdate: Value | ((oldValue: Value | undefined) => Value)\n  ) {\n    this.dispatch(\n      typeof newValueOrUpdate === 'function'\n        ? metaActions.setMetaValueDynamic({\n            id,\n            meta: meta as any,\n            key,\n            updateValue: newValueOrUpdate as any,\n          })\n        : metaActions.setMetaValue({\n            id,\n            meta: meta as any,\n            key,\n            value: newValueOrUpdate,\n          })\n    );\n  }\n}\n","export function getGlobal(): any {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n"],"mappings":"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"}