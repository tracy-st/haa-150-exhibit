{"version":3,"file":"vault-node.js","names":[],"sources":["../src/vault-node.ts"],"sourcesContent":["import * as Lib from './vault/vault';\nimport { Entities } from './vault/types';\nimport { getGlobal } from './vault/utility/get-global';\nimport { VaultZustandStore } from './vault/store/index';\n\nexport type VaultOptions = Lib.VaultOptions;\nexport type EntityRef<Ref extends keyof Entities> = Lib.EntityRef<Ref>;\n\nconst _importDynamic = new Function('modulePath', 'return import(modulePath)');\nasync function fetchInternal(...args: any[]) {\n  if (typeof fetch !== 'undefined') {\n    return (fetch as any)(...args);\n  }\n  const { default: fetch_ } = await _importDynamic('node-fetch');\n  return fetch_(...args);\n}\n\nexport class Vault extends Lib.Vault {\n  constructor(options?: Partial<VaultOptions>, store?: VaultZustandStore) {\n    const _options = options || {};\n    _options.customFetcher = async (url: string) => {\n      return fetchInternal(url).then((r) => r.json());\n    };\n    super(_options, store);\n  }\n}\n\nexport function globalVault(options?: VaultOptions) {\n  const g = getGlobal();\n  try {\n    const gv = g['IIIF_VAULT'];\n\n    if (gv) {\n      return gv;\n    }\n  } catch (e) {\n    // no-op\n  }\n\n  const newVault = new Vault(options);\n\n  try {\n    g['IIIF_VAULT'] = newVault;\n  } catch (e) {\n    // no-op\n  }\n\n  return newVault;\n}\n\nexport * from './vault/types';\n"],"mappings":"sVAQA,MAAM,EAAqB,SAAS,aAAc,6BAClD,eAAe,EAAc,GAAG,EAAa,CAC3C,GAAI,OAAO,MAAU,IACnB,OAAQ,MAAc,GAAG,GAE3B,GAAM,CAAE,QAAS,GAAW,MAAM,EAAe,cACjD,OAAO,EAAO,GAAG,GAGnB,IAAa,EAAb,cAAA,CAAqC,CACnC,YAAY,EAAiC,EAA2B,CACtE,IAAM,EAAW,GAAW,GAC5B,EAAS,cAAgB,KAAO,IACvB,EAAc,GAAK,KAAM,GAAM,EAAE,QAE1C,MAAM,EAAU,KAIpB,SAAgB,EAAY,EAAwB,CAClD,IAAM,EAAI,IACV,GAAI,CACF,IAAM,EAAK,EAAE,WAEb,GAAI,EACF,OAAO,OAEC,EAIZ,IAAM,EAAW,IAAI,EAAM,GAE3B,GAAI,CACF,EAAE,WAAgB,OACR,EAIZ,OAAO"}