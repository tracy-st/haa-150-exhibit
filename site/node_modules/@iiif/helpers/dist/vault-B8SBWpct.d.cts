import { ActionFromType, AllActions, BatchAction, Entities, IIIFStore, NormalizedEntity, PaginationState, RefToNormalized, RequestState } from "./batch-actions-D7V5t4hj.cjs";
import { VaultZustandStore } from "./index-CFeXWhmD.cjs";
import { Collection, Manifest, Reference, SpecificResource } from "@iiif/presentation-3";
import { CollectionNormalized, ManifestNormalized } from "@iiif/presentation-3-normalized";
import { SerializeConfig } from "@iiif/parser";

//#region rolldown:runtime
//#endregion
//#region src/vault/utility/objects.d.ts
type WrappedObject<OG = any> = {
  subscribe(subscription: (object: any, vault: Vault) => void, skipInitial?: boolean): () => void;
  reactive(): void;
  unreactive(): void;
  refresh(): void;
  unwrap(): OG;
  valueOf(): OG;
  toPresentation3(): any;
  toPresentation2(): any;
  is(refOrObject: any): boolean;
  toJSON(): any;
};
type ReactiveWrapped<Full = any, T = any> = {} & WrappedObject<Full> & Omit<Full, 'items' | 'annotations' | 'structures' | 'seeAlso' | 'rendering' | 'partOf' | 'start' | 'supplementary' | 'homepage' | 'thumbnail' | 'placeholderCanvas' | 'accompanyingCanvas' | 'provider' | 'body' | 'logo'> & {
  items: Full extends {
    items: (infer A)[];
  } ? (Full['items'][number] & ReactiveWrapped<any, Full['items'][number]>)[] : never;
  annotations: Full extends {
    annotations: (infer A)[];
  } ? ReactiveWrapped<any, Full['annotations'][number]>[] : never;
  structures: Full extends {
    structures: (infer A)[];
  } ? ReactiveWrapped<any, Full['structures'][number]>[] : never;
  seeAlso: Full extends {
    seeAlso: (infer A)[];
  } ? ReactiveWrapped<any, Full['seeAlso'][number]>[] : never;
  rendering: Full extends {
    rendering: (infer A)[];
  } ? ReactiveWrapped<any, Full['rendering'][number]>[] : never;
  partOf: Full extends {
    partOf: (infer A)[];
  } ? ReactiveWrapped<any, Full['partOf'][number]>[] : never;
  start: Full extends {
    start: (infer A)[];
  } ? ReactiveWrapped<any, Full['start'][number]>[] : never;
  supplementary: Full extends {
    supplementary: (infer A)[];
  } ? ReactiveWrapped<any, Full['supplementary'][number]>[] : never;
  homepage: Full extends {
    homepage: (infer A)[];
  } ? ReactiveWrapped<any, Full['homepage'][number]>[] : never;
  thumbnail: Full extends {
    thumbnail: (infer A)[];
  } ? ReactiveWrapped<any, Full['thumbnail'][number]>[] : never;
  placeholderCanvas: Full extends {
    placeholderCanvas: (infer A)[];
  } ? ReactiveWrapped<any, Full['placeholderCanvas'][number]>[] : never;
  accompanyingCanvas: Full extends {
    accompanyingCanvas: (infer A)[];
  } ? ReactiveWrapped<any, Full['accompanyingCanvas'][number]>[] : never;
  provider: Full extends {
    provider: (infer A)[];
  } ? ReactiveWrapped<any, Full['provider'][number]>[] : never;
  body: Full extends {
    body: (infer A)[];
  } ? ReactiveWrapped<any, Full['body'][number]>[] : never;
  logo: Full extends {
    logo: (infer A)[];
  } ? ReactiveWrapped<any, Full['logo'][number]>[] : never;
};
declare namespace vault_d_exports {
  export { EntityRef, GetObjectOptions, GetOptions, Vault, VaultOptions };
}
type VaultOptions = {
  reducers: Record<string, any>;
  defaultState?: IIIFStore;
  customFetcher: <T>(url: string, options: T) => unknown | Promise<unknown>;
  enableDevtools: boolean;
};
type GetOptions = {
  skipSelfReturn?: boolean;
  parent?: Reference<any> | string;
  preserveSpecificResources?: boolean;
  skipPartOfCheck?: boolean;
};
type GetObjectOptions = GetOptions & {
  reactive?: boolean;
};
type EntityRef<Ref extends keyof Entities> = IIIFStore['iiif']['entities'][Ref][string];
declare class Vault {
  private readonly options;
  private readonly store;
  private readonly emitter;
  private isBatching;
  private batchQueue;
  remoteFetcher: (str: string, options?: any, mapper?: (resource: any) => any) => Promise<NormalizedEntity | undefined>;
  staticFetcher: (str: string, json: any, mapper?: (resource: any) => any) => Promise<NormalizedEntity | undefined> | NormalizedEntity | undefined;
  constructor(options?: Partial<VaultOptions>, store?: VaultZustandStore);
  defaultFetcher: (url: string) => Promise<any>;
  batch(cb: (vault: this) => void): void;
  asyncBatch(cb: (vault: this) => Promise<void> | void): Promise<void>;
  modifyEntityField(entity: Reference<keyof Entities>, key: string, value: any): void;
  dispatch(action: AllActions | BatchAction): void;
  on<Type extends AllActions['type']>(event: Type | `after:${Type}`, handler: (ctx: {
    action: ActionFromType<Type>;
    state: IIIFStore;
  }) => void): () => void;
  serialize<Return>(entity: Reference<keyof Entities>, config: SerializeConfig): Return;
  toPresentation2<Return>(entity: Reference<keyof Entities>): Return;
  toPresentation3<Return>(entity: Reference<keyof Entities>): Return;
  hydrate<R extends {
    type?: string;
  }>(reference: string | Partial<R>, type?: string | GetOptions, options?: GetOptions): RefToNormalized<R>;
  hydrate<R extends {
    type?: string;
  }>(reference: string[] | Partial<R>[], type?: string | GetOptions, options?: GetOptions): RefToNormalized<R>[];
  get<R extends {
    type?: string;
  }>(reference: string | Partial<R> | Reference<R['type']> | SpecificResource<R>, type?: string | GetOptions, options?: GetOptions): RefToNormalized<R>;
  get<R extends {
    type?: string;
  }>(reference: string[] | Partial<R>[] | Reference<R['type']>[] | SpecificResource<R>[], type?: string | GetOptions, options?: GetOptions): RefToNormalized<R>[];
  select<R>(selector: (state: IIIFStore) => R): R;
  getStore(): VaultZustandStore;
  getState(): IIIFStore;
  deep(input?: any, prev?: any): any;
  loadManifest(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<ManifestNormalized | undefined>;
  loadCollection(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<CollectionNormalized | undefined>;
  load<T>(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<T | undefined>;
  loadSync<T>(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): T | undefined;
  loadManifestSync(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): ManifestNormalized | undefined;
  loadCollectionSync(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): CollectionNormalized | undefined;
  areInputsEqual(newInputs: readonly unknown[] | unknown, lastInputs: readonly unknown[] | unknown): boolean;
  subscribe<T>(selector: (state: IIIFStore) => T, subscription: (state: T, vault: Vault) => void, skipInitial: boolean): () => void;
  subscribe<T>(subscription: (state: T, vault: Vault) => void, skipInitial?: boolean): () => void;
  ensureLoaded(_id: string | Reference<any>): Promise<void>;
  requestStatus(id: string): RequestState[any] | undefined;
  getPaginationState<T = any>(resource: string | Reference): PaginationState | null;
  loadNextPage(resource: string | Reference, json?: any): Promise<[PaginationState | null, CollectionNormalized | null]>;
  getResourceMeta<T = any>(resource: string): Partial<T> | undefined;
  getResourceMeta<T = any, Key extends keyof T = keyof T>(resource: string, metaKey: Key): T[Key] | undefined;
  getObject<R extends {
    type?: string;
  }>(reference: string | Partial<R>, type?: string | GetObjectOptions, options?: GetObjectOptions): RefToNormalized<R>;
  loadObject<Type, NormalizedType = any>(id: string | Reference<any>, json?: any): Promise<ReactiveWrapped<Type, NormalizedType>>;
  loadManifestObject(id: string | Reference<any>, json?: any): Promise<ReactiveWrapped<Manifest, ManifestNormalized>>;
  loadCollectionObject(id: string | Reference<any>, json?: any): Promise<ReactiveWrapped<Collection, CollectionNormalized>>;
  wrapObject<T extends string>(objectType: Reference<T>): ReactiveWrapped<unknown, any>;
  isWrapped(object: any): boolean;
  setMetaValue<Value = any>([id, meta, key]: [string, string, string], newValueOrUpdate: Value | ((oldValue: Value | undefined) => Value)): void;
}
//#endregion
export { EntityRef, GetObjectOptions, GetOptions, Vault, VaultOptions, vault_d_exports };
//# sourceMappingURL=vault-B8SBWpct.d.cts.map