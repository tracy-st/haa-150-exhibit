{"version":3,"file":"painting-annotations-0y-vpoUY.js","names":["flatAnnotations: AnnotationNormalized[]","types: string[]","choices: ComplexChoice","items: Paintables['items']"],"sources":["../src/painting-annotations/parse-specific-resource.ts","../src/painting-annotations/helper.ts"],"sourcesContent":["import { ChoiceBody, ContentResource } from \"@iiif/presentation-3\";\n\nexport function parseSpecificResource(resource: ContentResource): [ContentResource | ChoiceBody, { selector?: any }] {\n  if (resource.type === 'SpecificResource') {\n    return [resource.source, { selector: resource.selector }];\n  }\n\n  return [resource, { selector: null }];\n}\n","import { ContentResource, IIIFExternalWebResource } from '@iiif/presentation-3';\nimport { AnnotationNormalized, CanvasNormalized } from '@iiif/presentation-3-normalized';\nimport { ComplexChoice, Paintables } from './types';\nimport { parseSpecificResource } from './parse-specific-resource';\nimport { compatVault, CompatVault } from '../compat';\n\nexport function createPaintingAnnotationsHelper(vault: CompatVault = compatVault) {\n  function getAllPaintingAnnotations(canvasOrId: string | CanvasNormalized | undefined | null) {\n    const canvas = canvasOrId\n      ? typeof canvasOrId === 'string'\n        ? vault.get<CanvasNormalized>(canvasOrId)\n        : canvasOrId\n      : null;\n\n    if (!canvas) {\n      return [];\n    }\n    const annotationPages = vault.get(canvas.items, { parent: canvas });\n    const flatAnnotations: AnnotationNormalized[] = [];\n    for (const page of annotationPages) {\n      flatAnnotations.push(...vault.get(page.items, { parent: page }));\n    }\n    return flatAnnotations;\n  }\n\n  function getPaintables(\n    paintingAnnotationsOrCanvas: string | CanvasNormalized | AnnotationNormalized[],\n    enabledChoices: string[] = []\n  ): Paintables {\n    const paintingAnnotations = Array.isArray(paintingAnnotationsOrCanvas)\n      ? paintingAnnotationsOrCanvas\n      : getAllPaintingAnnotations(paintingAnnotationsOrCanvas);\n\n    const types: string[] = [];\n    let choices: ComplexChoice = {\n      items: [],\n      type: 'complex-choice',\n    };\n    const items: Paintables['items'] = [];\n\n    for (const annotation of paintingAnnotations) {\n      if (annotation.type !== 'Annotation') {\n        throw new Error(`getPaintables() accept either a canvas or list of annotations`);\n      }\n\n      const references = Array.from(Array.isArray(annotation.body) ? annotation.body : [annotation.body]);\n      for (const reference of references) {\n        const [ref, { selector }] = parseSpecificResource(reference as any);\n        const body = vault.get(ref);\n        const type = (body.type || 'unknown').toLowerCase();\n\n        // Choice\n        if (type === 'choice') {\n          const nestedBodies = vault.get((body as any).items, { parent: (body as any).id }) as ContentResource[];\n          // Which are active? By default, the first, but we could push multiple here.\n          const selected = enabledChoices.length\n            ? enabledChoices.map((cid) => nestedBodies.find((b) => b.id === cid)).filter(Boolean)\n            : [nestedBodies[0]];\n\n          if (selected.length === 0) {\n            selected.push(nestedBodies[0]);\n          }\n\n          // Store choice.\n          choices.items.push({\n            type: 'single-choice',\n            items: nestedBodies.map((b) => ({\n              id: b.id,\n              label: (b as any).label as any,\n              selected: selected.indexOf(b) !== -1,\n            })) as any[],\n            label: (ref as any).label,\n          });\n\n          // @todo insert in the right order.\n          references.push(...(selected as any[]));\n\n          continue;\n        }\n\n        if (types.indexOf(type) === -1) {\n          types.push(type);\n        }\n\n        items.push({\n          type: type,\n          annotationId: annotation.id,\n          annotation: annotation as any,\n          resource: body as IIIFExternalWebResource,\n          target: annotation.target,\n          selector,\n        });\n      }\n    }\n\n    return {\n      types,\n      items,\n      choice: choices.items.length < 2 ? choices.items[0] || null : choices,\n      allChoices: choices.items.length ? choices : null,\n    };\n  }\n\n  function extractChoices(paintingAnnotationsOrCanvas: string | CanvasNormalized | AnnotationNormalized[]) {\n    const { choice } = getPaintables(paintingAnnotationsOrCanvas);\n    return choice;\n  }\n\n  return {\n    getAllPaintingAnnotations,\n    getPaintables,\n    extractChoices,\n  };\n}\n"],"mappings":"mDAEA,SAAgB,EAAsB,EAA+E,CAKnH,OAJI,EAAS,OAAS,mBACb,CAAC,EAAS,OAAQ,CAAE,SAAU,EAAS,WAGzC,CAAC,EAAU,CAAE,SAAU,OCDhC,SAAgB,EAAgC,EAAqB,EAAa,CAChF,SAAS,EAA0B,EAA0D,CAC3F,IAAM,EAAS,EACX,OAAO,GAAe,SACpB,EAAM,IAAsB,GAC5B,EACF,KAEJ,GAAI,CAAC,EACH,MAAO,GAET,IAAM,EAAkB,EAAM,IAAI,EAAO,MAAO,CAAE,OAAQ,IACpDA,EAA0C,GAChD,IAAK,IAAM,KAAQ,EACjB,EAAgB,KAAK,GAAG,EAAM,IAAI,EAAK,MAAO,CAAE,OAAQ,KAE1D,OAAO,EAGT,SAAS,EACP,EACA,EAA2B,GACf,CACZ,IAAM,EAAsB,MAAM,QAAQ,GACtC,EACA,EAA0B,GAExBC,EAAkB,GACpBC,EAAyB,CAC3B,MAAO,GACP,KAAM,kBAEFC,EAA6B,GAEnC,IAAK,IAAM,KAAc,EAAqB,CAC5C,GAAI,EAAW,OAAS,aACtB,MAAU,MAAM,iEAGlB,IAAM,EAAa,MAAM,KAAK,MAAM,QAAQ,EAAW,MAAQ,EAAW,KAAO,CAAC,EAAW,OAC7F,IAAK,IAAM,KAAa,EAAY,CAClC,GAAM,CAAC,EAAK,CAAE,aAAc,EAAsB,GAC5C,EAAO,EAAM,IAAI,GACjB,GAAQ,EAAK,MAAQ,WAAW,cAGtC,GAAI,IAAS,SAAU,CACrB,IAAM,EAAe,EAAM,IAAK,EAAa,MAAO,CAAE,OAAS,EAAa,KAEtE,EAAW,EAAe,OAC5B,EAAe,IAAK,GAAQ,EAAa,KAAM,GAAM,EAAE,KAAO,IAAM,OAAO,SAC3E,CAAC,EAAa,IAEd,EAAS,SAAW,GACtB,EAAS,KAAK,EAAa,IAI7B,EAAQ,MAAM,KAAK,CACjB,KAAM,gBACN,MAAO,EAAa,IAAK,IAAO,CAC9B,GAAI,EAAE,GACN,MAAQ,EAAU,MAClB,SAAU,EAAS,QAAQ,KAAO,MAEpC,MAAQ,EAAY,QAItB,EAAW,KAAK,GAAI,GAEpB,SAGE,EAAM,QAAQ,KAAU,IAC1B,EAAM,KAAK,GAGb,EAAM,KAAK,CACH,OACN,aAAc,EAAW,GACb,aACZ,SAAU,EACV,OAAQ,EAAW,OACnB,cAKN,MAAO,CACL,QACA,QACA,OAAQ,EAAQ,MAAM,OAAS,EAAI,EAAQ,MAAM,IAAM,KAAO,EAC9D,WAAY,EAAQ,MAAM,OAAS,EAAU,MAIjD,SAAS,EAAe,EAAiF,CACvG,GAAM,CAAE,UAAW,EAAc,GACjC,OAAO,EAGT,MAAO,CACL,4BACA,gBACA"}