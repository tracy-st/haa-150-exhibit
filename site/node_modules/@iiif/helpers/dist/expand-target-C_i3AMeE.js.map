{"version":3,"file":"expand-target-C_i3AMeE.js","names":["i","val","result: Record<string, BoxStyle>","style: BoxStyle","result: BoxStyle","mapToEllipse","approxUnitArc","vectorAngle","getArcCenter","arcToBezier","prevCmd: 'M' | 'L' | 'H' | 'V' | 'C' | 'S' | 'Q' | 'T' | 'A' | 'Z' | undefined","quadX: number | undefined","quadY: number | undefined","out: NormalizedSvgPathCommand[]","arcToCurve","selector: TemporalSelector","selector: SupportedSelectors","selectors: SupportedSelectors[]","points: [number, number][]","rect: [number, number, number, number] | undefined","style: SelectorStyle | undefined","svgShape: SvgShapeType | undefined","svgElement: SVGElement | null","sel: SvgSelector","shapeType: SvgShapeType","out: [number, number][]","style: SelectorStyle","rootElem: SVGElement | null"],"sources":["../src/annotation-targets/bezier.ts","../src/annotation-targets/css-selectors.ts","../node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js","../node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js","../node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js","../src/annotation-targets/normalize-svg.ts","../src/annotation-targets/parse-selector.ts","../src/annotation-targets/expand-target.ts"],"sourcesContent":["/** Code to \"flatten\" quadratic and cubic Bézier curves to polylines.\n *\n * All code in this module is based on JavaScript code by Raph Levien, published on his blog at\n * https://raphlinus.github.io/.\n * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.\n *\n * Flattening of quadratic Bézier curves:\n * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html\n * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212\n *\n * Flattening of cubic Bézier curves: https://levien.com/tmp/flatten.html\n *\n * Note that the code in this module has a different license than the rest of the package,\n * due to the inclusion of Apache-licensed third party code.\n *\n * @license\n * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>\n * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type Point = { x: number; y: number };\n\nexport function flattenQuadraticBezier(start: Point, control: Point, end: Point, tolerance = 1): Point[] {\n  return new QuadraticBezier(start, control, end).subdivide(tolerance);\n}\n\nexport function flattenCubicBezier(\n  start: Point,\n  startControl: Point,\n  end: Point,\n  endControl: Point,\n  tolerance = 1\n): Point[] {\n  return new CubicBezier(\n    new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])\n  ).subdivide(tolerance) as Point[];\n}\n\nfunction hypot2(p: Point): number {\n  return p.x * p.x + p.y * p.y;\n}\n\n// Compute an approximation to int (1 + 4x^2) ^ -0.25 dx\nfunction approx_myint(x: number): number {\n  const d = 0.67;\n  return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));\n}\n\n// Approximate the inverse of `approx_myint`\nfunction approx_inv_myint(x: number): number {\n  const b = 0.39;\n  return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));\n}\n\n// Parameters for a basic parabola corresponding to a quadratic bézier curve\ntype QuadraticBezierBasicParams = {\n  x0: number;\n  x2: number;\n  scale: number;\n  cross: number;\n};\n\nclass QuadraticBezier {\n  start: Point;\n  control: Point;\n  end: Point;\n\n  constructor(start: Point, control: Point, end: Point) {\n    this.start = start;\n    this.control = control;\n    this.end = end;\n  }\n\n  eval(t: number): Point {\n    const mt = 1 - t;\n    return {\n      x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,\n      y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t,\n    };\n  }\n\n  mapToBasic(): QuadraticBezierBasicParams {\n    const { x: x0, y: y0 } = this.start;\n    const { x: x1, y: y1 } = this.control;\n    const { x: x2, y: y2 } = this.end;\n\n    // Determine the x values and scaling to map to y=x^2\n    const ddx = 2 * x1 - x0 - x2;\n    const ddy = 2 * y1 - y0 - y2;\n    const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;\n    const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;\n    const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;\n    const paramX0 = u0 / cross;\n    const paramX2 = u2 / cross;\n\n    // There's probably a more elegant formulation of this...\n    const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));\n\n    return { x0, x2, scale, cross };\n  }\n\n  subdivide(tolerance: number): Point[] {\n    const params = this.mapToBasic();\n    const a0 = approx_myint(params.x0);\n    const a2 = approx_myint(params.x2);\n    const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);\n    const n = Math.ceil(count);\n    const u0 = approx_inv_myint(a0);\n    const u2 = approx_inv_myint(a2);\n    const tValues = [0];\n    for (let i = 1; i < n; i++) {\n      const u = approx_inv_myint(a0 + ((a2 - a0) * i) / n);\n      const t = (u - u0) / (u2 - u0);\n      tValues.push(t);\n    }\n    tValues.push(1);\n    return tValues.map((t) => this.eval(t));\n  }\n}\n\nclass CubicBezier {\n  private c: Float64Array;\n\n  /// Argument is array of coordinate values [x0, y0, x1, y1, x2, y2, x3, y3].\n  constructor(coords: Float64Array) {\n    this.c = coords;\n  }\n\n  weightsum(c0: number, c1: number, c2: number, c3: number): Point {\n    const x = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];\n    const y = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];\n    return { x, y };\n  }\n\n  eval(t: number): Point {\n    const mt = 1 - t;\n    const c0 = mt * mt * mt;\n    const c1 = 3 * mt * mt * t;\n    const c2 = 3 * mt * t * t;\n    const c3 = t * t * t;\n    return this.weightsum(c0, c1, c2, c3);\n  }\n\n  deriv(t: number): Point {\n    const mt = 1 - t;\n    const c0 = -3 * mt * mt;\n    const c3 = 3 * t * t;\n    const c1 = -6 * t * mt - c0;\n    const c2 = 6 * t * mt - c3;\n    return this.weightsum(c0, c1, c2, c3);\n  }\n\n  // quadratic bezier with matching endpoints and minimum max vector error\n  midpoint_quadbez(): QuadraticBezier {\n    const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);\n    return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });\n  }\n\n  subsegment(t0: number, t1: number): CubicBezier {\n    const c = new Float64Array(8);\n    const p0 = this.eval(t0);\n    const p3 = this.eval(t1);\n    c[0] = p0.x;\n    c[1] = p0.y;\n    const scale = (t1 - t0) / 3;\n    const d1 = this.deriv(t0);\n    c[2] = p0.x + scale * d1.x;\n    c[3] = p0.y + scale * d1.y;\n    const d2 = this.deriv(t1);\n    c[4] = p3.x - scale * d2.x;\n    c[5] = p3.y - scale * d2.y;\n    c[6] = p3.x;\n    c[7] = p3.y;\n    return new CubicBezier(c);\n  }\n\n  // Very fancy subdivision scheme\n  subdivide(tol: number) {\n    const tol1 = 0.1 * tol; // error for subdivision into quads\n    const tol2 = tol - tol1; // error for subdivision of quads into lines\n    const sqrt_tol2 = Math.sqrt(tol2);\n    const err2 = hypot2(this.weightsum(1, -3, 3, -1));\n    const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));\n    const quads = [];\n    let sum = 0;\n    for (let i = 0; i < n_quads; i++) {\n      const t0 = i / n_quads;\n      const t1 = (i + 1) / n_quads;\n      const quad = this.subsegment(t0, t1).midpoint_quadbez();\n      const params = quad.mapToBasic();\n      const a0 = approx_myint(params.x0);\n      const a2 = approx_myint(params.x2);\n      const scale = Math.sqrt(params.scale);\n      let val = Math.abs(a2 - a0) * scale;\n      if (Math.sign(params.x0) != Math.sign(params.x2)) {\n        // min x value in basic parabola to make sure we don't skip cusp\n        const xmin = sqrt_tol2 / scale;\n        const cusp_val = (sqrt_tol2 * Math.abs(a2 - a0)) / approx_myint(xmin);\n        // I *think* it will always be larger, but just in case...\n        val = Math.max(val, cusp_val);\n      }\n      quads.push({\n        quad: quad,\n        a0: a0,\n        a2: a2,\n        val: val,\n      });\n      sum += val;\n    }\n    const count = (0.5 * sum) / sqrt_tol2;\n    const n = Math.ceil(count);\n    const result = [{ x: this.c[0], y: this.c[1] }];\n    let val = 0; // sum of vals from [0..i]\n    let i = 0;\n    for (let j = 1; j < n; j++) {\n      const target = (sum * j) / n;\n      while (val + quads[i].val < target) {\n        val += quads[i].val;\n        i++;\n      }\n      const a0 = quads[i].a0;\n      const a2 = quads[i].a2;\n      // Note: we can cut down on recomputing these\n      const u0 = approx_inv_myint(a0);\n      const u2 = approx_inv_myint(a2);\n      const a = a0 + ((a2 - a0) * (target - val)) / quads[i].val;\n      const u = approx_inv_myint(a);\n      const t = (u - u0) / (u2 - u0);\n      result.push(quads[i].quad.eval(t));\n    }\n    result.push({ x: this.c[6], y: this.c[7] });\n    return result;\n  }\n}\n","import type { BoxStyle, SelectorStyle } from './selector-types';\n\nexport function parseCssToBoxStyleMap(css: string): Record<string, BoxStyle> {\n  const result: Record<string, BoxStyle> = {};\n\n  // Remove comments and normalize whitespace\n  const cleanCss = css\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\n  // Match CSS rules with selectors and their properties\n  const ruleRegex = /([^{]+)\\{([^}]+)\\}/g;\n  let match;\n\n  while ((match = ruleRegex.exec(cleanCss)) !== null) {\n    const selectorPart = match[1].trim();\n    const propertiesPart = match[2].trim();\n\n    // Extract class name from selector (remove . prefix)\n    const classMatch = selectorPart.match(/\\.([a-zA-Z0-9_-]+)/);\n    if (!classMatch) continue;\n\n    const className = classMatch[1];\n\n    // Parse properties\n    const properties = propertiesPart.split(';').filter((prop) => prop.trim());\n    const style: BoxStyle = {};\n\n    for (const prop of properties) {\n      const [key, value] = prop.split(':').map((s) => s.trim());\n      if (!key || !value) continue;\n\n      // Convert CSS property names to camelCase and map to BoxStyle properties\n      switch (key) {\n        case 'background-color':\n          style.backgroundColor = value;\n          break;\n        case 'opacity':\n          style.opacity = parseFloat(value);\n          break;\n        case 'box-shadow':\n          style.boxShadow = value;\n          break;\n        case 'border-color':\n          style.borderColor = value;\n          break;\n        case 'border-width':\n          style.borderWidth = value;\n          break;\n        case 'border-style':\n          style.borderStyle = value;\n          break;\n        case 'outline-color':\n          style.outlineColor = value;\n          break;\n        case 'outline-width':\n          style.outlineWidth = value;\n          break;\n        case 'outline-offset':\n          style.outlineOffset = value;\n          break;\n        case 'outline-style':\n          style.outlineStyle = value;\n          break;\n        case 'border':\n          style.border = value;\n          break;\n        case 'outline':\n          style.outline = value;\n          break;\n        case 'background':\n          style.background = value;\n          break;\n      }\n    }\n\n    result[className] = style;\n  }\n\n  return result;\n}\n\nexport function convertSelectorStyleToBoxStyle(style?: SelectorStyle): BoxStyle {\n  const result: BoxStyle = {};\n\n  if (!style) {\n    return result;\n  }\n\n  if (style.fill) {\n    result.backgroundColor = style.fill;\n    if (style.fillOpacity) {\n      // @todo.\n    }\n  }\n\n  if (style.stroke) {\n    result.borderColor = style.stroke;\n  }\n\n  if (style.strokeWidth) {\n    result.borderWidth = style.strokeWidth;\n  }\n\n  return result;\n}\n\nexport function convertBoxStyleToSelectorStyle(style: BoxStyle): SelectorStyle {\n  const result: SelectorStyle = {};\n\n  // Map backgroundColor to fill\n  if (style.backgroundColor) {\n    result.fill = style.backgroundColor;\n  }\n\n  // Map background to fill if backgroundColor is not available\n  if (!result.fill && style.background) {\n    result.fill = style.background;\n  }\n\n  // Map opacity to fillOpacity\n  if (typeof style.opacity !== 'undefined') {\n    result.fillOpacity = style.opacity;\n  }\n\n  // Map border properties to stroke\n  if (style.borderColor) {\n    result.stroke = style.borderColor;\n  }\n\n  // Map border shorthand to stroke if borderColor is not available\n  if (!result.stroke && style.border) {\n    // Extract color from border shorthand (simplified approach)\n    const borderParts = style.border.split(' ');\n    const colorPart = borderParts.find(\n      (part) => part.startsWith('#') || part.startsWith('rgb') || part.match(/^[a-z]+$/i)\n    );\n    if (colorPart) {\n      result.stroke = colorPart;\n    }\n  }\n\n  // Map borderWidth to strokeWidth\n  if (style.borderWidth) {\n    result.strokeWidth = style.borderWidth;\n  }\n\n  // Extract stroke width from border shorthand if borderWidth is not available\n  if (!result.strokeWidth && style.border) {\n    const borderParts = style.border.split(' ');\n    const widthPart = borderParts.find((part) => part.match(/^\\d+(?:px|em|rem|%)?$/));\n    if (widthPart) {\n      result.strokeWidth = widthPart;\n    }\n  }\n\n  return result;\n}\n\nconst styleParsedCache = new Map<string, Record<string, BoxStyle>>();\n\nexport function cachedParseCssToBoxStyleMap(id: string, css: string) {\n  if (styleParsedCache.has(id)) {\n    return styleParsedCache.get(id)!;\n  }\n\n  const styleMap = parseCssToBoxStyleMap(css);\n  styleParsedCache.set(id, Object.fromEntries(Object.entries(styleMap).map(([key, value]) => [key, value])));\n\n  return styleMap;\n}\n\nexport function resolveSelectorStyle(\n  styleClass?: string,\n  loadedStylesheets?: Record<string, string>,\n  existingStyle: SelectorStyle = {}\n): BoxStyle {\n  if (!styleClass || !loadedStylesheets) {\n    return convertSelectorStyleToBoxStyle(existingStyle || {});\n  }\n\n  const newStyle = convertSelectorStyleToBoxStyle(existingStyle || {});\n  const stylesheetEntries = Object.entries(loadedStylesheets);\n\n  for (const [id, css] of stylesheetEntries) {\n    if (!css) continue;\n    const styleMap = cachedParseCssToBoxStyleMap(id, css);\n    const classes = Object.entries(styleMap);\n    for (const [className, classStyle] of classes) {\n      if (className === styleClass) {\n        Object.assign(newStyle, classStyle);\n      }\n    }\n  }\n\n  return newStyle;\n}\n","var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexport default arcToBezier;","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","\nmodule.exports = absolutize\n\n/**\n * redefine `path` with absolute coordinates\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction absolutize(path){\n\tvar startX = 0\n\tvar startY = 0\n\tvar x = 0\n\tvar y = 0\n\n\treturn path.map(function(seg){\n\t\tseg = seg.slice()\n\t\tvar type = seg[0]\n\t\tvar command = type.toUpperCase()\n\n\t\t// is relative\n\t\tif (type != command) {\n\t\t\tseg[0] = command\n\t\t\tswitch (type) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tseg[6] += x\n\t\t\t\t\tseg[7] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'v':\n\t\t\t\t\tseg[1] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'h':\n\t\t\t\t\tseg[1] += x\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tfor (var i = 1; i < seg.length;) {\n\t\t\t\t\t\tseg[i++] += x\n\t\t\t\t\t\tseg[i++] += y\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update cursor state\n\t\tswitch (command) {\n\t\t\tcase 'Z':\n\t\t\t\tx = startX\n\t\t\t\ty = startY\n\t\t\t\tbreak\n\t\t\tcase 'H':\n\t\t\t\tx = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'V':\n\t\t\t\ty = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'M':\n\t\t\t\tx = startX = seg[1]\n\t\t\t\ty = startY = seg[2]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tx = seg[seg.length - 2]\n\t\t\t\ty = seg[seg.length - 1]\n\t\t}\n\n\t\treturn seg\n\t})\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport arcToCurve from 'svg-arc-to-cubic-bezier';\nimport parseSvgPath from 'parse-svg-path';\nimport absSvgPath, {\n  AbsoluteCubicBezierCommand,\n  AbsoluteLineCommand,\n  AbsoluteMoveCommand,\n  AbsoluteQuadraticBezierCommand,\n} from 'abs-svg-path';\n\nexport type NormalizedSvgPathCommand =\n  | AbsoluteMoveCommand\n  | AbsoluteLineCommand\n  | AbsoluteCubicBezierCommand\n  | AbsoluteQuadraticBezierCommand;\n\nexport type NormalizedSvgPathCommandType = 'M' | 'L' | 'C' | 'Q';\n\n/** Parse an SVG path and normalize it so it only contains Moves, Lines and Cubic or Quadratic Bézier curves\n *  in their absolute form. */\nexport function parseAndNormalizeSvgPath(path: string): NormalizedSvgPathCommand[] {\n  const parsed = parseSvgPath(path);\n  const absolute = absSvgPath(parsed);\n\n  let prevCmd: 'M' | 'L' | 'H' | 'V' | 'C' | 'S' | 'Q' | 'T' | 'A' | 'Z' | undefined;\n  let startX = 0;\n  let startY = 0;\n  let bezierX = 0;\n  let bezierY = 0;\n  let quadX: number | undefined;\n  let quadY: number | undefined;\n  let x = 0;\n  let y = 0;\n  const out: NormalizedSvgPathCommand[] = [];\n  for (let i = 0; i < absolute.length; i++) {\n    let seg = absolute[i];\n    const cmd = seg[0];\n    switch (cmd) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n      case 'H':\n        seg = ['L', seg[1], startY];\n        break;\n      case 'V':\n        seg = ['L', startX, seg[1]];\n        break;\n      case 'S':\n        {\n          let cx = x;\n          let cy = y;\n          if (prevCmd === 'C' || prevCmd == 'S') {\n            cx += cx - bezierX;\n            cy += cy - bezierY;\n          }\n          seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        }\n        break;\n      case 'T':\n        if (prevCmd === 'Q' || prevCmd == 'T') {\n          quadX = x * 2 - quadX!;\n          quadY = y * 2 - quadY!;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n        seg = ['Q', quadX, quadY, seg[1], seg[2]];\n        break;\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        break;\n      case 'A':\n        {\n          const curves = arcToCurve({\n            px: x,\n            py: y,\n            cx: seg[6],\n            cy: seg[7],\n            rx: seg[1],\n            ry: seg[2],\n            xAxisRotation: seg[3],\n            largeArcFlag: seg[4],\n            sweepFlag: seg[5],\n          });\n          if (!curves.length) {\n            continue;\n          }\n          for (const [j, curve] of curves.entries()) {\n            seg = ['C', curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];\n            if (j < curves.length - 1) {\n              out.push(seg);\n            }\n          }\n          // FIXME: Why do we need this cast?\n          seg = seg as NormalizedSvgPathCommand;\n        }\n        break;\n      case 'Z':\n        seg = ['L', startX, startY];\n        break;\n    }\n\n    prevCmd = cmd;\n    x = seg[seg.length - 2] as number;\n    y = seg[seg.length - 1] as number;\n    if (['C', 'Q', 'A'].indexOf(cmd) > -1) {\n      bezierX = seg[seg.length - 4] as number;\n      bezierY = seg[seg.length - 3] as number;\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n    out.push(seg);\n  }\n\n  return out;\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\nimport type { ImageApiSelector, Selector } from '@iiif/presentation-3';\nimport { flattenCubicBezier, flattenQuadraticBezier } from './bezier';\nimport { resolveSelectorStyle } from './css-selectors';\nimport {\n  type NormalizedSvgPathCommand,\n  type NormalizedSvgPathCommandType,\n  parseAndNormalizeSvgPath,\n} from './normalize-svg';\nimport {\n  type ParsedSelector,\n  type SelectorStyle,\n  type SupportedSelectors,\n  type SvgSelector,\n  type SvgShapeType,\n  TemporalBoxSelector,\n  type TemporalSelector,\n} from './selector-types';\n\nconst BOX_SELECTOR =\n  /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?)/;\n\n// Does not support 00:00:00 or 00:00 formats.\nconst TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(\\.[0-9]+)?)?(,([0-9]+(\\.[0-9]+)?))?/;\n\nconst RGBA_COLOR = /^rgba\\((\\d+),(\\d+),(\\d+),([0-9.]+)\\)$/;\n\nexport function parseSelector(\n  source: Selector | Selector[],\n  {\n    domParser,\n    svgPreprocessor,\n    iiifRenderingHints,\n    loadedStylesheets,\n  }: {\n    domParser?: DOMParser;\n    svgPreprocessor?: (svg: string) => string;\n    iiifRenderingHints?: ImageApiSelector;\n    loadedStylesheets?: Record<string, string>;\n  } = {},\n  { styleClass }: { styleClass?: string } = {}\n): ParsedSelector {\n  if (Array.isArray(source)) {\n    return resolveHints(\n      (source as Array<string | Selector>).reduce(\n        <ParseSelector>(data: ParsedSelector, nextSource: string | Selector) => {\n          const {\n            selector,\n            selectors,\n            iiifRenderingHints: newIiifRenderingHints,\n          } = parseSelector(\n            nextSource,\n            {\n              domParser,\n              svgPreprocessor,\n              iiifRenderingHints,\n            },\n            { styleClass }\n          );\n          if (selector) {\n            if (!data.selector) {\n              data.selector = selector;\n            } else {\n              // @todo we could be smarter about the \"main\" selector.\n              if (!data.selector.temporal && selector.temporal) {\n                data.selector.temporal = selector.temporal;\n              }\n              if (!data.selector.spatial && selector.spatial) {\n                data.selector.spatial = selector.spatial;\n              }\n\n              // There is a bug here where the type won't resolve correctly... \"TemporalSVGSelector\" or whatever.\n              if (!data.selector.svg && selector.svg) {\n                data.selector.svg = selector.svg;\n              }\n              if (!data.selector.svgShape && selector.svgShape) {\n                data.selector.svgShape = selector.svgShape;\n              }\n            }\n            data.selectors.push(...selectors);\n          }\n          if (newIiifRenderingHints) {\n            data.iiifRenderingHints = data.iiifRenderingHints || {\n              type: 'ImageApiSelector',\n            };\n            Object.assign(data.iiifRenderingHints, newIiifRenderingHints);\n          }\n          return data;\n        },\n        {\n          selector: null,\n          selectors: [],\n          iiifRenderingHints,\n        } as ParsedSelector\n      )\n    );\n  }\n\n  if (!source) {\n    return resolveHints({\n      selector: null,\n      selectors: [],\n      iiifRenderingHints,\n    });\n  }\n\n  if (typeof source === 'string') {\n    const [id, fragment] = source.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return resolveHints({\n        selector: null,\n        selectors: [],\n        iiifRenderingHints,\n      });\n    }\n\n    return parseSelector(\n      { type: 'FragmentSelector', value: fragment },\n      { svgPreprocessor, iiifRenderingHints, domParser },\n      { styleClass }\n    );\n  }\n\n  if (source.type) {\n    if (source.type === 'PointSelector' && (source.t || source.t === 0)) {\n      const selector: TemporalSelector = {\n        type: 'TemporalSelector',\n        temporal: {\n          startTime: source.t,\n        },\n      };\n\n      return resolveHints({\n        selector,\n        selectors: [selector],\n        iiifRenderingHints,\n      });\n    }\n\n    if (source.type === 'PointSelector' && source.x && source.y) {\n      const selector: SupportedSelectors = {\n        type: 'PointSelector',\n        spatial: {\n          x: source.x,\n          y: source.y,\n        },\n      };\n\n      return resolveHints({\n        selector,\n        selectors: [selector],\n        iiifRenderingHints,\n      });\n    }\n  }\n\n  if (isImageApiSelector(source)) {\n    const selectors: SupportedSelectors[] = [];\n    if (source.region) {\n      const parsedRegion = parseSelector(\n        { type: 'FragmentSelector', value: 'xywh=' + source.region },\n        { domParser, svgPreprocessor, iiifRenderingHints },\n        { styleClass }\n      );\n      selectors.push(...parsedRegion.selectors);\n    }\n\n    return resolveHints({\n      selector: selectors[0],\n      selectors: selectors,\n      iiifRenderingHints: iiifRenderingHints ? { ...iiifRenderingHints, ...source } : source,\n    });\n  }\n\n  if (source.type === 'FragmentSelector') {\n    const matchBoxSelector = BOX_SELECTOR.exec(source.value);\n    if (matchBoxSelector) {\n      let selector: SupportedSelectors = {\n        type: 'BoxSelector',\n        spatial: {\n          unit: matchBoxSelector[2] === 'percent:' || matchBoxSelector[2] === 'pct:' ? 'percent' : 'pixel',\n          x: Number.parseFloat(matchBoxSelector[3]),\n          y: Number.parseFloat(matchBoxSelector[4]),\n          width: Number.parseFloat(matchBoxSelector[5]),\n          height: Number.parseFloat(matchBoxSelector[6]),\n        },\n        boxStyle: resolveSelectorStyle(styleClass, loadedStylesheets),\n      };\n\n      const matchBoxTimeSelector = source.value.match(TEMPORAL_SELECTOR);\n      if (matchBoxTimeSelector) {\n        selector = {\n          type: 'TemporalBoxSelector',\n          spatial: selector.spatial,\n          temporal: {\n            startTime: matchBoxTimeSelector[3] ? Number.parseFloat(matchBoxTimeSelector[3]) : 0,\n            endTime: matchBoxTimeSelector[6] ? Number.parseFloat(matchBoxTimeSelector[6]) : undefined,\n          },\n          boxStyle: resolveSelectorStyle(styleClass, loadedStylesheets),\n        };\n      }\n\n      return resolveHints({\n        selector,\n        selectors: [selector],\n        iiifRenderingHints,\n      });\n    }\n\n    const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);\n    if (matchTimeSelector) {\n      const selector: TemporalSelector = {\n        type: 'TemporalSelector',\n        temporal: {\n          startTime: matchTimeSelector[3] ? Number.parseFloat(matchTimeSelector[3]) : 0,\n          endTime: matchTimeSelector[6] ? Number.parseFloat(matchTimeSelector[6]) : undefined,\n        },\n      };\n\n      return resolveHints({\n        selector,\n        selectors: [selector],\n        iiifRenderingHints,\n      });\n    }\n\n    return resolveHints({\n      selector: null,\n      selectors: [],\n      iiifRenderingHints,\n    });\n  }\n\n  if (source.type === 'SvgSelector' && 'value' in source) {\n    if (!domParser) {\n      if (typeof window !== 'undefined') {\n        domParser = new window.DOMParser();\n      } else {\n        console.warn(\n          'No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized.'\n        );\n      }\n    }\n    let points: [number, number][] = [];\n    let rect: [number, number, number, number] | undefined;\n    let style: SelectorStyle | undefined;\n    let svg = svgPreprocessor?.(source.value) ?? source.value;\n    let svgShape: SvgShapeType | undefined;\n    if (domParser) {\n      const svgElement: SVGElement | null = domParser\n        .parseFromString(source.value, 'image/svg+xml')\n        .querySelector('svg');\n      if (!svgElement) {\n        console.warn(`Illegal SVG selector: ${source.value}`);\n        return resolveHints({\n          selector: null,\n          selectors: [],\n          iiifRenderingHints,\n        });\n      }\n      const selectorElem = getSelectorElement(svgElement);\n      if (selectorElem) {\n        points = selectorElem.points;\n        svgShape = selectorElem.shapeType;\n        rect = [\n          Math.min(...points.map((p) => p[0])), // llx\n          Math.min(...points.map((p) => p[1])), // lly\n          Math.max(...points.map((p) => p[0])), // urx\n          Math.max(...points.map((p) => p[1])), // ury\n        ];\n        ({ style, svg } = extractStyles(selectorElem.element) ?? { svg });\n      }\n    }\n    const sel: SvgSelector = {\n      type: 'SvgSelector',\n      svg,\n      svgShape,\n      style,\n      boxStyle: resolveSelectorStyle(styleClass, loadedStylesheets, style),\n      points: points.length ? points : undefined,\n      spatial: rect\n        ? {\n            unit: 'pixel',\n            x: rect[0],\n            y: rect[1],\n            width: rect[2] - rect[0],\n            height: rect[3] - rect[1],\n          }\n        : undefined,\n    };\n    return resolveHints({\n      selector: sel,\n      selectors: [sel],\n      iiifRenderingHints,\n    });\n  }\n  return resolveHints({\n    selector: null,\n    selectors: [],\n    iiifRenderingHints,\n  });\n}\n\nexport type SelectorElement = {\n  element: SVGElement;\n  points: [number, number][];\n  shapeType: SvgShapeType;\n};\n\nfunction getShapeTypeFromPath(svgPath: NormalizedSvgPathCommand[]): SvgShapeType {\n  const cmdFrequencies = svgPath\n    .map((seg) => seg[0])\n    .reduce(\n      (acc: Record<NormalizedSvgPathCommandType, number>, cmd) => {\n        acc[cmd] += 1;\n        return acc;\n      },\n      { C: 0, Q: 0, L: 0, M: 0 }\n    );\n  const cmdTypes = new Set(svgPath.map((seg) => seg[0]));\n  if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {\n    return 'path';\n  }\n  if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || (cmdTypes.size === 2 && cmdTypes.has('M')))) {\n    // Only lines and moves: rectangle, polygon or polyline?\n    if (cmdFrequencies.L === 4) {\n      return 'rect';\n    }\n\n    // Check if the path is closed to decide if we have a polygon or a polyline\n    const lastSeg = svgPath.slice(-1)[0];\n    if (\n      (svgPath[0][0] === 'M' && lastSeg[0] === 'L' && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2]) ||\n      (lastSeg[1] === 0 && lastSeg[2] === 0)\n    ) {\n      return 'polygon';\n    } else {\n      return 'polyline';\n    }\n  }\n  return 'path';\n}\n\nfunction getSelectorElement(svgElem: SVGElement): SelectorElement | null {\n  for (const element of Array.from(svgElem.children) as SVGElement[]) {\n    switch (element?.tagName.toLowerCase()) {\n      case 'g':\n        {\n          // Check if any of the children in the container can be converted to points\n          const res = getSelectorElement(element as SVGElement);\n          if (res) {\n            return res;\n          }\n        }\n        continue;\n      case 'path': {\n        const p = element.getAttribute('d');\n        if (!p) {\n          continue;\n        }\n        const normalized = parseAndNormalizeSvgPath(p);\n        return {\n          element,\n          points: pathToPoints(normalized),\n          shapeType: getShapeTypeFromPath(normalized),\n        };\n      }\n      case 'circle': {\n        const cx = Number.parseFloat(element.getAttribute('cx') ?? '0');\n        const cy = Number.parseFloat(element.getAttribute('cy') ?? '0');\n        const r = Number.parseFloat(element.getAttribute('r') ?? '0');\n        if (!r) {\n          continue;\n        }\n        const points: [number, number][] = [];\n        // TODO: Get rid of the degree -> radian conversion and use radians from the beginning\n        for (let angle = 0; angle <= 360; angle += 12) {\n          const rad = (angle * Math.PI) / 180;\n          points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);\n        }\n        return { element, points, shapeType: 'circle' };\n      }\n      case 'ellipse': {\n        const cx = Number.parseFloat(element.getAttribute('cx') ?? '0');\n        const cy = Number.parseFloat(element.getAttribute('cy') ?? '0');\n        const rx = Number.parseFloat(element.getAttribute('rx') ?? '0');\n        const ry = Number.parseFloat(element.getAttribute('ry') ?? '0');\n        if (!rx && !ry) {\n          continue;\n        }\n        const points: [number, number][] = [];\n        for (let angle = 0; angle <= 360; angle += 12) {\n          const t = Math.tan((angle / 360) * Math.PI);\n          const px = (rx * (1 - t ** 2)) / (1 + t ** 2);\n          const py = (ry * 2 * t) / (1 + t ** 2);\n          points.push([cx + px, cy + py]);\n        }\n        return { element, points, shapeType: 'ellipse' };\n      }\n      case 'line': {\n        const x0 = Number.parseFloat(element.getAttribute('x0') ?? '0');\n        const y0 = Number.parseFloat(element.getAttribute('y0') ?? '0');\n        const x1 = Number.parseFloat(element.getAttribute('x1') ?? '0');\n        const y1 = Number.parseFloat(element.getAttribute('y1') ?? '0');\n        if (x0 === x1 && y0 === y1) {\n          continue;\n        }\n        return {\n          element,\n          points: [\n            [x0, y0],\n            [x1, y1],\n          ],\n          shapeType: 'polyline',\n        };\n      }\n      case 'polygon':\n      case 'polyline': {\n        const points =\n          element\n            .getAttribute('points')\n            ?.split(' ')\n            .map((ps) => ps.split(',').map(Number.parseFloat) as [number, number]) ?? [];\n        if (!points.length) {\n          continue;\n        }\n        let shapeType: SvgShapeType = 'polyline';\n        if (element.tagName.toLowerCase() === 'polygon') {\n          // A polygon is a closed path, so the last point is the same as the first.\n          points.push(points[0]);\n          shapeType = 'polygon';\n        }\n        return { element, points, shapeType };\n      }\n      case 'rect': {\n        const x = Number.parseFloat(element.getAttribute('x') ?? '0');\n        const y = Number.parseFloat(element.getAttribute('y') ?? '0');\n        const width = Number.parseFloat(element.getAttribute('width') ?? '0');\n        const height = Number.parseFloat(element.getAttribute('height') ?? '0');\n        if (!width || !height) {\n          continue;\n        }\n        return {\n          element,\n          points: [\n            [x, y],\n            [x + width, y],\n            [x + width, y + height],\n            [x, y + height],\n            [x, y],\n          ],\n          shapeType: 'rect',\n        };\n      }\n      default:\n        // Try next element\n        continue;\n    }\n  }\n  return null;\n}\n\nfunction pathToPoints(normalizedPath: NormalizedSvgPathCommand[]): [number, number][] {\n  const out: [number, number][] = [];\n  for (let i = 0; i < normalizedPath.length; i++) {\n    const startPoint = out[out.length - 1] ?? [0, 0];\n    const seg = normalizedPath[i];\n    switch (seg[0]) {\n      case 'M':\n      case 'L':\n        out.push([seg[1], seg[2]]);\n        continue;\n      case 'C':\n        out.push(\n          ...flattenCubicBezier(\n            { x: startPoint[0], y: startPoint[1] },\n            { x: seg[1], y: seg[2] },\n            { x: seg[3], y: seg[4] },\n            { x: seg[5], y: seg[6] }\n          )\n            .map((p) => [p.x, p.y] as [number, number])\n            .slice(1) // skip first point, already part of output\n        );\n        continue;\n      case 'Q':\n        out.push(\n          ...flattenQuadraticBezier(\n            { x: startPoint[0], y: startPoint[1] },\n            { x: seg[1], y: seg[2] },\n            { x: seg[3], y: seg[4] }\n          )\n            .map((p) => [p.x, p.y] as [number, number])\n            .slice(1) // skip first point, already part of output\n        );\n        continue;\n    }\n  }\n  return out;\n}\n\n/** Extract styling information from SVG selector.\n *\n * Will remove all styling information from the SVG element\n * and normalize `rgba` colors for `fill` and `stroke` to\n * `rgb` and store the opacity in `fillOpacity` and `strokeOpacity`.\n */\nfunction extractStyles(selectorElement: SVGElement): { style?: SelectorStyle; svg: string } | undefined {\n  // TODO: Can this be simplified somehow?\n  const style: SelectorStyle = {};\n  if (selectorElement.hasAttribute('fill')) {\n    style.fill = selectorElement.getAttribute('fill')!;\n    selectorElement.removeAttribute('fill');\n  } else if (selectorElement.style && selectorElement.style.fill) {\n    style.fill = selectorElement.style.fill;\n  }\n  if (style.fill) {\n    const rgbaMatch = RGBA_COLOR.exec(style.fill);\n    if (rgbaMatch) {\n      style.fillOpacity = Number.parseFloat(rgbaMatch[4]);\n      style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;\n    }\n  }\n  if (selectorElement.hasAttribute('fill-opacity')) {\n    style.fillOpacity = Number.parseFloat(selectorElement.getAttribute('fill-opacity')!);\n    selectorElement.removeAttribute('fill-opacity');\n  } else if (selectorElement.style && selectorElement.style.fillOpacity) {\n    style.fillOpacity = Number.parseFloat(selectorElement.style.fillOpacity);\n  }\n\n  if (selectorElement.hasAttribute('stroke')) {\n    style.stroke = selectorElement.getAttribute('stroke')!;\n    selectorElement.removeAttribute('stroke');\n  } else if (selectorElement.style && selectorElement.style.stroke) {\n    style.stroke = selectorElement.style.stroke;\n  }\n  if (style.stroke) {\n    const rgbaMatch = RGBA_COLOR.exec(style.stroke);\n    if (rgbaMatch) {\n      style.strokeOpacity = Number.parseFloat(rgbaMatch[4]);\n      style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;\n    }\n  }\n  if (selectorElement.hasAttribute('stroke-opacity')) {\n    style.strokeOpacity = Number.parseFloat(selectorElement.getAttribute('stroke-opacity')!);\n    selectorElement.removeAttribute('stroke-opacity');\n  } else if (selectorElement.style && selectorElement.style.strokeOpacity) {\n    style.strokeOpacity = Number.parseFloat(selectorElement.style.strokeOpacity);\n  }\n  if (selectorElement.hasAttribute('stroke-width')) {\n    style.strokeWidth = selectorElement.getAttribute('stroke-width')!;\n    selectorElement.removeAttribute('stroke-width');\n  } else if (selectorElement.style && selectorElement.style.strokeWidth) {\n    style.strokeWidth = selectorElement.style.strokeWidth;\n  }\n  if (selectorElement.hasAttribute('stroke-dasharray')) {\n    style.strokeDasharray = selectorElement.getAttribute('stroke-dasharray')!;\n    selectorElement.removeAttribute('stroke-dasharray');\n  } else if (selectorElement.style && selectorElement.style.strokeDasharray) {\n    style.strokeDasharray = selectorElement.style.strokeDasharray;\n  }\n\n  let rootElem: SVGElement | null = selectorElement;\n  while (rootElem.tagName.toLowerCase() !== 'svg') {\n    rootElem = rootElem.parentElement as SVGElement | null;\n    if (rootElem === null) {\n      throw new Error('Could not find root SVG element');\n    }\n  }\n  return {\n    svg: rootElem.outerHTML,\n    style: Object.keys(style).length > 0 ? style : undefined,\n  };\n}\n\nexport function isImageApiSelector(t: unknown): t is ImageApiSelector {\n  if (!t) return false;\n  const type = (t as any).type || (t as any)['@type'];\n\n  return type === 'iiif:ImageApiSelector' || type === 'ImageApiSelector';\n}\n\nfunction resolveHints(supported: ParsedSelector): ParsedSelector {\n  if (supported.iiifRenderingHints) {\n    const source = supported.iiifRenderingHints;\n    if (source.rotation) {\n      const parsedRotation = parseRotation(`${source.rotation}`);\n      if (parsedRotation) {\n        if (supported.selectors.length) {\n          for (const selector of supported.selectors) {\n            selector.rotation = parsedRotation;\n          }\n        } else {\n          supported.selectors.push({\n            type: 'RotationSelector',\n            rotation: parsedRotation,\n          });\n        }\n      }\n    }\n  } else {\n    delete supported.iiifRenderingHints;\n  }\n\n  return supported;\n}\n\n/**\n * Parse rotation \"90\", \"180\", \"!90\"\n */\nexport function parseRotation(input: string) {\n  let num = Number.parseFloat(input);\n  if (num && input.startsWith('!')) {\n    // @note we don't support mirroring..\n    num = 360 - num;\n  }\n  if (num) {\n    num = num % 360;\n  }\n  if (num !== num) {\n    return 0;\n  }\n  return num || 0;\n}\n","import type { ExternalWebResource, W3CAnnotationTarget } from '@iiif/presentation-3';\nimport { parseSelector } from './parse-selector';\nimport type { ParsedSelector, SupportedSelector } from './selector-types';\nimport type { SupportedTarget } from './target-types';\n\nexport function expandTarget(\n  target: W3CAnnotationTarget | W3CAnnotationTarget[],\n  options: {\n    typeMap?: Record<string, string>;\n    domParser?: DOMParser;\n    svgPreprocessor?: (svg: string) => string;\n    loadedStylesheets?: Record<string, string>;\n    defaultType?: string;\n    styleClass?: string;\n  } = {}\n): SupportedTarget {\n  if (Array.isArray(target)) {\n    // Don't support multiple targets for now.\n    return expandTarget(target[0]);\n  }\n\n  if (typeof target === 'string') {\n    const [id, fragment] = target.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: {\n          id,\n          type: (options.typeMap && (options.typeMap[id] as any)) || options.defaultType || 'Canvas',\n        },\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return expandTarget(\n      {\n        type: 'SpecificResource',\n        source: { id, type: (options.typeMap && (options.typeMap[id] as any)) || options.defaultType || 'Canvas' },\n        selector: {\n          type: 'FragmentSelector',\n          value: fragment,\n        },\n      },\n      options\n    );\n  }\n\n  // @todo, how do we want to support choices for targets.\n  if (\n    target.type === 'Choice' ||\n    target.type === 'List' ||\n    target.type === 'Composite' ||\n    target.type === 'Independents'\n  ) {\n    // we also don't support these, just choose the first.\n    return expandTarget(target.items[0], options);\n  }\n\n  if (!target.type && 'source' in target) {\n    (target as any).type = 'SpecificResource';\n  }\n\n  if (target.type === 'SpecificResource') {\n    if (target.source.type === 'Canvas' && target.source.partOf && typeof target.source.partOf === 'string') {\n      target.source.partOf = [\n        {\n          id: target.source.partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n    const styleClass = target.styleClass || options.styleClass;\n\n    let preParsedSelector = { selector: null, selectors: [] } as ParsedSelector;\n    if (typeof target.source === 'string' && target.source.includes('#')) {\n      const expandedAgain = expandTarget(target.source, { ...options, styleClass });\n      target.source = expandedAgain.source;\n      preParsedSelector = {\n        selector: expandedAgain.selector,\n        selectors: expandedAgain.selectors,\n      };\n    }\n\n    const { selector, selectors } = target.selector\n      ? parseSelector(target.selector, options, { styleClass })\n      : preParsedSelector;\n\n    return {\n      type: 'SpecificResource',\n      source: target.source,\n      selector,\n      selectors,\n    };\n  }\n\n  if (target.id) {\n    if ((target as any).type === 'Canvas' && (target as any).partOf && typeof (target as any).partOf === 'string') {\n      (target as any).partOf = [\n        {\n          id: (target as any).partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n\n    const [id, fragment] = target.id.split('#');\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: {\n          ...(target as any),\n          id,\n        },\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return expandTarget(\n      {\n        type: 'SpecificResource',\n        source: {\n          ...(target as any),\n          id,\n        },\n        selector: {\n          type: 'FragmentSelector',\n          value: fragment,\n        },\n      },\n      options\n    );\n  }\n\n  return {\n    type: 'SpecificResource',\n    source: target as ExternalWebResource,\n    selector: null,\n    selectors: [],\n  };\n}\n"],"x_google_ignoreList":[2,3,4],"mappings":"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"}