import { ContentResource, ImageProfile, ImageService, ImageSize, ImageTile, Service } from "@iiif/presentation-3";
import * as zustand_vanilla1 from "zustand/vanilla";
import { Emitter } from "mitt";

//#region src/image-service/types.d.ts
type FixedSizeImage = {
  id: string;
  type: 'fixed';
  width: number;
  height: number;
  unsafe?: boolean;
};
type FixedSizeImageService = {
  id: string;
  type: 'fixed-service';
  width: number;
  height: number;
  level?: number | null;
  version?: number;
};
type VariableSizeImage = {
  id: string;
  type: 'variable';
  minWidth: number;
  maxWidth: number;
  minHeight: number;
  maxHeight: number;
  level?: number | null;
  version?: number;
};
type UnknownSizeImage = {
  id: string;
  type: 'unknown';
};
type ImageCandidate = FixedSizeImage | VariableSizeImage | UnknownSizeImage | FixedSizeImageService;
type ImageCandidateRequest = {
  width?: number;
  height?: number;
  maxWidth?: number;
  maxHeight?: number;
  minWidth?: number;
  minHeight?: number;
  fallback?: boolean;
  atAnyCost?: boolean;
  unsafeImageService?: boolean;
  returnAllOptions?: boolean;
  allowUnsafe?: boolean;
  preferFixedSize?: boolean;
  explain?: boolean;
};
//#endregion
//#region src/image-service/image-service-loader.d.ts
type ImageServer = {
  root: string;
  server: string | null;
  sampledId: string;
  verifications: number;
  verified: boolean;
  preLoaded: boolean;
  malformed: boolean;
  result: {
    context: string | string[];
    resourceServiceRatio: number;
    sampledSizes: ImageSize[];
    sizeRatios: number[];
    sampledTiles: ImageTile[];
    sampledProfile: ImageProfile | ImageProfile[];
  };
};
type ImageServiceRequest = {
  id: string;
  width: number;
  height: number;
  source?: ImageService;
};
type LoadedImageService = ImageService & {
  real: boolean;
};
type ImageServiceLoaderConfig = {
  verificationsRequired: number;
  approximateServices: boolean;
  enableFetching: boolean;
  disableThrottling: boolean;
};
declare class ImageServiceLoader {
  constructor(options?: Partial<ImageServiceLoaderConfig>);
  config: ImageServiceLoaderConfig;
  fetchingCount: number;
  imageServices: {
    [k: string]: LoadedImageService;
  };
  knownImageServers: {
    [k: string]: ImageServer;
  };
  /**
   * Preload image service
   *
   * This will preload an image service, fetching details and recording the image server that served
   * the request. Based on this it will make a template for predicting other image sources from this
   * server. You can optionally pass in other ids to verify that the prediction is accurate.
   *
   */
  setConfig(config: Partial<ImageServiceLoaderConfig>): void;
  /**
   * Sample pre-fetched service
   *
   * If you have already fetched an image service, or are creating a viewer that only talks to a single
   * image server and want to avoid calls, you can sample a service up-front. This will allow you to make
   * completely synchronous calls to `loadServiceSync` and avoid any network calls for image services.
   *
   * @param service
   * @param preLoaded Mark this as being pre-loaded (default: true)
   */
  sample(service: ImageService, imageServiceRequest?: ImageServiceRequest, preLoaded?: boolean): true | Promise<boolean>;
  /**
   * Preload an image server
   *
   * Similar to sample, but faster. This will bypass any checks and the logic contained in this implementation
   * allowing you to correct mistakes this implementation might have made.
   *
   * @param server
   * @param forceVerify
   */
  preLoad(server: ImageServer, forceVerify?: boolean): void;
  /**
   * Predict
   *
   * Predicts what the image service will be for a content resource.
   *
   * @param resource
   * @param verify
   * @param force
   */
  predict(resource: ImageServiceRequest, verify?: boolean, force?: boolean): ImageService | null;
  getThumbnailFromResource(unknownResource: ContentResource | undefined, request: ImageCandidateRequest, dereference?: boolean, otherCandidates?: ImageCandidate[]): Promise<{
    best: ImageCandidate | null;
    fallback: ImageCandidate[];
    log: string[];
  }>;
  getImageCandidates(unknownResource: ContentResource, dereference?: boolean): Promise<ImageCandidate[]>;
  /**
   * Verify approximation
   *
   * Given an image service, it will dereference that image service and compare the result with what
   * would have been generated if we used internal guessing.
   *
   * @param resource
   * @return Promise<boolean>
   */
  verify(resource: ImageServiceRequest): Promise<boolean>;
  canLoadSync(service: ImageServiceRequest | ImageService | string): boolean;
  /**
   * Mark image service as malformed
   *
   * If you run into issues requesting images, you can mark an image service as malformed, and it will
   * return you a new one. Future image services will also be requested fresh, and the system will have
   * failed. Report a bug if this happens.
   *
   * @param resource
   */
  markAsMalformed(resource: ImageServiceRequest): Promise<ImageService>;
  /**
   * Fetch an image service (use loadService instead)
   *
   * @param serviceId
   * @param forceFresh
   */
  fetchService(serviceId: string, forceFresh?: boolean): Promise<ImageService & {
    real: boolean;
  }>;
  fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;
  /**
   * Load an image service
   *
   * @param resource
   * @param forceFresh
   *
   * @todo make this batched, so only the maximum required can be done at once, to allow
   *       for the prediction engine to kick in.
   */
  loadService(resource: ImageServiceRequest, forceFresh?: boolean): Promise<ImageService>;
  /**
   * Load service synchronously
   *
   * If you know that the image service you are
   * @param resource
   */
  loadServiceSync(resource: ImageServiceRequest): ImageService | null;
}
//#endregion
//#region src/image-service/get-image-server-from-id.d.ts
/**
 * Get image server from ID.
 *
 * Normalises image service URLs to extract identity of the image server.
 *
 * @param url
 */
declare function getImageServerFromId(url: string): string;
//#endregion
//#region src/image-service/sampled-tiles-to-tiles.d.ts
declare function sampledTilesToTiles(width: number, height: number, sampledTiles: ImageTile[]): ImageTile[];
//#endregion
//#region src/image-service/pick-best-from-candidates.d.ts
/**
 * Pick best from candidates
 *
 * Takes in a list of candidate lists. The order should be in preference. This algorithm will try to pick
 * from the first list, with a best fit size. If not it will fallback to the other lists. It may come back
 * around to the first list and provide a fallback.
 *
 * @param inputRequest
 * @param candidates
 */
declare function pickBestFromCandidates(inputRequest: ImageCandidateRequest, candidates: Array<() => ImageCandidate[]>): {
  best: ImageCandidate | null;
  fallback: ImageCandidate[];
  log: string[];
};
//#endregion
//#region src/image-service/is-best-match.d.ts
declare function isBestMatch(request: Required<ImageCandidateRequest>, current: FixedSizeImage | null, candidate: FixedSizeImage): boolean;
//#endregion
//#region src/image-service/image-service-store.d.ts
type LoadImageServiceDetail = {
  width: number;
  height: number;
  force?: boolean;
};
interface ImageServiceStore {
  loaded: Record<string, {
    status: 'loading' | 'done' | 'error';
    service: ImageService | null;
    error?: boolean;
    errorMesage?: string;
    real?: boolean;
  }>;
  loadServiceSync: (service: ImageService, detail?: LoadImageServiceDetail, backgroundRequest?: boolean) => ImageService | null;
  loadService: (service: ImageService, detail?: LoadImageServiceDetail) => Promise<ImageService | null>;
}
interface ImageServiceStoreOptions {
  loader?: ImageServiceLoader;
  events?: Emitter<ImageServiceStoreEvents>;
}
type ImageServiceStoreEvents = {
  'image-service.loaded': {
    id: string;
    service: ImageService | null;
  };
  'image-service.loading': {
    id: string;
  };
  'image-service.error': {
    id: string;
    error: Error;
  };
};
declare function createImageServiceStore(options?: ImageServiceStoreOptions): {
  store: zustand_vanilla1.StoreApi<ImageServiceStore>;
  events: Emitter<ImageServiceStoreEvents>;
};
declare const imageServices: {
  store: zustand_vanilla1.StoreApi<ImageServiceStore>;
  events: Emitter<ImageServiceStoreEvents>;
};
//#endregion
//#region src/image-service/get-image-from-tile-source.d.ts
declare function getImageFromTileSource(image: FixedSizeImageService, targetWidth: number, targetHeight?: number): FixedSizeImage;
//#endregion
//#region src/image-service/get-image-candidates.d.ts
/**
 * Get image candidates
 *
 * Given an unknown resource, and optionally an image service loader, it will
 * try to get all of the possible options for images at a specific size.
 *
 * Note: if you are wanting to depend on external web resources, then you have
 * to either preload these, or prepare the image loader for predicting them.
 *
 * @param unknownResource
 * @param dereference
 * @param loader
 */
declare function getImageCandidates(unknownResource: ContentResource, dereference: boolean | undefined, loader: ImageServiceLoader): ImageCandidate[];
//#endregion
//#region src/image-service/get-image-candidates-from-service.d.ts
declare function getImageCandidatesFromService(service: ImageService[]): ImageCandidate[];
//#endregion
//#region src/image-service/get-fixed-sizes-from-service.d.ts
/**
 * Get fixed sizes from service.
 *
 * Given an image service, this will extract the images from the sizes field of
 * the service. These are usually cached and great options for thumbnails.
 *
 * @param service
 */
declare function getFixedSizesFromService(service: Service): FixedSizeImageService[];
//#endregion
//#region src/image-service/is-image-3.d.ts
declare function isImage3(service: any): boolean;
//#endregion
//#region src/image-service/get-custom-size-from-service.d.ts
/**
 * Get custom size from service
 *
 * Given an image service â€“ usually a full one, de-referenced or embedded â€“ this
 * will return a list of available image sizes (min and max width and height) that
 * can be used to construct a IIIF query to get an image at any size within those
 * bounds. This is only supported by some image services. If unsupported, this will
 * return an empty list.
 *
 * @param service
 */
declare function getCustomSizeFromService(service: ImageService): ImageCandidate[];
//#endregion
//#region src/image-service/get-fixed-size-from-image.d.ts
/**
 * Get fixed size from image
 *
 * Given a content resource, usually the body of a painting annotation, this will
 * return the URL to the image, and the height and width. The resource may also
 * be a string / direct link to the image. The height and width may be inferred from
 * a IIIF Image API endpoint, otherwise the return image candidate will have a type
 * of unknown.
 *
 * @param contentResource
 */
declare function getFixedSizeFromImage(contentResource: ContentResource | string): ImageCandidate | null;
//#endregion
//#region src/image-service/infer-size-from-url.d.ts
/**
 * Extracts the height and width from an image URL
 *
 * @param image
 */
declare function inferImageSizeFromUrl(image: string): ImageCandidate;
//#endregion
//#region src/image-service/image-sizes-match.d.ts
declare function imageSizesMatch(sizesA: ImageSize[], sizesB: ImageSize[]): boolean;
//#endregion
//#region src/image-service/get-smallest-scale-factor-as-single-image.d.ts
/**
 * Returns a fixed size image using the tile using the largest available size,
 * or the smallest scale factor.
 *
 * @param service
 */
declare function getSmallestScaleFactorAsSingleImage(service: ImageService): FixedSizeImageService | null;
//#endregion
export { FixedSizeImage, FixedSizeImageService, ImageCandidate, ImageCandidateRequest, ImageServer, ImageServiceLoader, ImageServiceLoaderConfig, ImageServiceRequest, ImageServiceStore, ImageServiceStoreEvents, ImageServiceStoreOptions, LoadImageServiceDetail, UnknownSizeImage, VariableSizeImage, createImageServiceStore, getCustomSizeFromService, getFixedSizeFromImage, getFixedSizesFromService, getImageCandidates, getImageCandidatesFromService, getImageFromTileSource, getImageServerFromId, getSmallestScaleFactorAsSingleImage, imageServices, imageSizesMatch, inferImageSizeFromUrl, isBestMatch, isImage3, pickBestFromCandidates, sampledTilesToTiles };
//# sourceMappingURL=image-service-Beuc1aSY.d.ts.map