{"version":3,"file":"store-B7swNE6p.js","names":["newResource: any","added: string[]","newFromItems: any[]","itemsToMove: any[]","toReturn: Entities","newEntities: any","entity: any","reducers","nextState: any","createStore","dv: typeof devtools","create"],"sources":["../node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/middleware.mjs","../src/vault/store/reducers/mapping-reducer.ts","../src/vault/utility/is-reference-list.ts","../src/vault/utility/quick-merge.ts","../src/vault/store/reducers/entities-reducer.ts","../src/vault/store/reducers/request-reducer.ts","../src/vault/store/reducers/meta-reducer.ts","../src/vault/utility/combine-reducers.ts","../src/vault/store/reducers/batch-reducer.ts","../src/vault/store/index.ts"],"sourcesContent":["const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api)\n    return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording)\n      return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState)\n              return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0)\n    f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","import { MappingActions, ADD_MAPPING, ADD_MAPPINGS } from '../../actions';\n\nexport const mappingReducer = (state: Record<string, string> = {}, action: MappingActions) => {\n  switch (action.type) {\n    case ADD_MAPPING:\n      return {\n        ...state,\n        [action.payload.id]: action.payload.type,\n      };\n\n    case ADD_MAPPINGS:\n      return {\n        ...state,\n        ...action.payload.mapping,\n      };\n    default:\n      return state;\n  }\n};\n","import { CompatibleStore } from '@iiif/parser';\n\nexport function isReferenceList(state: CompatibleStore['entities'], id: string, type: string, key: string) {\n  return !(\n    !state[type] ||\n    !state[type][id] ||\n    !(state[type][id] as any)[key] ||\n    !Array.isArray((state[type][id] as any)[key])\n  );\n}\n","export function quickMerge(a: any, b: any) {\n  const newResource: any = {};\n  const added: string[] = [];\n  for (const [key, value] of Object.entries(a || {})) {\n    added.push(key);\n    const bValue = (b || {})[key];\n    if (!bValue || bValue.length === 0) {\n      newResource[key] = value;\n      continue;\n    }\n    newResource[key] = bValue;\n  }\n  for (const [key, value] of Object.entries(b || {})) {\n    if (added.indexOf(key) !== -1) {\n      continue;\n    }\n    // merge.\n    newResource[key] = value;\n  }\n\n  return newResource;\n}\n","import { toRef } from '@iiif/parser';\nimport type { ActionType } from 'typesafe-actions';\nimport {\n  ADD_METADATA,\n  ADD_REFERENCE,\n  type EntityActions,\n  IMPORT_ENTITIES,\n  MODIFY_ENTITY_FIELD,\n  MOVE_ENTITIES,\n  MOVE_ENTITY,\n  moveEntity,\n  REMOVE_METADATA,\n  REMOVE_REFERENCE,\n  REORDER_ENTITY_FIELD,\n  REORDER_METADATA,\n  UPDATE_METADATA,\n  UPDATE_REFERENCE,\n} from '../../actions';\nimport type { Entities } from '../../types';\nimport { getDefaultEntities } from '../../utility';\nimport { isReferenceList } from '../../utility/is-reference-list';\nimport { quickMerge } from '../../utility/quick-merge';\n\nfunction payload<T extends { payload: any }>(action: T): T['payload'] {\n  return action.payload || {};\n}\n\nfunction findEntity(entity: any, property: string, resource: { id: string; type: keyof Entities; index?: number }) {\n  if (!entity[property] || !Array.isArray(entity[property])) {\n    return null;\n  }\n\n  const index =\n    typeof resource.index === 'undefined'\n      ? entity[property].findIndex((item: any) => {\n          if (!item) return false;\n          return toRef(item)?.id === resource.id;\n        })\n      : resource.index;\n\n  if (index === -1) {\n    return null;\n  }\n\n  return {\n    entity: entity[property][index],\n    index,\n  };\n}\n\nfunction getEntity(state: Entities, entity: { id: string; type: keyof Entities } | undefined | null) {\n  if (!entity?.id || !entity?.type) {\n    return;\n  }\n  return state[entity.type]?.[entity.id];\n}\n\nfunction numberOr(a: number | undefined, b: number): number {\n  return typeof a === 'undefined' ? b : a;\n}\n\nexport const entitiesReducer = (state: Entities = getDefaultEntities(), action: EntityActions): Entities => {\n  const updateField = (entity: any, values: any) => {\n    return {\n      ...state,\n      [(payload(action) as any).type]: {\n        ...((state as any)[(payload(action) as any).type] as any),\n        [(payload(action) as any).id]: {\n          ...entity,\n          ...values,\n        },\n      },\n    };\n  };\n\n  switch (action.type) {\n    case MODIFY_ENTITY_FIELD: {\n      // Invalid.\n      if (!state[payload(action).type] || !state[payload(action).type][payload(action).id]) {\n        return state;\n      }\n\n      const entity = state[payload(action).type][payload(action).id];\n      if (typeof entity === 'string') {\n        return state;\n      }\n\n      return updateField(entity, {\n        [payload(action).key]: payload(action).value,\n      });\n    }\n    case REORDER_ENTITY_FIELD: {\n      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {\n        return state;\n      }\n\n      const entity = state[payload(action).type][payload(action).id];\n      if (typeof entity === 'string') {\n        return state;\n      }\n\n      const result = Array.from(entity[payload(action).key]);\n      const [removed] = result.splice(payload(action).startIndex, 1);\n      result.splice(payload(action).endIndex, 0, removed);\n\n      return updateField(entity, { [payload(action).key]: result });\n    }\n    case MOVE_ENTITIES: {\n      const subjects = payload(action).subjects;\n      const from = payload(action).from;\n      const to = payload(action).to || from;\n      const fromEntity = getEntity(state, from);\n      const toKey = to?.key || from.key;\n\n      if (!isReferenceList(state, from.id, from.type, from.key) || !isReferenceList(state, to.id, to.type, to.key)) {\n        return state;\n      }\n\n      let newFromItems: any[] = [];\n      let itemsToMove: any[] = [];\n\n      if (subjects.type === 'slice') {\n        // Is there a fast path here.\n        const startIndex = subjects.startIndex;\n        const length = subjects.length;\n\n        newFromItems = Array.from(fromEntity[from.key]);\n        itemsToMove = newFromItems.splice(startIndex, length);\n      } else {\n        const newFromItemsWithNulls = Array.from(fromEntity[from.key]);\n        for (const subject of subjects.items) {\n          const foundFrom = findEntity(fromEntity, from.key, subject);\n          if (foundFrom) {\n            itemsToMove.push(foundFrom.entity);\n            newFromItemsWithNulls[foundFrom.index] = null;\n          }\n          newFromItems = newFromItemsWithNulls.filter((item) => item !== null);\n        }\n      }\n\n      const fromEntityWithoutFoundItems = {\n        ...fromEntity,\n        [from.key]: newFromItems,\n      };\n\n      const stateWithUpdatedFrom = {\n        ...state,\n        [from.type]: {\n          ...state[from.type],\n          [from.id]: fromEntityWithoutFoundItems,\n        },\n      };\n\n      const toEntity = getEntity(stateWithUpdatedFrom, to);\n\n      if (!toEntity) {\n        return state; // Hoepfully not!\n      }\n\n      const toIndex = typeof to?.index === 'undefined' ? toEntity[toKey].length : to.index;\n\n      const newToItems = Array.from(toEntity[to.key]);\n      newToItems.splice(toIndex, 0, ...itemsToMove);\n      const toEntityWithItem = {\n        ...toEntity,\n        [toKey]: newToItems,\n      };\n\n      const withUpdatedTo = {\n        ...stateWithUpdatedFrom,\n        [to.type]: {\n          ...stateWithUpdatedFrom[to.type],\n          [to.id]: toEntityWithItem,\n        },\n      };\n\n      return withUpdatedTo;\n    }\n\n    case MOVE_ENTITY: {\n      return entitiesReducer(state, {\n        type: MOVE_ENTITIES,\n        payload: {\n          subjects: { type: 'list', items: [payload(action).subject] },\n          from: payload(action).from,\n          to: payload(action).to,\n        },\n      });\n    }\n    case IMPORT_ENTITIES: {\n      const keys = Object.keys(payload(action).entities) as Array<keyof Entities>;\n      const toReturn: Entities = { ...state };\n\n      for (const key of keys) {\n        const entities = payload(action).entities[key];\n        const newEntities: any = { ...(state[key] || {}) };\n        let changed = false;\n        const ids = (Object.keys(entities || {}) as string[]) || [];\n        if (entities && ids) {\n          for (const id of ids) {\n            changed = true;\n            newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];\n          }\n          if (changed) {\n            toReturn[key] = newEntities as any;\n          }\n        }\n      }\n\n      return toReturn;\n    }\n\n    case ADD_REFERENCE: {\n      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {\n        return state;\n      }\n\n      const entity: any = state[payload(action).type][payload(action).id];\n      const result = Array.from(entity[payload(action).key]);\n      result.splice(numberOr(payload(action).index, result.length + 1), 0, payload(action).reference);\n\n      return updateField(entity, { [payload(action).key]: result });\n    }\n\n    case UPDATE_REFERENCE:\n    case REMOVE_REFERENCE: {\n      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {\n        return state;\n      }\n\n      const entity: any = state[payload(action).type][payload(action).id];\n      const result = Array.from(entity[payload(action).key]);\n      const indexToRemove = numberOr(\n        payload(action).index,\n        result.findIndex((e: any) => e && e.id === payload(action).reference.id)\n      );\n\n      if (indexToRemove === -1 || (result as any[])[indexToRemove]?.id !== payload(action).reference.id) {\n        // Nothing to remove.\n        return state;\n      }\n\n      if (action.type === UPDATE_REFERENCE) {\n        result.splice(indexToRemove, 1, payload(action).reference);\n      } else {\n        result.splice(indexToRemove, 1);\n      }\n\n      return updateField(entity, { [payload(action).key]: result });\n    }\n\n    case ADD_METADATA: {\n      const entity: any = state[payload(action).type][payload(action).id];\n      if (!entity) {\n        return state;\n      }\n      const metadata = Array.from(entity.metadata || []);\n      const actionPayload = payload(action);\n      metadata.splice(numberOr(action.payload.beforeIndex, metadata.length + 1), 0, {\n        label: actionPayload.label,\n        value: actionPayload.label,\n      });\n\n      return updateField(entity, { metadata });\n    }\n    case REORDER_METADATA: {\n      const entity: any = state[payload(action).type][payload(action).id];\n      if (typeof entity === 'string' || !entity) {\n        return state;\n      }\n\n      const metadata = Array.from(entity.metadata || []);\n      const [removed] = metadata.splice(payload(action).startIndex, 1);\n      metadata.splice(payload(action).endIndex, 0, removed);\n\n      return updateField(entity, { metadata });\n    }\n    case UPDATE_METADATA:\n    case REMOVE_METADATA: {\n      const entity = state[payload(action).type][payload(action).id];\n      const metadata = Array.from(entity.metadata || []);\n      const indexToRemove = payload(action).atIndex;\n\n      if (typeof indexToRemove === 'undefined' || indexToRemove === -1 || !(metadata as any[])[indexToRemove]) {\n        // Nothing to remove.\n        return state;\n      }\n\n      if (action.type === UPDATE_METADATA) {\n        metadata.splice(indexToRemove, 1, {\n          label: payload(action).label,\n          value: payload(action).value,\n        });\n      } else {\n        metadata.splice(indexToRemove, 1);\n      }\n\n      return updateField(entity, { metadata });\n    }\n\n    default:\n      return state;\n  }\n};\n","import {\n  RequestActions,\n  REQUEST_COMPLETE,\n  REQUEST_ERROR,\n  REQUEST_MISMATCH,\n  REQUEST_OFFLINE_RESOURCE,\n  REQUEST_RESOURCE,\n  RESOURCE_ERROR,\n  RESOURCE_LOADING,\n  RESOURCE_READY,\n} from '../../actions';\nimport { RequestState } from '../../types';\n\nexport const requestReducer = (state: RequestState = {}, action: RequestActions) => {\n  switch (action.type) {\n    case REQUEST_RESOURCE:\n    case REQUEST_OFFLINE_RESOURCE:\n      return {\n        ...state,\n        [action.payload.id]: {\n          requestUri: action.payload.id,\n          loadingState: RESOURCE_LOADING,\n          uriMismatch: false,\n          resourceUri: action.payload.id,\n        },\n      };\n\n    case REQUEST_MISMATCH:\n      return {\n        ...state,\n        [action.payload.requestId]: {\n          ...(state[action.payload.requestId] || {}),\n          uriMismatch: true,\n          resourceUri: action.payload.actualId,\n        },\n        [action.payload.actualId]: {\n          requestUri: action.payload.requestId,\n          loadingState: state[action.payload.requestId].loadingState,\n          uriMismatch: true,\n          resourceUri: action.payload.actualId,\n        },\n      };\n\n    case REQUEST_ERROR:\n      return {\n        ...state,\n        [action.payload.id]: {\n          ...(state[action.payload.id] || {}),\n          loadingState: RESOURCE_ERROR,\n          error: action.payload.message,\n        },\n      };\n\n    case REQUEST_COMPLETE:\n      return {\n        ...state,\n        [action.payload.id]: {\n          ...(state[action.payload.id] || {}),\n          loadingState: RESOURCE_READY,\n          error: undefined,\n        },\n      };\n  }\n  return state;\n};\n","import { MetaActions, SET_META_VALUE, SET_META_VALUE_DYNAMIC, UNSET_META_VALUE } from '../../actions';\n\ntype MetaState = Record<string, Record<string, Record<string, any>>>;\n\nexport const metaReducer = (state: MetaState = {}, action: MetaActions) => {\n  const { id, updateValue, value, meta, key } = ((action && action.payload) || {}) as any;\n  switch (action.type) {\n    case SET_META_VALUE: {\n      return {\n        ...state,\n        [id]: {\n          ...(state[id] || {}),\n          [meta]: {\n            ...(state[id] ? state[id][meta] || {} : {}),\n            [key]: value,\n          },\n        },\n      };\n    }\n    case SET_META_VALUE_DYNAMIC: {\n      return {\n        ...state,\n        [id]: {\n          ...(state[id] || {}),\n          [meta]: {\n            ...(state[id] ? state[id][meta] || {} : {}),\n            [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(undefined),\n          },\n        },\n      };\n    }\n\n    case UNSET_META_VALUE: {\n      if (state[id] && state[id][meta] && state[id][meta][key]) {\n        return {\n          ...state,\n          [id]: {\n            ...(state[id] || {}),\n            [meta]: {\n              ...(state[id] ? state[id][meta] || {} : {}),\n              [key]: undefined,\n            },\n          },\n        };\n      }\n      return state;\n    }\n\n    default:\n      return state;\n  }\n};\n","export function combineReducers(\n  reducers: Record<any, (state: any, action: any) => any> = {}\n): (state: any, action: any) => any {\n  const reducerKeys = Object.keys(reducers);\n  return function combination(state = {}, action) {\n    let hasChanged = false;\n    const nextState: any = {};\n    for (let i = 0; i < reducerKeys.length; i++) {\n      const key = reducerKeys[i];\n      nextState[key] = reducers[key](state[key], action);\n      hasChanged = hasChanged || nextState[key] !== state[key];\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n","import { BatchAction, BATCH_ACTIONS, BATCH_IMPORT } from '../../actions/batch-actions';\nimport { AllActions, IIIFStore, Reducer } from '../../types';\n\nexport function createBatchReducer(rootReducer: Reducer<IIIFStore, AllActions>) {\n  return (state: IIIFStore, action: BatchAction | AllActions) => {\n    if (action && action.type === BATCH_ACTIONS) {\n      return action.payload.actions.reduce(rootReducer, state);\n    }\n\n    if (action && action.type === BATCH_IMPORT) {\n      return {\n        ...state,\n        iiif: {\n          ...state.iiif,\n          ...action.payload.state,\n        },\n      } as IIIFStore;\n    }\n\n    return rootReducer(state, action);\n  };\n}\n","import { createStore as create } from 'zustand/vanilla';\nimport type { StoreApi } from 'zustand/vanilla';\nimport { redux, devtools, subscribeWithSelector } from 'zustand/middleware';\nimport { mappingReducer } from './reducers/mapping-reducer';\nimport { entitiesReducer } from './reducers/entities-reducer';\nimport { requestReducer } from './reducers/request-reducer';\nimport { metaReducer } from './reducers/meta-reducer';\nimport { combineReducers } from '../utility/combine-reducers';\nimport { AllActions, IIIFStore } from '../types';\nimport { BatchAction } from '../actions';\nimport { createBatchReducer } from './reducers/batch-reducer';\nimport { getDefaultEntities } from '../utility';\n\nexport const reducers = combineReducers({\n  mapping: mappingReducer,\n  entities: entitiesReducer,\n  requests: requestReducer,\n  meta: metaReducer,\n});\n\ntype CreateStoreOptions = {\n  enableDevtools?: boolean;\n  iiifStoreName?: string;\n  customReducers?: any;\n  defaultState?: any;\n};\n\nfunction getDefaultState(): IIIFStore {\n  return {\n    iiif: {\n      entities: getDefaultEntities(),\n      meta: {},\n      mapping: {},\n      requests: {},\n    },\n  };\n}\nexport type VaultStoreState = StoreApi<IIIFStore & { dispatch: (action: AllActions | BatchAction) => void }> & {\n  dispatch: (action: AllActions | BatchAction) => void;\n};\n\nexport function createStore(options: CreateStoreOptions = {}) {\n  const {\n    enableDevtools = false,\n    iiifStoreName = 'iiif',\n    defaultState = getDefaultState(),\n    customReducers = {},\n  } = options;\n\n  const rootReducer = createBatchReducer(combineReducers({ [iiifStoreName]: reducers, ...customReducers }));\n  const enabled = Boolean(typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__);\n  const dv: typeof devtools = !enabled || process.env.NODE_ENV === 'test' ? (a: any, r: any) => a : devtools;\n\n  return create(\n    //\n    subscribeWithSelector(\n      //\n      dv(\n        //\n        redux(rootReducer, defaultState),\n        { enabled: enableDevtools }\n      )\n    )\n  );\n}\n\nexport type VaultZustandStore = ReturnType<typeof createStore>;\n"],"x_google_ignoreList":[0],"mappings":"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"}