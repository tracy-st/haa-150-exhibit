{
  "version": 3,
  "sources": ["../../@iiif/helpers/src/events.ts", "../../@iiif/helpers/src/styles.ts", "../../@iiif/helpers/node_modules/.pnpm/@oxc-project+runtime@0.82.3/node_modules/@oxc-project/runtime/src/helpers/esm/typeof.js", "../../@iiif/helpers/node_modules/.pnpm/@oxc-project+runtime@0.82.3/node_modules/@oxc-project/runtime/src/helpers/esm/toPrimitive.js", "../../@iiif/helpers/node_modules/.pnpm/@oxc-project+runtime@0.82.3/node_modules/@oxc-project/runtime/src/helpers/esm/toPropertyKey.js", "../../@iiif/helpers/node_modules/.pnpm/@oxc-project+runtime@0.82.3/node_modules/@oxc-project/runtime/src/helpers/esm/defineProperty.js", "../../@iiif/helpers/node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/vanilla.mjs", "../../@iiif/helpers/node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs", "../../@iiif/parser/src/image-3/profiles/profiles.ts", "../../@iiif/parser/src/image-3/parser/parse-image-server-from-id.ts", "../../@iiif/parser/src/image-3/parser/parse-region-parameter.ts", "../../@iiif/parser/src/image-3/parser/parse-size-parameter.ts", "../../@iiif/parser/src/image-3/parser/parse-rotation-parameter.ts", "../../@iiif/parser/src/image-3/parser/parse-image-service-url.ts", "../../@iiif/parser/src/image-3/parser/parse-image-service-request.ts", "../../@iiif/parser/src/image-3/profiles/level-to-profile.ts", "../../@iiif/parser/src/image-3/profiles/combine-profiles.ts", "../../@iiif/parser/src/image-3/profiles/is-level-0.ts", "../../@iiif/parser/src/image-3/utilities/get-id.ts", "../../@iiif/parser/src/image-3/utilities/is-image-service.ts", "../../@iiif/parser/src/image-3/profiles/supports.ts", "../../@iiif/parser/src/image-3/profiles/supports-custom-sizes.ts", "../../@iiif/parser/src/image-3/profiles/image-service-supports-format.ts", "../../@iiif/parser/src/image-3/profiles/image-service-supports-request.ts", "../../@iiif/parser/src/image-3/serialize/region-parameter-to-string.ts", "../../@iiif/parser/src/image-3/serialize/size-parameter-to-string.ts", "../../@iiif/parser/src/image-3/serialize/rotation-parameter-to-string.ts", "../../@iiif/parser/src/image-3/serialize/image-service-request-to-string.ts", "../../@iiif/parser/src/image-3/serialize/image-service-request-info.ts", "../../@iiif/parser/src/image-3/utilities/canonical-service-url.ts", "../../@iiif/parser/src/image-3/utilities/create-image-service-request.ts", "../../@iiif/parser/src/image-3/utilities/extract-fixed-size-scales.ts", "../../@iiif/parser/src/image-3/utilities/fixed-sizes-from-scales.ts", "../../@iiif/parser/src/image-3/utilities/is-image-service-level.ts", "../../@iiif/parser/src/image-3/utilities/get-image-service-level.ts", "../../@iiif/parser/src/image-3/utilities/get-image-services.ts", "../../@iiif/parser/src/image-3/utilities/get-type.ts", "../../@iiif/parser/src/image-3/utilities/identify-image-server.ts", "../../@iiif/helpers/src/image-service/get-image-server-from-id.ts", "../../@iiif/helpers/src/image-service/sampled-tiles-to-tiles.ts", "../../@iiif/helpers/src/image-service/get-image-from-tile-source.ts", "../../@iiif/helpers/src/image-service/is-best-match.ts", "../../@iiif/helpers/src/image-service/pick-best-from-candidates.ts", "../../@iiif/helpers/src/image-service/is-image-3.ts", "../../@iiif/helpers/src/image-service/get-fixed-sizes-from-service.ts", "../../@iiif/helpers/src/image-service/get-custom-size-from-service.ts", "../../@iiif/helpers/src/image-service/get-image-candidates-from-service.ts", "../../@iiif/helpers/src/image-service/infer-size-from-url.ts", "../../@iiif/helpers/src/image-service/get-fixed-size-from-image.ts", "../../@iiif/helpers/src/image-service/get-image-candidates.ts", "../../@iiif/helpers/src/image-service/image-sizes-match.ts", "../../@iiif/helpers/src/image-service/image-service-loader.ts", "../../@iiif/helpers/src/image-service/image-service-store.ts", "../../@iiif/helpers/src/image-service/get-smallest-scale-factor-as-single-image.ts", "../../@iiif/helpers/src/thumbnail.ts", "../../@iiif/parser/node_modules/.pnpm/@oxc-project+runtime@0.81.0/node_modules/@oxc-project/runtime/src/helpers/esm/typeof.js", "../../@iiif/parser/node_modules/.pnpm/@oxc-project+runtime@0.81.0/node_modules/@oxc-project/runtime/src/helpers/esm/toPrimitive.js", "../../@iiif/parser/node_modules/.pnpm/@oxc-project+runtime@0.81.0/node_modules/@oxc-project/runtime/src/helpers/esm/toPropertyKey.js", "../../@iiif/parser/node_modules/.pnpm/@oxc-project+runtime@0.81.0/node_modules/@oxc-project/runtime/src/helpers/esm/defineProperty.js", "../../@iiif/parser/src/shared/ensure-array.ts", "../../@iiif/parser/src/shared/remove-undefined-properties.ts", "../../@iiif/parser/src/shared/is-specific-resource.ts", "../../@iiif/parser/src/shared/compose.ts", "../../@iiif/parser/src/presentation-3/traverse.ts", "../../@iiif/parser/src/presentation-2/traverse.ts", "../../@iiif/parser/src/shared/image-api-profiles.ts", "../../@iiif/parser/src/presentation-2/upgrader.ts", "../../@iiif/parser/src/shared/to-ref.ts", "../../@iiif/parser/src/presentation-3/utilities.ts", "../../@iiif/parser/src/presentation-3/empty-types.ts", "../../@iiif/parser/src/shared/expand-target.ts", "../../@iiif/parser/src/presentation-3/normalize.ts", "../../@iiif/parser/src/presentation-3/serialize.ts", "../../@iiif/parser/src/shared/compress-specific-resource.ts", "../../@iiif/parser/src/presentation-3/serialize-presentation-2.ts", "../../@iiif/parser/src/presentation-3/serialize-presentation-3.ts", "../../@iiif/helpers/src/i18n.ts", "../../@iiif/helpers/dist/chunk-B1_aTGT8.js", "../../@iiif/helpers/src/annotation-targets/bezier.ts", "../../@iiif/helpers/src/annotation-targets/css-selectors.ts", "../../@iiif/helpers/node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js", "../../@iiif/helpers/node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js", "../../@iiif/helpers/node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js", "../../@iiif/helpers/src/annotation-targets/normalize-svg.ts", "../../@iiif/helpers/src/annotation-targets/parse-selector.ts", "../../@iiif/helpers/src/annotation-targets/expand-target.ts", "../../@iiif/helpers/src/content-state.ts", "../../@iiif/helpers/src/shared-utilities.ts", "../../@iiif/helpers/src/ranges.ts", "../../@iiif/helpers/src/sequences.ts", "../../@iiif/helpers/src/vault/utility/typesafe-actions-runtime.ts", "../../@iiif/helpers/src/vault/actions/entity-actions.ts", "../../@iiif/helpers/src/vault/actions/mapping-actions.ts", "../../@iiif/helpers/src/vault/actions/request-actions.ts", "../../@iiif/helpers/src/vault/actions/batch-actions.ts", "../../@iiif/helpers/src/vault/actions/meta-actions.ts", "../../@iiif/helpers/src/vault/utility/action-list-from-resource.ts", "../../@iiif/helpers/src/vault/utility/are-inputs-equal.ts", "../../@iiif/helpers/src/vault/utility/resolve-if-exists.ts", "../../@iiif/helpers/src/vault/utility/is-promise.ts", "../../@iiif/helpers/src/vault/utility/create-fetch-helper.ts", "../../@iiif/helpers/src/vault/utility/get-default-entities.ts", "../../@iiif/helpers/node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/middleware.mjs", "../../@iiif/helpers/src/vault/store/reducers/mapping-reducer.ts", "../../@iiif/helpers/src/vault/utility/is-reference-list.ts", "../../@iiif/helpers/src/vault/utility/quick-merge.ts", "../../@iiif/helpers/src/vault/store/reducers/entities-reducer.ts", "../../@iiif/helpers/src/vault/store/reducers/request-reducer.ts", "../../@iiif/helpers/src/vault/store/reducers/meta-reducer.ts", "../../@iiif/helpers/src/vault/utility/combine-reducers.ts", "../../@iiif/helpers/src/vault/store/reducers/batch-reducer.ts", "../../@iiif/helpers/src/vault/store/index.ts", "../../@iiif/helpers/src/vault/utility/objects.ts", "../../@iiif/helpers/src/vault/utility/resolve-type.ts", "../../@iiif/helpers/src/vault/vault.ts", "../../@iiif/helpers/src/vault/utility/get-global.ts", "../../@iiif/helpers/src/vault/global-vault.ts", "../../@iiif/parser/src/upgrader.ts", "../../@iiif/helpers/src/fetch.ts", "../../@iiif/helpers/src/search1.ts", "../../@iiif/helpers/src/nav-date.ts"],
  "sourcesContent": ["import type { Reference } from '@iiif/presentation-3';\nimport { compatVault, CompatVault } from './compat';\n\nexport function createEventsHelper(vault: CompatVault = compatVault) {\n  return {\n    addEventListener<T>(\n      resource: Reference<any>,\n      event: string,\n      listener: (e: any, resource: T) => void,\n      scope?: string[]\n    ) {\n      if (!resource) {\n        return;\n      }\n\n      vault.setMetaValue<Array<{ callback: any; scope?: string[] }>>(\n        [resource.id, 'eventManager', event],\n        (registeredCallbacks) => {\n          const callbacks = registeredCallbacks || [];\n          for (const registered of callbacks) {\n            if (registered.callback === listener) {\n              // @todo check for scopes matching, very edge-case as scopes should be fixed.\n              return callbacks;\n            }\n          }\n          return [...callbacks, { callback: listener, scope }];\n        }\n      );\n\n      return listener;\n    },\n\n    removeEventListener<T>(resource: Reference<any>, event: string, listener: (e: any, resource: T) => void) {\n      if (!resource) {\n        return;\n      }\n      vault.setMetaValue<Array<{ callback: () => void; scope?: string[] }>>(\n        [resource.id, 'eventManager', event],\n        (registeredCallbacks) => {\n          return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);\n        }\n      );\n    },\n\n    getListenersAsProps(resourceOrId: string | Reference<any>, scope?: string[]) {\n      const resource = typeof resourceOrId === 'string' ? { id: resourceOrId } : resourceOrId;\n      if (!resource || !resource.id) {\n        return {};\n      }\n      const hooks = vault.getResourceMeta(resource.id, 'eventManager');\n      const props: any = {};\n      if (hooks && resource) {\n        for (const hook of Object.keys(hooks)) {\n          props[hook] = (e: any) => {\n            const fullResource = vault.get<any>(resource);\n            for (const { callback, scope: _scope } of hooks[hook] || []) {\n              if (!_scope || (scope && _scope.indexOf(scope) !== -1)) {\n                callback(e, fullResource);\n              }\n            }\n          };\n        }\n      }\n      return props;\n    },\n  };\n}\n", "import { Reference } from '@iiif/presentation-3';\nimport { compatVault, CompatVault } from './compat';\n\nexport type StyleDefinition = Record<string, any>;\n\nexport type StyledHelper<S extends StyleDefinition> = {\n  applyStyles<Style extends StyleDefinition = S>(resource: any, scope: string, styles: Style[string]): void;\n  getAppliedStyles<Style extends StyleDefinition = S>(resource: any): Style | undefined;\n};\n\nexport function createStylesHelper<S extends StyleDefinition>(vault: CompatVault = compatVault): StyledHelper<S> {\n  return {\n    applyStyles<Style extends StyleDefinition = S>(\n      resource: string | Reference<any>,\n      scope: string,\n      styles: Style[string]\n    ) {\n      const id = typeof resource === 'string' ? resource : resource.id;\n      return vault.setMetaValue<Style[string]>([id, 'styles', scope], styles);\n    },\n    getAppliedStyles<Style extends StyleDefinition = S>(resource: string | Reference<any>): Style | undefined {\n      const id = typeof resource === 'string' ? resource : resource.id;\n      return vault.getResourceMeta<{ styles: Style }, 'styles'>(id, 'styles');\n    },\n  };\n}\n", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };", "import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };", "import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };", "import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };", "const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n", "export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n", "export const STANFORD_IIIF_IMAGE_COMPLIANCE_0 = 'http://library.stanford.edu/iiif/image-api/compliance.html#level0';\nexport const STANFORD_IIIF_IMAGE_COMPLIANCE_1 = 'http://library.stanford.edu/iiif/image-api/compliance.html#level1';\nexport const STANFORD_IIIF_IMAGE_COMPLIANCE_2 = 'http://library.stanford.edu/iiif/image-api/compliance.html#level2';\nexport const STANFORD_IIIF_IMAGE_CONFORMANCE_0 = 'http://library.stanford.edu/iiif/image-api/conformance.html#level0';\nexport const STANFORD_IIIF_IMAGE_CONFORMANCE_1 = 'http://library.stanford.edu/iiif/image-api/conformance.html#level1';\nexport const STANFORD_IIIF_IMAGE_CONFORMANCE_2 = 'http://library.stanford.edu/iiif/image-api/conformance.html#level2';\nexport const STANFORD_IIIF_1_IMAGE_COMPLIANCE_0 =\n  'http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0';\nexport const STANFORD_IIIF_1_IMAGE_COMPLIANCE_1 =\n  'http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1';\nexport const STANFORD_IIIF_1_IMAGE_COMPLIANCE_2 =\n  'http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2';\nexport const STANFORD_IIIF_1_IMAGE_CONFORMANCE_0 =\n  'http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0';\nexport const STANFORD_IIIF_1_IMAGE_CONFORMANCE_1 =\n  'http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1';\nexport const STANFORD_IIIF_1_IMAGE_CONFORMANCE_2 =\n  'http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2';\nexport const IIIF_1_IMAGE_LEVEL_0 = 'http://iiif.io/api/image/1/level0.json';\nexport const IIIF_1_IMAGE_LEVEL_0_PROFILE = 'http://iiif.io/api/image/1/profiles/level0.json';\nexport const IIIF_1_IMAGE_LEVEL_1 = 'http://iiif.io/api/image/1/level1.json';\nexport const IIIF_1_IMAGE_LEVEL_1_PROFILE = 'http://iiif.io/api/image/1/profiles/level1.json';\nexport const IIIF_1_IMAGE_LEVEL_2 = 'http://iiif.io/api/image/1/level2.json';\nexport const IIIF_1_IMAGE_LEVEL_2_PROFILE = 'http://iiif.io/api/image/1/profiles/level2.json';\nexport const IIIF_2_IMAGE_LEVEL_0 = 'http://iiif.io/api/image/2/level0.json';\nexport const IIIF_2_IMAGE_LEVEL_0_PROFILE = 'http://iiif.io/api/image/2/profiles/level0.json';\nexport const IIIF_2_IMAGE_LEVEL_1 = 'http://iiif.io/api/image/2/level1.json';\nexport const IIIF_2_IMAGE_LEVEL_1_PROFILE = 'http://iiif.io/api/image/2/profiles/level1.json';\nexport const IIIF_2_IMAGE_LEVEL_2 = 'http://iiif.io/api/image/2/level2.json';\nexport const IIIF_2_IMAGE_LEVEL_2_PROFILE = 'http://iiif.io/api/image/2/profiles/level2.json';\nexport const IIIF_3_IMAGE_LEVEL_0 = 'level0';\nexport const IIIF_3_IMAGE_LEVEL_1 = 'level1';\nexport const IIIF_3_IMAGE_LEVEL_2 = 'level2';\n\n// Non-standard\nexport const IIIF_2_IMAGE_LEVEL_0_NO_JSON = 'http://iiif.io/api/image/2/level0';\nexport const IIIF_2_IMAGE_LEVEL_1_NO_JSON = 'http://iiif.io/api/image/2/level1';\nexport const IIIF_2_IMAGE_LEVEL_2_NO_JSON = 'http://iiif.io/api/image/2/level2';\n\nexport const level2Support = [\n  IIIF_2_IMAGE_LEVEL_2_NO_JSON,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_2,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_2,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_2,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_2,\n  IIIF_1_IMAGE_LEVEL_2,\n  IIIF_1_IMAGE_LEVEL_2_PROFILE,\n  IIIF_2_IMAGE_LEVEL_2,\n  IIIF_2_IMAGE_LEVEL_2_PROFILE,\n  IIIF_3_IMAGE_LEVEL_2,\n];\n\nexport const level1Support = [\n  ...level2Support,\n  IIIF_2_IMAGE_LEVEL_1_NO_JSON,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_1,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_1,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_1,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_1,\n  IIIF_1_IMAGE_LEVEL_1,\n  IIIF_1_IMAGE_LEVEL_1_PROFILE,\n  IIIF_2_IMAGE_LEVEL_1,\n  IIIF_2_IMAGE_LEVEL_1_PROFILE,\n  IIIF_3_IMAGE_LEVEL_1,\n];\n\nexport const imageServiceProfiles = [\n  IIIF_2_IMAGE_LEVEL_0_NO_JSON,\n  IIIF_2_IMAGE_LEVEL_1_NO_JSON,\n  IIIF_2_IMAGE_LEVEL_2_NO_JSON,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_0,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_1,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_2,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_0,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_1,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_2,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_0,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_1,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_2,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_0,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_1,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_2,\n  IIIF_1_IMAGE_LEVEL_0,\n  IIIF_1_IMAGE_LEVEL_0_PROFILE,\n  IIIF_1_IMAGE_LEVEL_1,\n  IIIF_1_IMAGE_LEVEL_1_PROFILE,\n  IIIF_1_IMAGE_LEVEL_2,\n  IIIF_1_IMAGE_LEVEL_2_PROFILE,\n  IIIF_2_IMAGE_LEVEL_0,\n  IIIF_2_IMAGE_LEVEL_0_PROFILE,\n  IIIF_2_IMAGE_LEVEL_1,\n  IIIF_2_IMAGE_LEVEL_1_PROFILE,\n  IIIF_2_IMAGE_LEVEL_2,\n  IIIF_2_IMAGE_LEVEL_2_PROFILE,\n  IIIF_3_IMAGE_LEVEL_0,\n  IIIF_3_IMAGE_LEVEL_1,\n  IIIF_3_IMAGE_LEVEL_2,\n];\n\nexport const level0Support = imageServiceProfiles;\n\nexport const onlyLevel0 = [\n  IIIF_2_IMAGE_LEVEL_0_NO_JSON,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_0,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_0,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_0,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_0,\n  IIIF_1_IMAGE_LEVEL_0,\n  IIIF_1_IMAGE_LEVEL_0_PROFILE,\n  IIIF_2_IMAGE_LEVEL_0,\n  IIIF_2_IMAGE_LEVEL_0_PROFILE,\n  IIIF_3_IMAGE_LEVEL_0,\n];\n\nexport type Profile = {\n  extraFormats: string[];\n  extraQualities: string[];\n  extraFeatures: ExtraFeature[];\n  maxArea?: number;\n  maxHeight?: number;\n  maxWidth?: number;\n};\n\nexport const level0: Profile = {\n  extraFormats: ['jpg'],\n  extraQualities: ['default'],\n  extraFeatures: ['sizeByWhListed'],\n};\n\nexport const level1: Profile = {\n  extraFormats: ['jpg'],\n  extraQualities: ['default'],\n  extraFeatures: [\n    'baseUriRedirect',\n    'cors',\n    'jsonldMediaType',\n    'regionByPx',\n    'regionSquare',\n    'sizeByWhListed',\n    'sizeByH',\n    'sizeByW',\n    'sizeByWh',\n\n    // 2.1\n    // 'sizeByPct', <-- Used to be supported in 2.1\n  ],\n};\n\nexport const level2: Profile = {\n  extraFormats: ['jpg', 'png'],\n  extraQualities: ['default'],\n  extraFeatures: [\n    'baseUriRedirect',\n    'cors',\n    'jsonldMediaType',\n    'regionByPct',\n    'regionByPx',\n    'regionSquare',\n    'rotationBy90s',\n    'sizeByWhListed',\n    'sizeByConfinedWh',\n    'sizeByH',\n    'sizeByPct',\n    'sizeByW',\n    'sizeByWh',\n\n    // 2.1\n    // 'sizeByDistortedWh', <-- Used to be supported in 2.1\n    // 'sizeByForcedWh', <-- Used to be supported in 2.1\n  ],\n};\n\nexport const extraFeatures = [\n  //\tThe base URI of the service will redirect to the image information document.\n  'baseUriRedirect',\n  //\tThe canonical image URI HTTP link header is provided on image responses.\n  'canonicalLinkHeader',\n  //\tThe CORS HTTP headers are provided on all responses.\n  'cors',\n  //\tThe JSON-LD media type is provided when requested.\n  'jsonldMediaType',\n  //\tThe image may be rotated around the vertical axis, resulting in a left-to-right mirroring of the content.\n  'mirroring',\n  //\tThe profile HTTP link header is provided on image responses.\n  'profileLinkHeader',\n  //\tRegions of the full image may be requested by percentage.\n  'regionByPct',\n  //\tRegions of the full image may be requested by pixel dimensions.\n  'regionByPx',\n  //\tA square region may be requested, where the width and height are equal to the shorter dimension of the full image.\n  'regionSquare',\n  //\tImage rotation may be requested using values other than multiples of 90 degrees.\n  'rotationArbitrary',\n  //\tImage rotation may be requested in multiples of 90 degrees.\n  'rotationBy90s',\n  //\tImage size may be requested in the form !w,h.\n  'sizeByConfinedWh',\n  //\tImage size may be requested in the form ,h.\n  'sizeByH',\n  //\tImages size may be requested in the form pct:n.\n  'sizeByPct',\n  //\tImage size may be requested in the form w,.\n  'sizeByW',\n  //\tImage size may be requested in the form w,h.\n  'sizeByWh',\n  //\tImage sizes prefixed with ^ may be requested.\n  'sizeUpscaling',\n\n  // 2.1.1 compat\n  'sizeByWhListed',\n  'sizeByDistortedWh',\n  'sizeByForcedWh',\n] as const;\n\nexport type ExtraFeature = typeof extraFeatures extends ReadonlyArray<infer ElementType> ? ElementType : never;\n", "/**\n * Get image server from ID.\n *\n * Normalises image service URLs to extract identity of the image server.\n *\n * @param url\n */\nexport function parseImageServerFromId(url: string): string {\n  // Strip off the protocol + www\n  const id = url.replace(/(https?:\\/\\/)?(www.)?/i, '');\n\n  // Strip off the path.\n  if (id.indexOf('/') !== -1) {\n    return id.split('/')[0]!;\n  }\n\n  // Return the id.\n  return id;\n}\n", "import { RegionParameter } from '../types';\n\nexport function parseRegionParameter(pathPart: string): RegionParameter {\n  try {\n    if (pathPart === 'full') {\n      return { full: true };\n    }\n    if (pathPart === 'square') {\n      return { square: true };\n    }\n\n    const percent = pathPart.startsWith('pct:');\n    const stringParts = pathPart.substr(percent ? 4 : 0).split(',');\n    const xywh = stringParts.map((part) => parseFloat(part));\n    return {\n      x: xywh[0],\n      y: xywh[1],\n      w: xywh[2],\n      h: xywh[3],\n      percent: percent,\n    };\n  } catch {\n    throw new Error(\"Expected 'full', 'square' or 'x,y,w,h'. Found \" + pathPart);\n  }\n}\n", "import { SizeParameter } from '../types';\n\nexport function parseSizeParameter(pathPart: string): SizeParameter {\n  const size: SizeParameter = {\n    upscaled: false,\n    max: false,\n    confined: false,\n  };\n\n  if (pathPart[0] === '^') {\n    size.upscaled = true;\n    pathPart = pathPart.slice(1);\n  }\n\n  if (pathPart === 'max' || pathPart === 'full') {\n    size.max = true;\n    size.serialiseAsFull = pathPart === 'full';\n    return size;\n  }\n\n  if (pathPart[0] === '!') {\n    size.confined = true;\n    pathPart = pathPart.slice(1);\n  }\n\n  if (pathPart[0] === 'p') {\n    size.percentScale = parseFloat(pathPart.slice(4));\n    return size;\n  }\n\n  const wh = pathPart.split(',').map((t) => t.trim());\n  if (wh.length) {\n    if (wh[0] !== '') {\n      size.width = parseInt(wh[0]!, 10);\n    }\n\n    if (wh[1] !== '') {\n      size.height = parseInt(wh[1]!, 10);\n    }\n  }\n\n  return size;\n}\n", "import { RotationParameter } from '../types';\n\nexport function parseRotationParameter(pathPart: string): RotationParameter {\n  const rotation: RotationParameter = { angle: 0 };\n  if (pathPart[0] === '!') {\n    rotation.mirror = true;\n    pathPart = pathPart.substr(1);\n  }\n\n  rotation.angle = parseFloat(pathPart) % 360;\n  if (Number.isNaN(rotation.angle)) {\n    throw new Error(`Invalid rotation ${pathPart}`);\n  }\n  return rotation;\n}\n", "export function parseImageServiceUrl(canonicalId: string, prefix = '') {\n  const parsedUrl = canonicalId.match(/^(([a-zA-Z]+):\\/\\/([^/]+))?((.*)+)/);\n  if (!parsedUrl) {\n    throw new Error(`Invalid or unknown input ${canonicalId}`);\n  }\n  const scheme = parsedUrl[2];\n  const server = parsedUrl[3];\n  let path = parsedUrl[4]!;\n  if (path[0] === '/') {\n    path = path.substring(1);\n  }\n  if (prefix.length > 0) {\n    if (prefix[0] === '/') {\n      prefix = prefix.substring(1);\n    }\n    if (prefix !== path.substring(0, prefix.length)) {\n      throw new Error(`Path does not start with prefix (path: ${path}, prefix: ${prefix})`);\n    }\n    path = path.substring(prefix.length);\n  }\n\n  return {\n    scheme,\n    server,\n    path,\n    prefix,\n  } as {\n    scheme: string;\n    server: string;\n    path: string;\n    prefix: string;\n  };\n}\n", "import { parseRegionParameter } from './parse-region-parameter';\nimport { parseSizeParameter } from './parse-size-parameter';\nimport { parseRotationParameter } from './parse-rotation-parameter';\nimport { ImageServiceImageRequest } from '../types';\nimport { parseImageServiceUrl } from './parse-image-service-url';\n\nexport function parseImageServiceRequest(input: string, _prefix = ''): ImageServiceImageRequest {\n  const { path, scheme, server, prefix } = parseImageServiceUrl(input, _prefix);\n\n  const parts = path.split('/').reverse();\n  const [fileName, rotation, size, region, ...others] = parts;\n  const identifier = others.reverse().filter(Boolean).join('/');\n\n  if (parts.length === 1 || fileName === '') {\n    // likely the server will want to redirect this\n    return { type: 'base', scheme, server, prefix, identifier };\n  }\n\n  if (fileName === 'info.json') {\n    const [, ...identifierParts] = parts;\n\n    return {\n      type: 'info',\n      scheme,\n      server,\n      prefix,\n      identifier: identifierParts.reverse().filter(Boolean).join('/'),\n    };\n  }\n\n  if (\n    typeof scheme === 'undefined' ||\n    typeof server === 'undefined' ||\n    typeof path === 'undefined' ||\n    typeof region === 'undefined' ||\n    typeof size === 'undefined' ||\n    typeof rotation === 'undefined' ||\n    typeof fileName === 'undefined'\n  ) {\n    throw new Error('Invalid image service URL');\n  }\n\n  const [quality = '', format = ''] = fileName.split('.');\n\n  return {\n    type: 'image',\n    scheme,\n    server,\n    prefix,\n    identifier,\n    originalPath: path,\n    region: parseRegionParameter(region),\n    size: parseSizeParameter(size),\n    rotation: parseRotationParameter(rotation),\n    quality,\n    format,\n  };\n}\n", "import { level0, level1, level1Support, level2, level2Support, Profile } from './profiles';\n\nexport function levelToProfile(levelProfile: string): Profile {\n  const isLevel2 = level2Support.indexOf(levelProfile) !== -1;\n  if (isLevel2) {\n    return level2;\n  }\n  const isLevel1 = level1Support.indexOf(levelProfile) !== -1;\n  if (isLevel1) {\n    return level1;\n  }\n\n  // The minimum.\n  return level0;\n}\n", "import { levelToProfile } from './level-to-profile';\nimport { Profile } from './profiles';\nimport { ImageService } from '@iiif/presentation-3';\n\nexport function combineProfiles(service: ImageService): Profile {\n  const profiles: any[] = service ? (Array.isArray(service.profile) ? service.profile : [service.profile]) : [];\n  const final: Profile = {\n    extraQualities: [],\n    extraFormats: [],\n    extraFeatures: [],\n  };\n\n  for (let profile of profiles) {\n    if (typeof profile === 'string') {\n      profile = levelToProfile(profile);\n    }\n\n    if (!profile) {\n      continue;\n    }\n\n    // Merging Image 2.1.1\n    if (profile.formats) {\n      for (const format of profile.formats) {\n        if (final.extraFormats.indexOf(format) === -1) {\n          final.extraFormats.push(format);\n        }\n      }\n    }\n    if (profile.qualities) {\n      for (const format of profile.qualities) {\n        if (final.extraQualities.indexOf(format) === -1) {\n          final.extraQualities.push(format);\n        }\n      }\n    }\n    if (profile.supports) {\n      for (const feature of profile.supports) {\n        if (final.extraFeatures.indexOf(feature as any) === -1) {\n          final.extraFeatures.push(feature as any);\n        }\n      }\n    }\n\n    if (profile.maxHeight) {\n      final.maxHeight = profile.maxHeight;\n    }\n    if (profile.maxWidth) {\n      final.maxWidth = profile.maxWidth;\n    }\n    if (profile.maxArea) {\n      final.maxArea = profile.maxArea;\n    }\n\n    // Merging Image 3.0\n    if (profile.extraFormats) {\n      for (const format of profile.extraFormats) {\n        if (final.extraFormats.indexOf(format) === -1) {\n          final.extraFormats.push(format);\n        }\n      }\n    }\n    if (profile.extraQualities) {\n      for (const format of profile.extraQualities) {\n        if (final.extraQualities.indexOf(format) === -1) {\n          final.extraQualities.push(format);\n        }\n      }\n    }\n    if (profile.extraFeatures) {\n      for (const feature of profile.extraFeatures) {\n        if (final.extraFeatures.indexOf(feature as any) === -1) {\n          final.extraFeatures.push(feature as any);\n        }\n      }\n    }\n\n    if (profile.maxHeight) {\n      final.maxHeight = profile.maxHeight;\n    }\n    if (profile.maxWidth) {\n      final.maxWidth = profile.maxWidth;\n    }\n    if (profile.maxArea) {\n      final.maxArea = profile.maxArea;\n    }\n  }\n\n  if (service.extraFormats) {\n    for (const format of service.extraFormats) {\n      if (final.extraFormats.indexOf(format) === -1) {\n        final.extraFormats.push(format);\n      }\n    }\n  }\n  if (service.extraFeatures) {\n    for (const feature of service.extraFeatures) {\n      if (final.extraFeatures.indexOf(feature as any) === -1) {\n        final.extraFeatures.push(feature as any);\n      }\n    }\n  }\n  if (service.extraQualities) {\n    for (const quality of service.extraQualities) {\n      if (final.extraQualities.indexOf(quality as any) === -1) {\n        final.extraQualities.push(quality as any);\n      }\n    }\n  }\n\n  return final;\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { onlyLevel0 } from './profiles';\n\nexport function isLevel0(service: ImageService) {\n  const profile = Array.isArray(service.profile) ? service.profile : [service.profile];\n\n  for (const single of profile) {\n    if (typeof single === 'string' && onlyLevel0.indexOf(single) !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "export function getId(resource: any) {\n  if (resource['@id']) {\n    return resource['@id'];\n  }\n\n  if (resource.id) {\n    return resource.id;\n  }\n\n  return undefined;\n}\n", "import { imageServiceProfiles } from '../profiles/profiles';\nimport { ImageService } from '@iiif/presentation-3';\nimport { getId } from './get-id';\n\nexport function isImageService(service: any): service is ImageService {\n  if (!service || !service.profile) {\n    return false;\n  }\n\n  if (!getId(service)) {\n    return false;\n  }\n\n  const profiles = Array.isArray(service.profile) ? service.profile : [service.profile];\n\n  for (const profile of profiles) {\n    if (typeof profile === 'string' && imageServiceProfiles.indexOf(profile) !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { extraFeatures, Profile } from './profiles';\nimport { isImageService } from '../utilities/is-image-service';\nimport { combineProfiles } from './combine-profiles';\n\nexport function supports(\n  service: ImageService,\n  req: Partial<Profile> & { exactSize?: { width?: number; height?: number } }\n) {\n  if (!isImageService(service)) {\n    return [false, 'Not a valid image service'] as const;\n  }\n\n  req.extraFeatures = req.extraFeatures ? req.extraFeatures : [];\n\n  const combined = combineProfiles(service);\n\n  if (req.exactSize) {\n    let valid = false;\n    // 1. Check sizes.\n    if (service.sizes) {\n      for (const size of service.sizes) {\n        if (size.width && size.width === req.exactSize.width) {\n          if (extraFeatures.indexOf('sizeByW') !== -1) {\n            valid = true;\n          } else if (size.height && size.height === req.exactSize.height) {\n            valid = true;\n          }\n        }\n        if (size.height && size.height === req.exactSize.height) {\n          if (extraFeatures.indexOf('sizeByH') !== -1) {\n            valid = true;\n          } else if (size.width && size.width === req.exactSize.width) {\n            valid = true;\n          }\n        }\n      }\n    }\n\n    if (!valid) {\n      req.maxWidth = Math.max(req.maxWidth || 0, req.exactSize.width || 0) || undefined;\n      req.maxHeight = Math.max(req.maxHeight || 0, req.exactSize.height || 0) || undefined;\n      req.maxArea =\n        Math.max(\n          req.maxArea || 0,\n          (req.exactSize.width && req.exactSize.height ? req.exactSize.width * req.exactSize.height : req.maxArea) || 0\n        ) || undefined;\n\n      if (!req.exactSize.height && req.exactSize.width) {\n        if (req.extraFeatures.indexOf('sizeByW') === -1) {\n          req.extraFeatures.push('sizeByW');\n        }\n      } else if (!req.exactSize.width && req.exactSize.height) {\n        if (req.extraFeatures.indexOf('sizeByH') === -1) {\n          req.extraFeatures.push('sizeByH');\n        }\n      }\n    }\n  }\n\n  if (req.maxArea && combined.maxArea && req.maxArea > combined.maxArea) {\n    return [false, `Max area is ${combined.maxArea}`] as const;\n  }\n\n  if (req.maxWidth && combined.maxWidth && req.maxWidth > combined.maxWidth) {\n    return [false, `Max width is ${combined.maxWidth}`] as const;\n  }\n\n  if (req.maxHeight && combined.maxHeight && req.maxHeight > combined.maxHeight) {\n    return [false, `Max height is ${combined.maxHeight}`] as const;\n  }\n\n  if (req.extraFeatures) {\n    const missingFeatures = [];\n    for (const feature of req.extraFeatures) {\n      if (combined.extraFeatures.indexOf(feature) === -1) {\n        missingFeatures.push(feature);\n      }\n    }\n    if (missingFeatures.length) {\n      return [false, `Missing features: ${missingFeatures.join(', ')}`] as const;\n    }\n  }\n\n  if (req.extraFormats) {\n    const missingFormats = [];\n    for (const feature of req.extraFormats) {\n      if (combined.extraFormats.indexOf(feature) === -1) {\n        missingFormats.push(feature);\n      }\n    }\n    if (missingFormats.length) {\n      return [false, `Missing formats: ${missingFormats.join(', ')}`] as const;\n    }\n  }\n\n  if (req.extraQualities) {\n    const missingQualities = [];\n    for (const quality of req.extraQualities) {\n      if (combined.extraQualities.indexOf(quality) === -1) {\n        missingQualities.push(quality);\n      }\n    }\n    if (missingQualities.length) {\n      return [false, `Missing qualities: ${missingQualities.join(', ')}`] as const;\n    }\n  }\n\n  return [true] as const;\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { isImageService } from '../utilities/is-image-service';\nimport { level1Support, Profile } from './profiles';\n\nexport function supportsCustomSizes(service: ImageService): boolean {\n  if (!isImageService(service)) {\n    return false;\n  }\n\n  const profiles = Array.isArray(service.profile) ? service.profile : [service.profile];\n\n  for (const profile of profiles) {\n    if (typeof profile === 'string') {\n      if (level1Support.indexOf(profile) !== -1) {\n        return true;\n      }\n    } else {\n      const supports = [...(profile.supports || []), ...((profile as Profile).extraFeatures || [])];\n      if (\n        supports.indexOf('regionByPx') !== -1 &&\n        (supports.indexOf('sizeByW') !== -1 || supports.indexOf('sizeByWh') !== -1)\n      ) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { supports } from './supports';\n\nexport function imageServiceSupportsFormat(imageService: ImageService, format: string) {\n  return supports(imageService, {\n    extraFormats: [format],\n  });\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { ImageServiceImageRequest } from '../types';\nimport { supports } from './supports';\nimport { ExtraFeature } from './profiles';\n\nexport function imageServiceSupportsRequest(imageService: ImageService, request: ImageServiceImageRequest) {\n  if (request.type !== 'image') {\n    return [true];\n  }\n\n  const extraFeatures: ExtraFeature[] = [];\n\n  if (request.rotation.mirror) {\n    extraFeatures.push('mirroring');\n  }\n\n  if (request.region.percent) {\n    extraFeatures.push('regionByPct');\n  }\n\n  if (request.region.square) {\n    extraFeatures.push('regionSquare');\n  } else if (!request.region.full) {\n    extraFeatures.push('regionByPx');\n  }\n\n  if (request.rotation.angle) {\n    const remainder = request.rotation.angle % 90;\n    if (remainder) {\n      extraFeatures.push('rotationArbitrary');\n    } else {\n      extraFeatures.push('rotationBy90s');\n    }\n  }\n\n  if (request.size.confined) {\n    extraFeatures.push('sizeByConfinedWh');\n  }\n\n  if (!request.size.width && request.size.height) {\n    extraFeatures.push('sizeByH');\n  }\n\n  if (request.size.percentScale) {\n    extraFeatures.push('sizeByPct');\n  }\n\n  // Could we bail, and check sizes instead?\n  const fixedSize = (imageService.sizes || []).find(\n    (size) =>\n      (size.width === request.size.width && !request.size.height) ||\n      (size.height === request.size.height && !request.size.width) ||\n      (size.height === request.size.height && size.width === request.size.width)\n  );\n  if (fixedSize) {\n    extraFeatures.push('sizeByWhListed');\n  } else {\n    if (request.size.width && !request.size.height) {\n      extraFeatures.push('sizeByW');\n    }\n\n    if (request.size.width && request.size.height) {\n      extraFeatures.push('sizeByWh');\n    }\n  }\n\n  if (request.size.upscaled) {\n    extraFeatures.push('sizeUpscaling');\n  }\n\n  const [doesSupport, reason] = supports(imageService, {\n    extraFeatures,\n    extraQualities: [request.quality],\n    extraFormats: [request.format],\n    exactSize: request.size,\n  });\n\n  if (doesSupport) {\n    return [true] as const;\n  }\n\n  return [false, reason] as const;\n}\n", "import { RegionParameter } from '../types';\n\nexport function regionParameterToString({ x = 0, y = 0, w, h, full, square, percent }: RegionParameter) {\n  if (full) {\n    return 'full';\n  }\n\n  if (square) {\n    return 'square';\n  }\n\n  if (typeof w === 'undefined' || typeof h === 'undefined') {\n    throw new Error('RegionParameter: invalid region');\n  }\n\n  const xywh = `${x},${y},${w},${h}`;\n  if (percent) {\n    return `pct:${xywh}`;\n  }\n\n  return xywh;\n}\n", "import { SizeParameter } from '../types';\n\nexport function sizeParameterToString({\n  max,\n  percentScale,\n  upscaled,\n  confined,\n  width,\n  height,\n  serialiseAsFull,\n  version,\n}: SizeParameter): string {\n  const sb: string[] = [];\n\n  if (upscaled) {\n    sb.push('^');\n  }\n\n  if (max) {\n    sb.push(serialiseAsFull ? 'full' : 'max');\n    return sb.join('');\n  }\n\n  if (confined) {\n    sb.push('!');\n  }\n\n  if (percentScale) {\n    sb.push(`pct:${percentScale}`);\n  }\n\n  if (width) {\n    sb.push(`${width}`);\n  }\n\n  sb.push(',');\n\n  if (height && version === 3) {\n    sb.push(`${height}`);\n  }\n\n  return sb.join('');\n}\n", "import { RotationParameter } from '../types';\n\nexport function rotationParameterToString(rotationParameter: RotationParameter) {\n  return `${rotationParameter.mirror ? '!' : ''}${(rotationParameter.angle || 0) % 360}`;\n}\n", "import { ImageServiceImageRequest } from '../types';\nimport { regionParameterToString } from './region-parameter-to-string';\nimport { sizeParameterToString } from './size-parameter-to-string';\nimport { rotationParameterToString } from './rotation-parameter-to-string';\nimport { ImageService } from '@iiif/presentation-3';\n\nexport function imageServiceRequestToString(req: ImageServiceImageRequest, service?: ImageService): string {\n  const prefix = req.prefix.startsWith('/') ? req.prefix.substring(1) : req.prefix;\n  const baseUrl = `${req.scheme}://${req.server}/${prefix ? `${prefix}/` : ''}${req.identifier}`;\n\n  if (req.type === 'base') {\n    return baseUrl;\n  }\n\n  if (req.type === 'info') {\n    return `${baseUrl}/info.json`;\n  }\n\n  let { size } = req;\n  const { region, rotation, format, quality } = req;\n\n  if (service) {\n    // Service specific changes.\n    const ctx = service['@context']\n      ? Array.isArray(service['@context'])\n        ? service['@context']\n        : [service['@context']]\n      : [];\n    const is2 = ctx.indexOf('http://iiif.io/api/image/2/context.json') !== -1;\n    const is3 = ctx.indexOf('http://iiif.io/api/image/3/context.json') !== -1;\n\n    // max size, for canonical.\n    if (\n      (size.width === service.width && !size.height) ||\n      (size.height === service.height && !size.width) ||\n      (size.width === service.width && size.height === service.height)\n    ) {\n      size = { ...size, max: true };\n    }\n\n    if (is2) {\n      if (size.max && !size.serialiseAsFull) {\n        size = { ...size, serialiseAsFull: true };\n      }\n\n      if (!size.max && size.width && size.height) {\n        size = { ...size, height: undefined };\n      }\n\n      size = { ...size, version: 2 };\n    }\n    if (is3) {\n      if (size.max && size.serialiseAsFull) {\n        size = { ...size, serialiseAsFull: false };\n      }\n\n      if (size.width && !size.height && service.width && service.height) {\n        // canonical requires height.\n        const ratio = service.height / service.width;\n        size = { ...size, height: Math.ceil(size.width * ratio) };\n      }\n\n      size = { ...size, version: 3 };\n    }\n\n    // @todo FUTURE - possibly passing in a correct=true option\n    // 1. Closeness/rounding to fixed size\n    // 2. Fallback to supported format.\n    // 3. Round to rotation\n  }\n\n  return [\n    baseUrl,\n    regionParameterToString(region),\n    sizeParameterToString(size),\n    rotationParameterToString(rotation),\n    `${quality}.${format}`,\n  ]\n    .filter(Boolean)\n    .join('/');\n}\n", "import { ImageService } from \"@iiif/presentation-3\";\nimport { ImageServiceImageRequest } from \"../types\";\nimport { imageServiceRequestToString } from \"./image-service-request-to-string\";\n\nexport function imageServiceRequestInfo(req: ImageServiceImageRequest, service?: ImageService): string {\n  return imageServiceRequestToString({ ...req, type: 'info' }, service);\n}", "/**\n * Get canonical service url\n * Ensures an image service id contains the /info.json on the end of it.\n *\n * @param serviceId\n */\nexport function canonicalServiceUrl(serviceId: string) {\n  return serviceId.endsWith('info.json')\n    ? serviceId\n    : serviceId.endsWith('/')\n    ? `${serviceId}info.json`\n    : `${serviceId}/info.json`;\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { ImageServiceImageRequest } from '../types';\nimport { combineProfiles } from '../profiles/combine-profiles';\nimport { parseImageServiceRequest } from '../parser/parse-image-service-request';\nimport { canonicalServiceUrl } from './canonical-service-url';\n\nexport function createImageServiceRequest(imageService: ImageService): ImageServiceImageRequest {\n  const parsed = parseImageServiceRequest(canonicalServiceUrl(imageService.id));\n  if (parsed.type !== 'info') {\n    throw new Error('Invalid service URL');\n  }\n\n  const features = combineProfiles(imageService);\n\n  return {\n    identifier: parsed.identifier,\n    originalPath: '',\n    server: parsed.server,\n    prefix: parsed.prefix,\n    scheme: parsed.scheme,\n    type: 'image',\n    quality: features.extraQualities.indexOf('default') === -1 ? features.extraQualities[0]! : 'default',\n    region: {\n      full: true,\n    },\n    size: {\n      max: true,\n      upscaled: false,\n      confined: false,\n    },\n    format: 'jpg',\n    rotation: {\n      angle: 0,\n    },\n  };\n}\n", "import { ImageSize } from '@iiif/presentation-3';\n\n/**\n * Extract fixed size scales\n *\n * Given a source width and height and a list of sizes of that same image,\n * it will return an ordered list of scales.\n *\n * @param width\n * @param height\n * @param sizes\n */\nexport function extractFixedSizeScales(width: number, height: number, sizes: ImageSize[]): number[] {\n  const len = sizes.length;\n  const scales = [];\n  for (let i = 0; i < len; i++) {\n    const size = sizes[i];\n    if (!size) continue;\n    const w = size.width;\n    scales.push(width / w);\n  }\n  return scales;\n}\n", "import { ImageSize } from '@iiif/presentation-3';\n\n/**\n * Fixed sizes from scales.\n *\n * Given a width and height of an image and a list of scales, this will return\n * an ordered list of widths and heights of the image at those scales.\n *\n * @param width\n * @param height\n * @param scales\n */\nexport function fixedSizesFromScales(width: number, height: number, scales: number[]): ImageSize[] {\n  const len = scales.length;\n  const sizes: ImageSize[] = [];\n  for (let i = 0; i < len; i++) {\n    const scale = scales[i];\n    if (!scale) continue;\n    sizes.push({\n      width: Math.floor(width / scale),\n      height: Math.floor(height / scale),\n    });\n  }\n  return sizes;\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { level1Support, level2Support, onlyLevel0 } from '../profiles/profiles';\n\nexport function isImageServiceLevel(level: 0 | 1 | 2, imageService?: ImageService) {\n  if (imageService && imageService.profile) {\n    const profile = imageService.profile;\n    if (profile) {\n      const profileArray = Array.isArray(profile) ? profile : [profile];\n\n      if (\n        profileArray.includes(`level${level}`) ||\n        profileArray.includes(`http://iiif.io/api/image/2/level${level}.json`) ||\n        profileArray.includes(`http://iiif.io/api/image/1/level${level}.json`) ||\n        profileArray.includes(`http://iiif.io/api/image/1/profiles/level${level}.json`)\n      ) {\n        return true;\n      }\n\n      if (level === 2) {\n        for (let singleProfile of profileArray) {\n          if (level2Support.includes(singleProfile as string)) {\n            return true;\n          }\n        }\n      }\n\n      if (level === 1) {\n        for (let singleProfile of profileArray) {\n          if (level1Support.includes(singleProfile as string)) {\n            return true;\n          }\n        }\n      }\n\n      if (level === 0) {\n        for (let singleProfile of profileArray) {\n          if (onlyLevel0.includes(singleProfile as string)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { isImageServiceLevel } from './is-image-service-level';\nimport { isImageService } from './is-image-service';\n\nexport function getImageServiceLevel(service: ImageService): null | number {\n  if (!isImageService(service)) {\n    return null;\n  }\n  if (isImageServiceLevel(2, service)) {\n    return 2;\n  }\n  if (isImageServiceLevel(1, service)) {\n    return 1;\n  }\n  if (isImageServiceLevel(0, service)) {\n    return 0;\n  }\n  return null;\n}\n", "import { ImageService, Service } from '@iiif/presentation-3';\nimport { isImageService } from './is-image-service';\n\n/**\n * Given a resource, will return only the image services on that resource.\n *\n * @param resource\n */\nexport function getImageServices(resource: { service?: Array<Service> }): ImageService[] {\n  const services = resource.service ? (Array.isArray(resource.service) ? resource.service : [resource.service]) : [];\n  const totalServices = services.length;\n  const imageServices = [];\n  for (let i = 0; i < totalServices; i++) {\n    if (isImageService((services as ImageService[])[i])) {\n      imageServices.push(services[i]);\n    }\n  }\n  return imageServices as any;\n}\n", "export function getType(resource: any) {\n  if (resource['@type']) {\n    return resource['@type'];\n  }\n  if (resource.type) {\n    return resource.type;\n  }\n\n  return undefined;\n}\n", "/**\n * Get image server from ID.\n *\n * Normalises image service URLs to extract identity of the image server.\n *\n * @param url\n */\nexport function identifyImageServer(url: string): string {\n  // Strip off the protocol + www\n  const id = url.replace(/(https?:\\/\\/)?(www.)?/i, '');\n\n  // Strip off the path.\n  if (id.indexOf('/') !== -1) {\n    return id.split('/')[0]!;\n  }\n\n  // Return the id.\n  return id;\n}\n", "/**\n * Get image server from ID.\n *\n * Normalises image service URLs to extract identity of the image server.\n *\n * @param url\n */\nexport function getImageServerFromId(url: string): string {\n  // Strip off the protocol + www\n  const id = url.replace(/(https?:\\/\\/)?(www.)?/i, '');\n\n  // Strip off the path.\n  if (id.indexOf('/') !== -1) {\n    return id.split('/')[0]!;\n  }\n\n  // Return the id.\n  return id;\n}\n", "import { ImageTile } from '@iiif/presentation-3';\n\nexport function sampledTilesToTiles(width: number, height: number, sampledTiles: ImageTile[]): ImageTile[] {\n  const maxDim = width > height ? width : height;\n  const len = sampledTiles.length;\n  const newTiles: ImageTile[] = [];\n\n  for (let i = 0; i < len; i++) {\n    const tile = sampledTiles[i];\n    if (!tile) continue;\n    if (tile.scaleFactors.length === 0) continue;\n\n    let lastSize = tile.scaleFactors[0];\n    if (!lastSize) continue;\n\n    let curWidth = maxDim / lastSize;\n    const scaleFactors = [lastSize];\n    while (curWidth >= tile.width) {\n      lastSize = lastSize * 2;\n      scaleFactors.push(lastSize);\n      curWidth = curWidth / 2;\n    }\n\n    newTiles.push({\n      ...tile,\n      scaleFactors,\n    });\n  }\n\n  return newTiles;\n}\n", "import {\n  canonicalServiceUrl,\n  createImageServiceRequest,\n  getId,\n  imageServiceRequestToString,\n} from '@iiif/parser/image-3';\nimport { FixedSizeImage, FixedSizeImageService } from './types';\nimport { ImageProfile } from '@iiif/presentation-3';\n\nexport function getImageFromTileSource(\n  image: FixedSizeImageService,\n  targetWidth: number,\n  targetHeight?: number\n): FixedSizeImage {\n  // @todo this needs to determine levels 0, 1 + 2.\n  const req = createImageServiceRequest({\n    '@context':\n      image.version === 3 ? 'http://iiif.io/api/image/3/context.json' : 'http://iiif.io/api/image/2/context.json',\n    id: canonicalServiceUrl(getId(image)),\n    profile:\n      image.level === null || typeof image.level === 'undefined'\n        ? ('level0' as ImageProfile)\n        : (`level${image.level}` as ImageProfile),\n    type: image.version === 3 ? 'ImageService3' : 'ImageService2',\n  });\n\n  if (req.type !== 'image') {\n    throw new Error('Invalid service');\n  }\n\n  req.size.max = false;\n  req.size.width = targetWidth;\n  req.size.height = targetHeight;\n\n  const url = imageServiceRequestToString(req);\n\n  return {\n    id: url,\n    type: 'fixed',\n    width: targetWidth,\n    height: targetHeight || (image.height / (image.width || 1)) * targetWidth,\n    unsafe: image.width > targetWidth,\n  };\n}\n", "import { FixedSizeImage, ImageCandidateRequest } from './types';\n\nexport function isBestMatch(\n  request: Required<ImageCandidateRequest>,\n  current: FixedSizeImage | null,\n  candidate: FixedSizeImage\n) {\n  const width = !request.width ? request.maxWidth : request.width;\n\n  return (\n    candidate.height <= request.maxHeight &&\n    candidate.width <= request.maxWidth &&\n    candidate.height >= request.minHeight &&\n    candidate.width >= request.minWidth &&\n    (!current || Math.abs(candidate.width - width) < Math.abs(current.width - width))\n  );\n}\n", "import { getImageFromTileSource } from './get-image-from-tile-source';\nimport { isBestMatch } from './is-best-match';\nimport { FixedSizeImage, ImageCandidate, ImageCandidateRequest, UnknownSizeImage, VariableSizeImage } from './types';\n\n/**\n * Pick best from candidates\n *\n * Takes in a list of candidate lists. The order should be in preference. This algorithm will try to pick\n * from the first list, with a best fit size. If not it will fallback to the other lists. It may come back\n * around to the first list and provide a fallback.\n *\n * @param inputRequest\n * @param candidates\n */\nexport function pickBestFromCandidates(\n  inputRequest: ImageCandidateRequest,\n  candidates: Array<() => ImageCandidate[]>\n): { best: ImageCandidate | null; fallback: ImageCandidate[]; log: string[] } {\n  const log: string[] = [];\n  const request: Required<ImageCandidateRequest> = Object.assign(\n    {\n      unsafeImageService: false,\n      atAnyCost: true,\n      fallback: true,\n      minHeight: 64,\n      minWidth: 64,\n      maxHeight: Infinity,\n      maxWidth: Infinity,\n      returnAllOptions: false,\n      preferFixedSize: false,\n      allowUnsafe: false,\n      explain: false,\n      height: 0,\n      width: 0,\n    },\n    inputRequest\n  );\n  const explain = (text: () => string, indent = 0) =>\n    request.explain\n      ? log.push(\n          new Array(indent)\n            .fill(0)\n            .map((e) => '    ')\n            .join('') + text().trim()\n        )\n      : undefined;\n  const lastResorts: UnknownSizeImage[] = [];\n  const fallback: Array<FixedSizeImage | VariableSizeImage> = [];\n  let currentChoice: ImageCandidate | null = null;\n\n  explain(() => `Using configuration: ${JSON.stringify(request, null, 2)}`);\n\n  const swapChoice = (candidate: FixedSizeImage, current: FixedSizeImage | null) => {\n    explain(() => 'Swapping choice', 3);\n\n    if (isBestMatch(request, current, candidate)) {\n      // If we prefer a fixed size, we'll push it onto the fallback. But a fixed size will be looked for\n      // from all of the candidates.\n      if (request.preferFixedSize && candidate.unsafe) {\n        explain(() => `We found an image that was marked as unsafe, but it was the best size. (${candidate.id})`, 4);\n        fallback.push(candidate);\n        return;\n      }\n\n      if (request.returnAllOptions && current) {\n        fallback.push(current);\n      }\n      explain(() => `We found a new image that was the best size. (${candidate.id})`, 4);\n      // We have a new candidate.\n      currentChoice = candidate;\n    } else if (request.returnAllOptions) {\n      fallback.push(candidate);\n    }\n  };\n\n  explain(() => `The input shows we have ${candidates.length} list(s) of candidates to choose from.`);\n  const candidateGroups = candidates.length;\n  for (let x = 0; x < candidateGroups; x++) {\n    const group = candidates[x]!();\n\n    explain(() => `Candidate group ${x}: ${JSON.stringify(group, null, 2)}`, 1);\n\n    const candidatesLength = group.length;\n    explain(\n      () => `Checking candidate list number ${x} and found ${candidatesLength} potential ways of creating image(s)`,\n      1\n    );\n    for (let y = 0; y < candidatesLength; y++) {\n      const candidate = group[y]!;\n      explain(() => `-> Checking candidate ${y}`, 1);\n      if (candidate.type === 'unknown' && request.atAnyCost) {\n        explain(() => `We've found an unknown image type, adding this to the \"last resort\" list`, 2);\n        lastResorts.push(candidate);\n      }\n      if (candidate.type === 'fixed') {\n        if (candidate.unsafe) {\n          explain(() => `We've found an unsafe fixed image type, adding this to the \"last resort\" list`, 2);\n          lastResorts.push(candidate as any);\n        } else {\n          explain(() => `We've found a fixed size image, checking if it matches the request`, 2);\n          swapChoice(candidate, currentChoice);\n        }\n      }\n      if (candidate.type === 'fixed-service') {\n        if (request.unsafeImageService) {\n          // @todo fit within on request height/width based on candidate.\n          explain(\n            () =>\n              `Checking for an image from the tile source, without calculating the right height and width (unsafeImageService)`,\n            2\n          );\n          const choice = getImageFromTileSource(candidate, request.width, request.height);\n          swapChoice(choice, currentChoice);\n        } else {\n          explain(() => `Checking for an image from the tile source 3`, 2);\n          const choice = getImageFromTileSource(candidate, candidate.width, candidate.height);\n\n          swapChoice(choice, currentChoice);\n        }\n      }\n      if (candidate.type === 'variable') {\n        if (candidate.maxWidth) {\n          const choice = getImageFromTileSource(\n            {\n              id: candidate.id,\n              type: 'fixed-service',\n              width: candidate.maxWidth,\n              height: candidate.maxWidth,\n              level: candidate.level,\n              version: candidate.version,\n            },\n            candidate.maxWidth\n          );\n\n          swapChoice(choice, currentChoice);\n        }\n      }\n    }\n    if (currentChoice && !request.returnAllOptions) {\n      if ((currentChoice as any).unsafe || request.allowUnsafe) {\n        continue;\n      }\n\n      explain(() => `We found a match in choice list number ${x}, no searching any more`);\n      break;\n    }\n  }\n\n  if (request.atAnyCost && fallback.length === 0) {\n    explain(() =>\n      currentChoice\n        ? `We found an image! ${currentChoice.id} of type ${currentChoice.type}`\n        : `We found no images, but \"atAnyCost\" is set, so returning that`\n    );\n    return {\n      best: currentChoice || lastResorts[0] || null,\n      fallback: lastResorts.slice(1),\n      log,\n    };\n  }\n\n  if (request.returnAllOptions) {\n    explain(() => `Returning all options that we have found`);\n    return {\n      best: (request.atAnyCost ? currentChoice || fallback[0] || lastResorts[0] : currentChoice || fallback[0]) || null,\n      fallback: [...fallback, ...lastResorts],\n      log,\n    };\n  }\n\n  explain(() => `Returning the best image that we found, and a fallback`);\n\n  return {\n    best: currentChoice || fallback[0] || null,\n    fallback: currentChoice ? fallback : fallback.slice(1),\n    log,\n  };\n}\n", "export function isImage3(service: any) {\n  const context = service['@context']\n    ? Array.isArray(service['@context'])\n      ? service['@context']\n      : [service['@context']]\n    : [];\n  return context.indexOf('http://iiif.io/api/image/3/context.json') !== -1;\n}\n", "import { Service } from '@iiif/presentation-3';\nimport { FixedSizeImageService } from './types';\nimport { getId, isImageService, getImageServiceLevel } from '@iiif/parser/image-3';\nimport { isImage3 } from './is-image-3';\n\n/**\n * Get fixed sizes from service.\n *\n * Given an image service, this will extract the images from the sizes field of\n * the service. These are usually cached and great options for thumbnails.\n *\n * @param service\n */\nexport function getFixedSizesFromService(service: Service): FixedSizeImageService[] {\n  if (!isImageService(service)) {\n    return [];\n  }\n  return (service && service.sizes ? service.sizes : []).map((size: any) => {\n    return {\n      id: getId(service),\n      type: 'fixed-service',\n      height: size.height,\n      width: size.width,\n      level: getImageServiceLevel(service),\n      version: isImage3(service) ? 3 : 2,\n    };\n  });\n}\n", "import { ImageCandidate } from './types';\nimport { isImage3 } from './is-image-3';\nimport { ImageService } from '@iiif/presentation-3';\nimport { getId, supportsCustomSizes, getImageServiceLevel } from '@iiif/parser/image-3';\n\n/**\n * Get custom size from service\n *\n * Given an image service  usually a full one, de-referenced or embedded  this\n * will return a list of available image sizes (min and max width and height) that\n * can be used to construct a IIIF query to get an image at any size within those\n * bounds. This is only supported by some image services. If unsupported, this will\n * return an empty list.\n *\n * @param service\n */\nexport function getCustomSizeFromService(service: ImageService): ImageCandidate[] {\n  if (!supportsCustomSizes(service)) {\n    return [];\n  }\n\n  const imagesSizes: ImageCandidate[] = [];\n\n  // Check for max width in profile.\n  const profiles = Array.isArray(service.profile) ? service.profile : [service.profile];\n\n  const pLen = profiles.length;\n  for (let x = 0; x < pLen; x++) {\n    const profile = profiles[x];\n    if (profile && typeof profile !== 'string') {\n      if (profile.maxHeight || profile.maxWidth) {\n        return [\n          {\n            id: getId(service),\n            type: 'variable',\n            minWidth: 0,\n            minHeight: 0,\n            maxHeight: (profile.maxHeight || profile.maxWidth) as number,\n            maxWidth: (profile.maxWidth || profile.maxHeight) as number,\n            level: getImageServiceLevel(service),\n            version: service['@context'] === 'http://iiif.io/api/image/3/context.json' ? 3 : 2,\n          },\n        ];\n      }\n    }\n  }\n\n  if (service.tiles) {\n    const len = service.tiles.length;\n    for (let y = 0; y < len; y++) {\n      const tile = service.tiles[y];\n      if (tile && (tile.height || tile.width)) {\n        imagesSizes.push({\n          id: getId(service),\n          type: 'variable',\n          minHeight: 0,\n          minWidth: 0,\n          maxHeight: tile.height || tile.width,\n          maxWidth: tile.width,\n          level: getImageServiceLevel(service),\n          version: isImage3(service) ? 3 : 2,\n        });\n      }\n    }\n  }\n\n  return imagesSizes;\n}\n", "import { ImageService } from '@iiif/presentation-3';\nimport { ImageCandidate } from './types';\nimport { getFixedSizesFromService } from './get-fixed-sizes-from-service';\nimport { getCustomSizeFromService } from './get-custom-size-from-service';\n\nexport function getImageCandidatesFromService(service: ImageService[]): ImageCandidate[] {\n  const candidates: ImageCandidate[] = [];\n\n  const totalServices = service.length;\n  for (let s = 0; s < totalServices; s++) {\n    const single = service[s];\n    if (!single) continue;\n    // - x.2 embedded service - fixed sizes\n    const fixedSizes = getFixedSizesFromService(single);\n    if (fixedSizes.length) {\n      candidates.push(...fixedSizes);\n    }\n    // - x.3 embedded service - profile 1 / 2 (custom size)\n    const customSizes = getCustomSizeFromService(single);\n    if (customSizes.length) {\n      candidates.push(...customSizes);\n    }\n  }\n\n  return candidates;\n}\n", "import { ImageCandidate } from './types';\n\n/**\n * Extracts the height and width from an image URL\n *\n * @param image\n */\nexport function inferImageSizeFromUrl(image: string): ImageCandidate {\n  const regex = /^.*\\/(full)\\/(((\\d+),(\\d+)?)|max)\\/(\\d+)\\/default\\.(jpg|png|jpeg)$/;\n  const match = image.match(regex);\n\n  if (match && match[4] && match[5]) {\n    const region = match[1];\n    const width = parseInt(match[4], 10);\n    const height = parseInt(match[5], 10);\n    // const rotation = parseInt(match[6], 10);\n    const format = match[7];\n\n    if ((region === 'max' || region === 'full') && width && height && format) {\n      return {\n        type: 'fixed',\n        id: image,\n        height,\n        width,\n      };\n    }\n  }\n\n  return { type: 'unknown', id: image };\n}\n", "import { ContentResource, IIIFExternalWebResource } from '@iiif/presentation-3';\nimport { ImageCandidate } from './types';\nimport { inferImageSizeFromUrl } from './infer-size-from-url';\nimport { getId, getType } from '@iiif/parser/image-3';\n\n/**\n * Get fixed size from image\n *\n * Given a content resource, usually the body of a painting annotation, this will\n * return the URL to the image, and the height and width. The resource may also\n * be a string / direct link to the image. The height and width may be inferred from\n * a IIIF Image API endpoint, otherwise the return image candidate will have a type\n * of unknown.\n *\n * @param contentResource\n */\nexport function getFixedSizeFromImage(contentResource: ContentResource | string): ImageCandidate | null {\n  if (typeof contentResource === 'string') {\n    // Might not even be an image.\n    return inferImageSizeFromUrl(contentResource);\n  }\n\n  const type = getType(contentResource);\n  if (type !== 'Image' && type !== 'sc:Image') {\n    return null;\n  }\n\n  const image = contentResource as IIIFExternalWebResource;\n  const id = getId(image);\n\n  if (!id) {\n    return null;\n  }\n\n  if (id && image.width && image.height) {\n    return {\n      id: id,\n      type: 'fixed',\n      width: image.width,\n      height: image.height,\n      unsafe: true,\n    };\n  }\n\n  return inferImageSizeFromUrl(id);\n}\n", "import { ContentResource, IIIFExternalWebResource } from '@iiif/presentation-3';\nimport { ImageServiceLoader, ImageServiceRequest } from './image-service-loader';\nimport { ImageCandidate } from './types';\nimport { getImageCandidatesFromService } from './get-image-candidates-from-service';\nimport { getFixedSizeFromImage } from './get-fixed-size-from-image';\nimport { getId, getImageServices } from '@iiif/parser/image-3';\n\n/**\n * Get image candidates\n *\n * Given an unknown resource, and optionally an image service loader, it will\n * try to get all of the possible options for images at a specific size.\n *\n * Note: if you are wanting to depend on external web resources, then you have\n * to either preload these, or prepare the image loader for predicting them.\n *\n * @param unknownResource\n * @param dereference\n * @param loader\n */\nexport function getImageCandidates(\n  unknownResource: ContentResource,\n  dereference = true,\n  loader: ImageServiceLoader\n): ImageCandidate[] {\n  const candidates: ImageCandidate[] = [];\n  const fixedSizeFromImage = getFixedSizeFromImage(unknownResource);\n  if (fixedSizeFromImage === null) {\n    return candidates;\n  }\n  // Cast to IIIF resource, assuming we are working in that context.\n  const resource = unknownResource as IIIFExternalWebResource;\n\n  // - x.1 fixed size\n  // - x.4 ID of thumbnail (without width/height)\n  candidates.push(fixedSizeFromImage);\n\n  // We will try to dereference if available (cache or prediction).\n  if (dereference && resource && resource.width && resource.height) {\n    const refCandidates = [];\n    const imageServices = getImageServices(resource);\n    for (const service of imageServices) {\n      const request: ImageServiceRequest = {\n        id: getId(service),\n        width: resource.width,\n        height: resource.height,\n      };\n      if (loader.canLoadSync(request)) {\n        const externalService = loader.loadServiceSync(request);\n        if (externalService) {\n          if (!externalService.height) {\n            externalService.height = resource.height;\n          }\n          if (!externalService.width) {\n            externalService.width = resource.width;\n          }\n          refCandidates.push(...getImageCandidatesFromService([externalService]));\n        }\n      }\n    }\n\n    if (refCandidates.length) {\n      candidates.push(...refCandidates);\n      return candidates;\n    }\n  }\n\n  // Embedded service.\n  if (resource.service) {\n    candidates.push(...getImageCandidatesFromService(resource.service as any));\n  }\n\n  return candidates;\n}\n", "import { ImageSize } from '@iiif/presentation-3';\n\nexport function imageSizesMatch(sizesA: ImageSize[], sizesB: ImageSize[]): boolean {\n  if (sizesA.length !== sizesB.length) {\n    return false;\n  }\n\n  if (sizesA.length === 0 && sizesB.length === 0) {\n    return true;\n  }\n\n  const len = sizesA.length;\n  let matchOrder = true;\n  for (let i = 0; i < len; i++) {\n    const a = sizesA[i]!;\n    const b = sizesB[i]!;\n    if (a.width !== b.width || a.height !== b.height) {\n      matchOrder = false;\n      break;\n    }\n  }\n  if (matchOrder) {\n    return true;\n  }\n\n  let matching = 0;\n  for (let a = 0; a < len; a++) {\n    for (let b = 0; b < len; b++) {\n      if (sizesA[a]!.width === sizesB[b]!.width && sizesA[a]!.height === sizesB[b]!.height) {\n        matching++;\n        break;\n      }\n    }\n  }\n\n  return matching === len;\n}\n", "import {\n  isLevel0,\n  getId,\n  canonicalServiceUrl,\n  extractFixedSizeScales,\n  fixedSizesFromScales,\n  getImageServices,\n} from '@iiif/parser/image-3';\nimport {\n  ContentResource,\n  IIIFExternalWebResource,\n  ImageProfile,\n  ImageSize,\n  ImageTile,\n  ImageService,\n} from '@iiif/presentation-3';\nimport { getImageServerFromId } from './get-image-server-from-id';\nimport { sampledTilesToTiles } from './sampled-tiles-to-tiles';\nimport { ImageCandidate, ImageCandidateRequest } from './types';\nimport { pickBestFromCandidates } from './pick-best-from-candidates';\nimport { getImageCandidates } from './get-image-candidates';\nimport { imageSizesMatch } from './image-sizes-match';\n\nexport type ImageServer = {\n  root: string;\n  server: string | null; // @todo future enhancement (e.g. iipsrv, dlcs)\n  sampledId: string;\n  verifications: number;\n  verified: boolean;\n  preLoaded: boolean;\n  malformed: boolean;\n  result: {\n    context: string | string[];\n    resourceServiceRatio: number;\n    sampledSizes: ImageSize[];\n    sizeRatios: number[];\n    sampledTiles: ImageTile[];\n    sampledProfile: ImageProfile | ImageProfile[];\n  };\n};\n\nexport type ImageServiceRequest = {\n  id: string;\n  width: number;\n  height: number;\n  source?: ImageService;\n};\n\ntype LoadedImageService = ImageService & {\n  real: boolean;\n};\n\nexport type ImageServiceLoaderConfig = {\n  verificationsRequired: number;\n  approximateServices: boolean;\n  enableFetching: boolean;\n  disableThrottling: boolean;\n};\n\nexport class ImageServiceLoader {\n  constructor(options: Partial<ImageServiceLoaderConfig> = {}) {\n    this.config = Object.assign(this.config, options);\n  }\n\n  config: ImageServiceLoaderConfig = {\n    verificationsRequired: 1,\n    approximateServices: false,\n    enableFetching: true,\n    disableThrottling: false,\n  };\n\n  fetchingCount = 0;\n\n  imageServices: {\n    [k: string]: LoadedImageService;\n  } = {};\n\n  knownImageServers: {\n    [k: string]: ImageServer;\n  } = {};\n\n  /**\n   * Preload image service\n   *\n   * This will preload an image service, fetching details and recording the image server that served\n   * the request. Based on this it will make a template for predicting other image sources from this\n   * server. You can optionally pass in other ids to verify that the prediction is accurate.\n   *\n   */\n  // async preload(id: string, verify?: string[]): Promise<void> {}\n\n  setConfig(config: Partial<ImageServiceLoaderConfig>) {\n    Object.assign(this.config, config);\n  }\n\n  /**\n   * Sample pre-fetched service\n   *\n   * If you have already fetched an image service, or are creating a viewer that only talks to a single\n   * image server and want to avoid calls, you can sample a service up-front. This will allow you to make\n   * completely synchronous calls to `loadServiceSync` and avoid any network calls for image services.\n   *\n   * @param service\n   * @param preLoaded Mark this as being pre-loaded (default: true)\n   */\n  sample(service: ImageService, imageServiceRequest?: ImageServiceRequest, preLoaded = true) {\n    const server = getImageServerFromId(getId(service));\n    const serviceUrl = canonicalServiceUrl(getId(service));\n    const existing = this.knownImageServers[server];\n\n    this.imageServices[serviceUrl] = Object.assign(service, { real: true });\n\n    if (!existing && service.tiles && !isLevel0(service)) {\n      // Add new prediction.\n      this.knownImageServers[server] = {\n        verifications: 0,\n        malformed: false,\n        root: server,\n        preLoaded,\n        sampledId: getId(service),\n        verified: false,\n        server: null,\n        result: {\n          context: service['@context'] || [],\n          sampledProfile: service.profile,\n          resourceServiceRatio: imageServiceRequest && service.height ? imageServiceRequest.height / service.height : 1,\n          sampledSizes: service.sizes || [],\n          sizeRatios: extractFixedSizeScales(service.width as number, service.height as number, service.sizes || []),\n          sampledTiles: service.tiles || [],\n        },\n      };\n      return true;\n    }\n\n    return this.verify(service as ImageServiceRequest);\n  }\n\n  /**\n   * Preload an image server\n   *\n   * Similar to sample, but faster. This will bypass any checks and the logic contained in this implementation\n   * allowing you to correct mistakes this implementation might have made.\n   *\n   * @param server\n   * @param forceVerify\n   */\n  preLoad(server: ImageServer, forceVerify = true) {\n    this.knownImageServers[server.root] = server;\n    if (forceVerify) {\n      this.knownImageServers[server.root]!.malformed = false;\n      this.knownImageServers[server.root]!.verifications = this.config.verificationsRequired;\n    }\n  }\n\n  /**\n   * Predict\n   *\n   * Predicts what the image service will be for a content resource.\n   *\n   * @param resource\n   * @param verify\n   * @param force\n   */\n  predict(resource: ImageServiceRequest, verify = false, force = false): ImageService | null {\n    const source = resource?.source;\n    const serverId = getImageServerFromId(getId(resource));\n    const imageServer = this.knownImageServers[serverId];\n    const serviceUrl = canonicalServiceUrl(getId(resource));\n\n    if (this.imageServices[serviceUrl]) {\n      return this.imageServices[serviceUrl] || null;\n    }\n\n    if (!this.config.approximateServices) {\n      return null;\n    }\n\n    // No known image server.\n    if (\n      !imageServer ||\n      !imageServer.result ||\n      !(source?.height || resource.height) ||\n      !(source?.width || resource.width) ||\n      (!force && (imageServer.malformed || imageServer.verifications < this.config.verificationsRequired)) ||\n      (resource.source && isLevel0(resource.source))\n    ) {\n      return null;\n    }\n\n    if (!this.imageServices[serviceUrl]) {\n      this.imageServices[serviceUrl] = {\n        '@context': imageServer.result.context,\n        '@id': getId(resource),\n        id: getId(resource),\n        protocol: 'http://iiif.io/api/image',\n        tiles: source?.tiles || sampledTilesToTiles(resource.width, resource.height, imageServer.result.sampledTiles),\n        sizes:\n          source?.sizes ||\n          fixedSizesFromScales(\n            Math.round(resource.width / imageServer.result.resourceServiceRatio),\n            Math.round(resource.height / imageServer.result.resourceServiceRatio),\n            imageServer.result.sizeRatios\n          ),\n        profile: source?.profile || imageServer.result.sampledProfile,\n        height: source?.height || resource.height,\n        width: source?.width || resource.width,\n        real: false,\n      } as any;\n    }\n\n    return this.imageServices[serviceUrl] || null;\n  }\n\n  async getThumbnailFromResource(\n    unknownResource: ContentResource | undefined,\n    request: ImageCandidateRequest,\n    dereference = true,\n    otherCandidates: ImageCandidate[] = []\n  ) {\n    const candidates = unknownResource ? await this.getImageCandidates(unknownResource, dereference) : [];\n\n    return pickBestFromCandidates(request, [() => otherCandidates, () => candidates]);\n  }\n\n  async getImageCandidates(unknownResource: ContentResource, dereference = true): Promise<ImageCandidate[]> {\n    const resource = unknownResource as IIIFExternalWebResource;\n    if (dereference && resource && resource.height && resource.width) {\n      const imageServices = getImageServices(resource);\n      for (const service of imageServices) {\n        const request: ImageServiceRequest = {\n          id: getId(service),\n          width: service.width ? service.width : resource.width,\n          height: service.height ? service.height : resource.height,\n          source: service,\n        };\n        await this.loadService(request);\n      }\n    }\n\n    return getImageCandidates(unknownResource, dereference, this);\n  }\n\n  /**\n   * Verify approximation\n   *\n   * Given an image service, it will dereference that image service and compare the result with what\n   * would have been generated if we used internal guessing.\n   *\n   * @param resource\n   * @return Promise<boolean>\n   */\n  async verify(resource: ImageServiceRequest): Promise<boolean> {\n    const prediction = this.predict(resource, false, true);\n    const imageService = await this.fetchService(getId(resource));\n\n    if (!prediction) {\n      return false;\n    }\n\n    const isValid =\n      prediction.height === imageService.height &&\n      prediction.width === imageService.width &&\n      prediction['@context'] === imageService['@context'] &&\n      imageSizesMatch(prediction.sizes || [], imageService.sizes || []);\n    // @todo profiles match.\n\n    if (isValid) {\n      const serverId = getImageServerFromId(getId(resource));\n      const server = this.knownImageServers[serverId];\n      if (server) {\n        server.verifications += 1;\n        if (server.verifications >= this.config.verificationsRequired) {\n          server.verified = true;\n        }\n      }\n    }\n\n    return isValid;\n  }\n\n  canLoadSync(service: ImageServiceRequest | ImageService | string): boolean {\n    const serviceId = typeof service === 'string' ? service : getId(service);\n    const canonical = canonicalServiceUrl(serviceId);\n    if (this.imageServices[canonical]) {\n      return true;\n    }\n    const server = this.knownImageServers[getImageServerFromId(serviceId)];\n    return !!(server && !server.malformed && server.verifications >= this.config.verificationsRequired);\n  }\n\n  /**\n   * Mark image service as malformed\n   *\n   * If you run into issues requesting images, you can mark an image service as malformed, and it will\n   * return you a new one. Future image services will also be requested fresh, and the system will have\n   * failed. Report a bug if this happens.\n   *\n   * @param resource\n   */\n  async markAsMalformed(resource: ImageServiceRequest): Promise<ImageService> {\n    this.knownImageServers[getImageServerFromId(getId(resource))]!.malformed = true;\n    return this.loadService(resource, true);\n  }\n\n  /**\n   * Fetch an image service (use loadService instead)\n   *\n   * @param serviceId\n   * @param forceFresh\n   */\n  async fetchService(serviceId: string, forceFresh = false): Promise<ImageService & { real: boolean }> {\n    const serviceUrl = canonicalServiceUrl(serviceId);\n    const service = this.imageServices[serviceUrl];\n\n    if (service && (!forceFresh || service!.real)) {\n      return service;\n    }\n\n    if (!this.config.enableFetching) {\n      throw new Error('Fetching is not enabled');\n    }\n\n    const json = (await this.fetch(serviceUrl).then((service) => service.json())) as ImageService;\n\n    if (!json.id && (json as any)['@id']) {\n      json.id = (json as any)['@id'];\n    }\n\n    if (json.id !== serviceId) {\n      json.id = serviceId;\n      if (json['@id']) {\n        json['@id'] = serviceId;\n      }\n    }\n\n    this.imageServices[serviceUrl] = Object.assign(json, { real: true });\n\n    return this.imageServices[serviceUrl]!;\n  }\n\n  async fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n    return fetch(input, init);\n  }\n\n  /**\n   * Load an image service\n   *\n   * @param resource\n   * @param forceFresh\n   *\n   * @todo make this batched, so only the maximum required can be done at once, to allow\n   *       for the prediction engine to kick in.\n   */\n  async loadService(resource: ImageServiceRequest, forceFresh = false): Promise<ImageService> {\n    if (!this.config.disableThrottling) {\n      let running = true;\n      while (running) {\n        if (this.fetchingCount >= this.config.verificationsRequired) {\n          await new Promise((resolve) => setTimeout(resolve, 500));\n        } else {\n          running = false;\n          break;\n        }\n      }\n    }\n\n    const imageServer = this.knownImageServers[getImageServerFromId(getId(resource))];\n    if (imageServer && !imageServer.malformed && !forceFresh) {\n      // We have a known image server, let wait for it.\n      await imageServer.result;\n      // We should have a result at this point.\n      const service = this.loadServiceSync(resource);\n      if (service) {\n        return service;\n      }\n      // Unlikely path, but we will fall through to just load it again.\n    }\n\n    this.fetchingCount++;\n    // Fetch a real copy of the image service.\n    const serviceJson = await this.fetchService(getId(resource), forceFresh);\n    this.fetchingCount--;\n\n    if (serviceJson.real) {\n      this.sample(serviceJson, resource);\n    }\n\n    return serviceJson;\n  }\n\n  /**\n   * Load service synchronously\n   *\n   * If you know that the image service you are\n   * @param resource\n   */\n  loadServiceSync(resource: ImageServiceRequest): ImageService | null {\n    const serviceId = canonicalServiceUrl(getId(resource));\n\n    if (this.imageServices[serviceId]) {\n      return this.imageServices[serviceId]!;\n    }\n\n    if (!this.config.approximateServices) {\n      return null;\n    }\n\n    // Other-wise we do the magic.\n    return this.predict(resource);\n  }\n}\n", "import { ImageServiceLoader } from './image-service-loader';\nimport { createStore } from 'zustand/vanilla';\nimport mitt, { Emitter, Handler } from 'mitt';\nimport { ImageService } from '@iiif/presentation-3';\nimport { getId } from '@iiif/parser/image-3';\n\nexport type LoadImageServiceDetail = {\n  width: number;\n  height: number;\n  force?: boolean;\n};\n\nexport interface ImageServiceStore {\n  loaded: Record<\n    string,\n    {\n      status: 'loading' | 'done' | 'error';\n      service: ImageService | null;\n      error?: boolean;\n      errorMesage?: string;\n      real?: boolean;\n    }\n  >;\n\n  loadServiceSync: (\n    service: ImageService,\n    detail?: LoadImageServiceDetail,\n    backgroundRequest?: boolean\n  ) => ImageService | null;\n  loadService: (service: ImageService, detail?: LoadImageServiceDetail) => Promise<ImageService | null>;\n}\n\nexport interface ImageServiceStoreOptions {\n  loader?: ImageServiceLoader;\n  events?: Emitter<ImageServiceStoreEvents>;\n}\n\nexport type ImageServiceStoreEvents = {\n  'image-service.loaded': {\n    id: string;\n    service: ImageService | null;\n  };\n  'image-service.loading': {\n    id: string;\n  };\n  'image-service.error': {\n    id: string;\n    error: Error;\n  };\n};\n\nexport function createImageServiceStore(options: ImageServiceStoreOptions = {}) {\n  const events = options.events || mitt<ImageServiceStoreEvents>();\n  const loader = options.loader || new ImageServiceLoader();\n\n  const store = createStore<ImageServiceStore>((set, get) => ({\n    loaded: {},\n\n    loadServiceSync: (service, detail, backgroundRequest) => {\n      const id = service.id || (service['@id'] as string);\n      const existing = get().loaded[id];\n\n      if (existing && existing.status === 'done') {\n        return existing.service;\n      }\n\n      if (existing && existing.status === 'loading') {\n        return null;\n      }\n\n      if (existing && existing.status === 'error') {\n        throw new Error('Failed to load image service');\n      }\n\n      const request = {\n        id: getId(service),\n        width: service.width || detail?.width || 0,\n        height: service.height || detail?.height || 0,\n        source: service,\n      };\n\n      const loaded = loader.loadServiceSync(request);\n      if (loaded) {\n        set((state) => ({\n          loaded: {\n            ...state.loaded,\n            [id]: {\n              status: 'done',\n              service: loaded,\n              real: true,\n            },\n          },\n        }));\n\n        events.emit('image-service.loaded', { id, service: loaded });\n      } else {\n        if (backgroundRequest) {\n          get()\n            .loadService(service, detail)\n            .then(() => {\n              // ?\n            });\n        }\n      }\n\n      return loaded;\n    },\n\n    loadService: async (service: ImageService, detail) => {\n      const id = service.id || (service['@id'] as string);\n      const existing = get().loaded[id];\n\n      if (existing && existing.status === 'done') {\n        return existing.service;\n      }\n\n      if (existing && existing.status === 'loading') {\n        return new Promise<ImageService>((resolve, reject) => {\n          const handler: Handler<ImageServiceStoreEvents['image-service.loaded']> = (e) => {\n            if (e.id === id) {\n              events.off('image-service.loaded', handler);\n              resolve(e.service || service);\n            }\n          };\n          events.on('image-service.loaded', handler);\n        });\n      }\n\n      if (existing && existing.status === 'error' && !detail?.force) {\n        throw new Error('Failed to load image service');\n      }\n\n      events.emit('image-service.loading', { id });\n      try {\n        const request = {\n          id: getId(service),\n          width: service.width || 0,\n          height: service.height || 0,\n          source: service,\n        };\n\n        const loaded = await loader.loadService(request, detail?.force);\n\n        set((state) => ({\n          loaded: {\n            ...state.loaded,\n            [id]: {\n              status: 'done',\n              service: loaded,\n              real: (loaded as any).real,\n            },\n          },\n        }));\n\n        events.emit('image-service.loaded', { id, service: loaded });\n\n        return loaded;\n      } catch (error: any) {\n        events.emit('image-service.error', { id, error });\n        throw error;\n      }\n    },\n  }));\n\n  return {\n    store,\n    events,\n  };\n}\n\nexport const imageServices = createImageServiceStore();\n", "import { ImageService } from '@iiif/presentation-3';\nimport { isImage3 } from './is-image-3';\nimport { FixedSizeImageService } from './types';\nimport { getId, getImageServiceLevel } from '@iiif/parser/image-3';\n\n/**\n * Returns a fixed size image using the tile using the largest available size,\n * or the smallest scale factor.\n *\n * @param service\n */\nexport function getSmallestScaleFactorAsSingleImage(service: ImageService): FixedSizeImageService | null {\n  if (!service.width || !service.height) {\n    return null;\n  }\n\n  if (service.tiles) {\n    const tiles = service.tiles.sort((a, b) => {\n      return Math.max(...b.scaleFactors) - Math.max(...a.scaleFactors);\n    });\n    const len = tiles.length;\n    for (let i = 0; i < len; i++) {\n      const tile = tiles[i];\n      if (!tile) continue;\n      // @todo possible refinement.\n      // const targetSize = tile.width > (tile.height || 0) ? tile.width : tile.height;\n      const targetSize = tile.width;\n      if (!targetSize) {\n        continue;\n      }\n      const sizeLen = tile.scaleFactors.length;\n      const sortedScales = tile.scaleFactors.sort();\n      for (let j = 0; j < sizeLen; j++) {\n        const size = sortedScales[j];\n        if (!size) continue;\n        if (service.width / size <= targetSize && service.height / size <= targetSize) {\n          return {\n            id: getId(service),\n            type: 'fixed-service',\n            width: (service.width / size) | 0,\n            height: (service.height / size) | 0,\n            level: getImageServiceLevel(service)!,\n            version: isImage3(service) ? 3 : 2,\n          };\n        }\n      }\n    }\n  }\n  return null;\n}\n", "import { ChoiceBody, CollectionItemSchemas, ContentResource, Reference } from '@iiif/presentation-3';\nimport {\n  AnnotationNormalized,\n  AnnotationPageNormalized,\n  CanvasNormalized,\n  CollectionNormalized,\n  DescriptiveNormalized,\n  ManifestNormalized,\n} from '@iiif/presentation-3-normalized';\nimport { compatVault, CompatVault } from './compat';\nimport {\n  FixedSizeImage,\n  FixedSizeImageService,\n  getFixedSizeFromImage,\n  ImageCandidate,\n  ImageCandidateRequest,\n  ImageServiceLoader,\n  UnknownSizeImage,\n  VariableSizeImage,\n} from './image-service';\n\nexport const imageServiceLoader = new ImageServiceLoader();\n\nexport type ThumbnailInput =\n  | string\n  | Reference<CollectionItemSchemas>\n  | Reference<'Collection'>\n  | Reference<'Manifest'>\n  | Reference<'Canvas'>\n  | Reference<'Annotation'>\n  | Reference<'AnnotationPage'>\n  | Reference<'ContentResource'>\n  | CollectionNormalized\n  | ManifestNormalized\n  | CanvasNormalized\n  | AnnotationNormalized\n  | AnnotationPageNormalized\n  | ContentResource\n  | undefined;\n\nexport type ThumbnailOutput = Promise<{\n  best: null | undefined | FixedSizeImage | FixedSizeImageService | VariableSizeImage | UnknownSizeImage;\n  fallback: Array<ImageCandidate>;\n  log: string[];\n}>;\n\nconst helpers: Map<CompatVault, ReturnType<typeof createThumbnailHelper>> = new Map();\nexport function getThumbnail(\n  input: ThumbnailInput,\n  {\n    vault = compatVault,\n    dereference = false,\n    ...options\n  }: ImageCandidateRequest & { vault?: CompatVault; dereference?: boolean } = {}\n) {\n  let helper = helpers.get(vault);\n  if (!helper) {\n    helper = createThumbnailHelper(vault);\n    helpers.set(vault, helper);\n  }\n  return helper.getBestThumbnailAtSize(input, options, dereference);\n}\n\nexport function createThumbnailHelper(\n  vault: CompatVault = compatVault,\n  dependencies: { imageServiceLoader?: ImageServiceLoader } = {}\n) {\n  const loader = dependencies.imageServiceLoader || imageServiceLoader;\n\n  async function getBestThumbnailAtSize(\n    input: ThumbnailInput,\n    request: ImageCandidateRequest,\n    dereference = false,\n    candidates: Array<ImageCandidate> = [],\n    dimensions?: { width: number; height: number }\n  ): ThumbnailOutput {\n    const thumbnailNotFound = () => loader.getThumbnailFromResource(undefined as any, request, dereference, candidates);\n\n    if (!input) {\n      // We might have candidates already to pick from.\n      return await loader.getThumbnailFromResource(undefined as any, request, dereference, candidates);\n    }\n\n    if (typeof input === 'string') {\n      const fixed = getFixedSizeFromImage(input as any);\n      if (fixed) {\n        candidates.push(fixed);\n      }\n\n      return await loader.getThumbnailFromResource(undefined as any, request, dereference, candidates);\n    }\n\n    // Run through from ref, just in case.\n    const fullInput:\n      | string\n      | ManifestNormalized\n      | CollectionNormalized\n      | CanvasNormalized\n      | AnnotationNormalized\n      | AnnotationPageNormalized\n      | ContentResource\n      | ChoiceBody\n      | undefined = vault.get(input as any, { skipSelfReturn: false }) as any;\n\n    if (typeof fullInput === 'string') {\n      return { best: getFixedSizeFromImage(fullInput as any), fallback: [], log: [] };\n    }\n\n    if (!fullInput) {\n      return await thumbnailNotFound();\n    }\n\n    const parseThumbnail = async (resource: DescriptiveNormalized) => {\n      if (resource && resource.thumbnail && resource.thumbnail.length) {\n        const thumbnail = vault.get(resource.thumbnail[0]);\n        const potentialThumbnails = await loader.getImageCandidates(thumbnail as any, dereference);\n        if (potentialThumbnails && potentialThumbnails.length) {\n          candidates.push(...potentialThumbnails);\n        }\n      }\n    };\n\n    await parseThumbnail(fullInput as any);\n\n    switch (fullInput.type) {\n      case 'Annotation': {\n        // Grab the body.\n        const contentResources = Array.isArray(fullInput.body) ? fullInput.body : [fullInput.body];\n        // @todo this could be configuration.\n        const firstContentResources = vault.get(contentResources[0]);\n        if (dimensions && !(firstContentResources as any).width) {\n          (firstContentResources as any).width = dimensions.width;\n          (firstContentResources as any).height = dimensions.height;\n        }\n\n        return await loader.getThumbnailFromResource(firstContentResources as any, request, dereference, candidates);\n      }\n\n      case 'Canvas': {\n        const canvas = fullInput as CanvasNormalized;\n\n        return getBestThumbnailAtSize(canvas.items[0], request, dereference, candidates, {\n          width: canvas.width,\n          height: canvas.height,\n        });\n      }\n\n      // Unsupported for now.\n      case 'AnnotationPage': {\n        const annotationPage = fullInput as AnnotationPageNormalized;\n        return getBestThumbnailAtSize(annotationPage.items[0], request, dereference, candidates, dimensions);\n      }\n\n      case 'Choice': {\n        const choice = fullInput;\n        if (!choice.items || choice.items[0]) {\n          return await thumbnailNotFound();\n        }\n        // @todo this could also be configuration, just choosing the first choice.\n        return getBestThumbnailAtSize(choice.items[0] as any, request, dereference, candidates, dimensions);\n      }\n      case 'Collection': {\n        // This one is tricky, as the manifests may not have been loaded. But we will give it a shot.\n        const collection = fullInput as CollectionNormalized;\n        const firstManifest = collection.items[0];\n        if (!firstManifest) {\n          return await thumbnailNotFound();\n        }\n        return getBestThumbnailAtSize(firstManifest, request, dereference, candidates, dimensions);\n      }\n\n      case 'Manifest': {\n        const manifest = fullInput as ManifestNormalized;\n        const firstCanvas = manifest.items[0];\n        if (!firstCanvas) {\n          return await thumbnailNotFound();\n        }\n        return getBestThumbnailAtSize(firstCanvas, request, dereference, candidates, dimensions);\n      }\n\n      case 'SpecificResource':\n      case 'Image':\n      case 'Dataset':\n      case 'Sound':\n      case 'Text':\n      case 'TextualBody':\n      case 'Video':\n        if (dimensions && !(fullInput as any).width) {\n          (fullInput as any).width = dimensions.width;\n          (fullInput as any).height = dimensions.height;\n        }\n\n        return loader.getThumbnailFromResource(fullInput as any, request, dereference, candidates);\n\n      // Seems unlikely these would appear, but it would be an error..\n      // case 'Service': // @todo could do something with vault.\n      // case 'Range':\n      // case 'AnnotationCollection':\n      // case 'CanvasReference':\n      // case 'ContentResource':\n      //   return await thumbnailNotFound();\n    }\n\n    return await thumbnailNotFound();\n  }\n\n  return {\n    getBestThumbnailAtSize,\n  };\n}\n", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };", "import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };", "import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };", "import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };", "export function ensureArray<T>(maybeArray: T | T[]): T[] {\n  if (Array.isArray(maybeArray)) {\n    return maybeArray;\n  }\n  return maybeArray ? [maybeArray] : [];\n}\n", "export function removeUndefinedProperties(obj: any) {\n  for (const prop in obj) {\n    if (typeof obj[prop] === 'undefined' || obj[prop] === null) {\n      delete obj[prop];\n    }\n  }\n  return obj;\n}\n", "import { SpecificResource } from '@iiif/presentation-3';\n\nexport function isSpecificResource(resource: unknown): resource is SpecificResource {\n  if (typeof resource === 'string') {\n    return false;\n  }\n\n  if (resource && !(resource as any).type && 'source' in (resource as any)) {\n    (resource as any).type = 'SpecificResource';\n    return true;\n  }\n\n  return !!resource && (resource as any).type === 'SpecificResource';\n}\n", "export function compose<T, B = T>(...fns: any[]): (input: T) => T {\n  return <B>(arg: any) => fns.reduce((a, f) => f(a), arg) as any as T;\n}\n", "import {\n  Annotation,\n  AnnotationCollection,\n  AnnotationPage,\n  Canvas,\n  ChoiceBody,\n  ChoiceTarget,\n  Collection,\n  ContentResource,\n  DescriptiveProperties,\n  IIIFExternalWebResource,\n  LinkingProperties,\n  Manifest,\n  Range,\n  RangeItems,\n  Required,\n  Service,\n  SpecificResource,\n  ResourceProvider,\n  StructuralProperties,\n} from '@iiif/presentation-3';\nimport { isSpecificResource } from '../shared/is-specific-resource';\nimport { ensureArray } from '../shared/ensure-array';\nimport { compose } from '../shared/compose';\n\nexport const types = [\n  'Collection',\n  'Manifest',\n  'Canvas',\n  'AnnotationPage',\n  'AnnotationCollection',\n  'Annotation',\n  'ContentResource',\n  'Range',\n  'Service',\n  'Selector',\n  'Agent',\n];\n\nexport type TraversalContext = { parent?: any };\n\nexport type Traversal<T> = (jsonLd: T, context: TraversalContext) => Partial<T> | any;\n\nexport type TraversalMap = {\n  collection?: Array<Traversal<Collection>>;\n  manifest?: Array<Traversal<Manifest>>;\n  canvas?: Array<Traversal<Canvas>>;\n  annotationCollection?: Array<Traversal<AnnotationCollection>>;\n  annotationPage?: Array<Traversal<AnnotationPage>>;\n  annotation?: Array<Traversal<Annotation>>;\n  contentResource?: Array<Traversal<ContentResource>>;\n  choice?: Array<Traversal<ChoiceTarget | ChoiceBody>>;\n  range?: Array<Traversal<Range>>;\n  service?: Array<Traversal<Service>>;\n  agent?: Array<Traversal<ResourceProvider>>;\n  specificResource?: Array<Traversal<SpecificResource>>;\n  geoJson?: Array<Traversal<import('geojson').GeoJSON>>;\n};\n\nexport type TraverseOptions = {\n  allowUndefinedReturn: boolean;\n};\n\nexport function identifyResource(resource: any, typeHint?: string): string {\n  if (typeof resource === 'undefined' || resource === null) {\n    throw new Error('Null or undefined is not a valid entity.');\n  }\n  if (Array.isArray(resource)) {\n    throw new Error('Array is not a valid entity');\n  }\n  if (typeof resource !== 'object') {\n    if (typeHint) {\n      return typeHint;\n    }\n    throw new Error(`${typeof resource} is not a valid entity`);\n  }\n\n  if (typeof resource!.type === 'string') {\n    const hasType = types.indexOf(resource.type);\n    if (hasType !== -1) {\n      return types[hasType]!;\n    }\n  }\n\n  if (resource!.profile) {\n    return 'Service';\n  }\n\n  throw new Error('Resource type is not known');\n}\n\nexport class Traverse {\n  private traversals: Required<TraversalMap>;\n\n  private options: TraverseOptions;\n\n  constructor(traversals: TraversalMap, options: Partial<TraverseOptions> = {}) {\n    this.traversals = {\n      collection: [],\n      manifest: [],\n      canvas: [],\n      annotationCollection: [],\n      annotationPage: [],\n      annotation: [],\n      contentResource: [],\n      choice: [],\n      range: [],\n      service: [],\n      agent: [],\n      specificResource: [],\n      geoJson: [],\n      ...traversals,\n    };\n    this.options = {\n      allowUndefinedReturn: false,\n      ...options,\n    };\n  }\n\n  static all(traversal: (resource: any) => any) {\n    return new Traverse({\n      collection: [traversal],\n      manifest: [traversal],\n      canvas: [traversal],\n      annotationCollection: [traversal],\n      annotationPage: [traversal],\n      annotation: [traversal],\n      contentResource: [traversal],\n      choice: [traversal],\n      range: [traversal],\n      service: [traversal],\n      geoJson: [traversal],\n      specificResource: [traversal],\n      agent: [traversal],\n    });\n  }\n\n  traverseDescriptive<T extends Partial<DescriptiveProperties>>(resource: T): T {\n    if (resource.thumbnail) {\n      resource.thumbnail = ensureArray(resource.thumbnail).map((thumbnail) =>\n        this.traverseType(thumbnail, { parent: resource }, this.traversals.contentResource)\n      );\n    }\n    if (resource.provider) {\n      resource.provider = resource.provider.map((agent) => this.traverseAgent(agent, resource));\n    }\n    return resource;\n  }\n\n  traverseLinking<T extends Partial<LinkingProperties>>(resource: T): T {\n    if (resource.seeAlso) {\n      resource.seeAlso = ensureArray(resource.seeAlso).map((content) =>\n        this.traverseType(content, { parent: resource }, this.traversals.contentResource)\n      );\n    }\n    if (resource.service) {\n      resource.service = ensureArray(resource.service).map((service) => this.traverseService(service));\n    }\n    if (resource.services) {\n      resource.services = ensureArray(resource.services).map((service) => this.traverseService(service, resource));\n    }\n    if (resource.logo) {\n      resource.logo = ensureArray(resource.logo).map((content) =>\n        this.traverseType(content, { parent: resource }, this.traversals.contentResource)\n      );\n    }\n    if (resource.homepage) {\n      resource.homepage = ensureArray(resource.homepage).map((homepage) =>\n        this.traverseType(homepage, { parent: resource }, this.traversals.contentResource)\n      );\n    }\n    if (resource.partOf) {\n      // Array<ContentResource | Canvas | AnnotationCollection>\n      (resource as any).partOf = resource.partOf.map((partOf) => {\n        if (typeof partOf === 'string' || !partOf.type) {\n          return this.traverseType(partOf as ContentResource, { parent: resource }, this.traversals.contentResource);\n        }\n        if (partOf.type === 'Canvas') {\n          return this.traverseType(partOf as Canvas, { parent: resource }, this.traversals.canvas);\n        }\n        if (partOf.type === 'AnnotationCollection') {\n          return this.traverseType(\n            partOf as AnnotationCollection,\n            { parent: resource },\n            this.traversals.annotationCollection\n          );\n        }\n        if (partOf.type === 'Collection') {\n          return this.traverseType(partOf as Collection, { parent: resource }, this.traversals.collection);\n        }\n        return this.traverseType(partOf as ContentResource, { parent: resource }, this.traversals.contentResource);\n      });\n    }\n    if (resource.start) {\n      if (isSpecificResource(resource.start)) {\n        resource.start = this.traverseSpecificResource(resource.start, 'Canvas', resource) as any;\n      } else {\n        // The spec says this can be a \"partial canvas\" causing errors with the types.\n        resource.start = this.traverseType(resource.start as any, { parent: resource }, this.traversals.canvas);\n      }\n    }\n    if (resource.rendering) {\n      resource.rendering = resource.rendering.map((content) =>\n        this.traverseType(content, { parent: resource }, this.traversals.contentResource)\n      );\n    }\n    if (resource.supplementary) {\n      resource.supplementary = resource.supplementary.map((content) =>\n        this.traverseType(content, { parent: resource }, this.traversals.contentResource)\n      );\n    }\n\n    return resource;\n  }\n\n  traverseCollectionItems<T extends StructuralProperties<any>>(collection: T): T {\n    if (collection.items) {\n      collection.items.map((collectionOrManifest: Manifest | Collection) => {\n        if (collectionOrManifest.type === 'Collection') {\n          return this.traverseCollection(collectionOrManifest as Collection);\n        }\n        return this.traverseManifest(collectionOrManifest as Manifest);\n      });\n    }\n\n    return collection;\n  }\n\n  traverseCollection(collection: Collection, parent?: any): Collection {\n    return this.traverseType<Collection>(\n      this.traverseDescriptive(\n        this.traverseNavPlace(\n          this.traverseInlineAnnotationPages(\n            this.traverseLinking(this.traverseLinkedCanvases(this.traverseCollectionItems(collection as any)))\n          )\n        )\n      ),\n      { parent },\n      this.traversals.collection\n    );\n  }\n\n  traverseGeoJson(geoJson: import('geojson').GeoJSON, parent?: any): import('geojson').GeoJSON {\n    return this.traverseType<import('geojson').GeoJSON>(geoJson, { parent }, this.traversals.geoJson);\n  }\n\n  traverseNavPlace(resource: any /*NavPlaceExtension*/) {\n    if (resource.navPlace) {\n      resource.navPlace = this.traverseGeoJson(resource.navPlace, resource);\n    }\n    return resource;\n  }\n\n  traverseManifestItems(manifest: Manifest): Manifest {\n    if (manifest.items) {\n      manifest.items = manifest.items.map((canvas) => this.traverseCanvas(canvas));\n    }\n    return manifest;\n  }\n\n  traverseManifestStructures(manifest: Manifest): Manifest {\n    if (manifest.structures) {\n      manifest.structures = manifest.structures.map((range) => this.traverseRange(range));\n    }\n    return manifest;\n  }\n\n  _traverseManifest: (manifest: Manifest) => Manifest = compose<Manifest>(\n    this.traverseManifestItems.bind(this),\n    this.traverseNavPlace.bind(this),\n    this.traverseLinking.bind(this),\n    this.traverseDescriptive.bind(this),\n    this.traverseLinkedCanvases.bind(this),\n    this.traverseManifestStructures.bind(this),\n    this.traverseInlineAnnotationPages.bind(this),\n  );\n\n  traverseManifest(manifest: Manifest, parent?: any): Manifest {\n    return this.traverseType<Manifest>(this._traverseManifest(manifest), { parent }, this.traversals.manifest);\n  }\n\n  traverseCanvasItems(canvas: Canvas): Canvas {\n    canvas.items = (canvas.items || []).map((annotationPage: AnnotationPage): AnnotationPage => {\n      return this.traverseAnnotationPage(annotationPage, canvas);\n    });\n\n    return canvas;\n  }\n\n  traverseInlineAnnotationPages<T extends Manifest | Canvas | Range | string>(resource: T): T {\n    if (typeof resource === 'string' || !resource) {\n      return resource;\n    }\n    if (resource.annotations) {\n      resource.annotations = resource.annotations.map((annotationPage: AnnotationPage): AnnotationPage => {\n        return this.traverseAnnotationPage(annotationPage, resource);\n      });\n    }\n\n    return resource;\n  }\n\n  _traverseCanvas: (canvas: Canvas) => Canvas = compose<Canvas>(\n    this.traverseCanvasItems.bind(this),\n    this.traverseLinking.bind(this),\n    this.traverseDescriptive.bind(this),\n    this.traverseLinkedCanvases.bind(this),\n    this.traverseInlineAnnotationPages.bind(this)\n  );\n\n  traverseCanvas(canvas: Canvas, parent?: any): Canvas {\n    return this.traverseType<Canvas>(this._traverseCanvas(canvas), { parent }, this.traversals.canvas);\n  }\n\n  traverseAnnotationPageItems(annotationPage: AnnotationPage): AnnotationPage {\n    if (annotationPage.items) {\n      annotationPage.items = annotationPage.items.map((annotation: Annotation): Annotation => {\n        return this.traverseAnnotation(annotation, annotationPage);\n      });\n    }\n    return annotationPage;\n  }\n\n  _traverseAnnotationPage: (page: AnnotationPage) => AnnotationPage = compose<AnnotationPage>(\n    this.traverseAnnotationPageItems.bind(this),\n    this.traverseLinking.bind(this),\n    this.traverseDescriptive.bind(this)\n  );\n\n  traverseAnnotationPage(annotationPageJson: AnnotationPage, parent?: any): AnnotationPage {\n    return this.traverseType<AnnotationPage>(\n      this._traverseAnnotationPage(annotationPageJson),\n      { parent },\n      this.traversals.annotationPage\n    );\n  }\n\n  // Disabling these.\n\n  traverseAnnotationBody(annotation: Annotation): Annotation {\n    if (Array.isArray(annotation.body)) {\n      annotation.body = annotation.body.map((annotationBody: any): ContentResource => {\n        return this.traverseContentResource(annotationBody, annotation);\n      });\n    } else if (annotation.body) {\n      annotation.body = this.traverseContentResource(annotation.body as ContentResource, annotation);\n    }\n\n    return annotation;\n  }\n\n  traverseLinkedCanvases<T extends { placeholderCanvas?: any; accompanyingCanvas?: any }>(json: T): T {\n    if (json.placeholderCanvas) {\n      json.placeholderCanvas = this.traverseCanvas(json.placeholderCanvas);\n    }\n\n    if (json.accompanyingCanvas) {\n      json.accompanyingCanvas = this.traverseCanvas(json.accompanyingCanvas);\n    }\n\n    return json;\n  }\n\n  // @todo traverseAnnotationSelector\n  traverseAnnotation(annotationJson: Annotation, parent?: any): Annotation {\n    return this.traverseType<Annotation>(\n      this.traverseLinking(this.traverseAnnotationBody(this.traverseDescriptive(annotationJson as any))),\n      { parent },\n      this.traversals.annotation\n    );\n  }\n\n  traverseContentResourceLinking(contentResourceJson: ContentResource): ContentResource {\n    if (typeof contentResourceJson === 'string' || !contentResourceJson) {\n      return contentResourceJson;\n    }\n    if (contentResourceJson && (contentResourceJson as IIIFExternalWebResource)!.service) {\n      (contentResourceJson as IIIFExternalWebResource).service = ensureArray(\n        (contentResourceJson as IIIFExternalWebResource).service || []\n      ).map((service) => this.traverseService(service, contentResourceJson));\n    }\n\n    return contentResourceJson;\n  }\n\n  traverseContentResource(contentResourceJson: ContentResource, parent?: any): ContentResource {\n    if ((contentResourceJson as any).type === 'Choice') {\n      (contentResourceJson as any).items = (contentResourceJson as any).items.map((choiceItem: ContentResource) => {\n        return this.traverseContentResource(choiceItem, contentResourceJson);\n      });\n    }\n\n    if (isSpecificResource(contentResourceJson)) {\n      return this.traverseSpecificResource(contentResourceJson, 'ContentResource');\n    }\n\n    return this.traverseType<ContentResource>(\n      // This needs an `any` because of the scope of W3C annotation bodies (covered by ContentResource).\n      // ContentResources are permitted to have a `.annotations` property, so we can pass it as any  for this\n      // case.\n      this.traverseInlineAnnotationPages(this.traverseContentResourceLinking(contentResourceJson) as any),\n      { parent },\n      this.traversals.contentResource\n    );\n  }\n\n  traverseSpecificResource(specificResource: SpecificResource, typeHint?: string, parent?: any): SpecificResource {\n    let source = specificResource.source;\n    if (typeof specificResource.source === 'string') {\n      source = { id: specificResource.source, type: typeHint || 'unknown' };\n    }\n\n    return this.traverseType<SpecificResource>(\n      {\n        ...specificResource,\n        source:\n          typeHint === 'Canvas' || source.type === 'Canvas'\n            ? this.traverseType(source, { parent }, this.traversals.canvas)\n            : typeHint === 'ContentResource'\n              ? this.traverseContentResource(source, { parent })\n              : this.traverseUnknown(source, { parent, typeHint }),\n      },\n      { parent },\n      this.traversals.specificResource\n    );\n  }\n\n  traverseRangeRanges(range: Range): Range {\n    if (range.items) {\n      range.items = range.items.map((rangeOrManifest: RangeItems) => {\n        if (typeof rangeOrManifest === 'string') {\n          return this.traverseCanvas({ id: rangeOrManifest, type: 'Canvas' }, range);\n        }\n        if (isSpecificResource(rangeOrManifest)) {\n          return this.traverseSpecificResource(rangeOrManifest, 'Canvas', range);\n        }\n        // This is a non-standard case.\n        if ((rangeOrManifest as any).type === 'Manifest') {\n          return this.traverseManifest(rangeOrManifest as any, range) as any as RangeItems;\n        }\n        return this.traverseRange(rangeOrManifest as Range, range);\n      });\n    }\n\n    return range;\n  }\n\n  _traverseRange: (range: Range) => Range = compose<Range>(\n    this.traverseRangeRanges.bind(this),\n    this.traverseLinking.bind(this),\n    this.traverseDescriptive.bind(this),\n    this.traverseLinkedCanvases.bind(this)\n  );\n\n  traverseRange(range: Range, parent?: any): Range {\n    return this.traverseType<Range>(this._traverseRange(range), { parent }, this.traversals.range);\n  }\n\n  traverseAgent(agent: ResourceProvider, parent?: any) {\n    return this.traverseType<ResourceProvider>(\n      this.traverseDescriptive(this.traverseLinking(agent)),\n      { parent },\n      this.traversals.agent\n    );\n  }\n\n  traverseType<T>(object: T, context: TraversalContext, traversals: Array<Traversal<T>>): T {\n    return traversals.reduce((acc: T, traversal: Traversal<T>): T => {\n      const returnValue = traversal(acc, context);\n      if (typeof returnValue === 'undefined' && !this.options.allowUndefinedReturn) {\n        return acc;\n      }\n      return returnValue;\n    }, object);\n  }\n\n  traverseService(service: Service, parent?: any): Service {\n    const _service: any = Object.assign({}, service);\n    if (_service && _service.service) {\n      _service.service = ensureArray(_service.service).map((innerService: any) => this.traverseService(innerService));\n    }\n    return this.traverseType<Service>(_service, { parent }, this.traversals.service);\n  }\n\n  traverseUnknown(\n    resource: any,\n    { parent, typeHint }: { typeHint?: string; parent?: any } = {}\n  ):\n    | Collection\n    | Manifest\n    | Canvas\n    | AnnotationPage\n    | Annotation\n    | ContentResource\n    | Range\n    | Service\n    | ResourceProvider {\n    const type = identifyResource(resource, typeHint);\n\n    switch (type) {\n      case 'Collection':\n        return this.traverseCollection(resource as Collection, parent);\n      case 'Manifest':\n        return this.traverseManifest(resource as Manifest, parent);\n      case 'Canvas':\n        return this.traverseCanvas(resource as Canvas, parent);\n      case 'AnnotationPage':\n        return this.traverseAnnotationPage(resource as AnnotationPage, parent);\n      case 'Annotation':\n        return this.traverseAnnotation(resource as Annotation, parent);\n      case 'ContentResource':\n        return this.traverseContentResource(resource as ContentResource, parent);\n      case 'Range':\n        return this.traverseRange(resource as Range, parent);\n      case 'Service':\n        return this.traverseService(resource as Service, parent);\n      case 'Agent':\n        return this.traverseAgent(resource as ResourceProvider, parent);\n      default: {\n        throw new Error(`Unknown or unsupported resource type of ${type}`);\n      }\n    }\n  }\n}\n", "import type {\n  Annotation,\n  AnnotationList,\n  Canvas,\n  ChoiceEmbeddedContent,\n  Collection,\n  CommonContentResource,\n  ContentResource,\n  DescriptiveProperties,\n  Layer,\n  LinkingProperties,\n  Manifest,\n  OneOrMany,\n  Range,\n  RightsProperties,\n  Sequence,\n  Service,\n  TraversableEntityTypes,\n  Traversal,\n  TraversalMap,\n} from '@iiif/presentation-2';\n\nexport const types: TraversableEntityTypes[] = [\n  'sc:Collection',\n  'sc:Manifest',\n  'sc:Canvas',\n  'sc:AnnotationList',\n  'oa:Annotation',\n  'sc:Range',\n  'sc:Layer',\n  'sc:Sequence',\n  'oa:Choice',\n  // Opaque.\n  'Service',\n  'ContentResource',\n];\n\nexport type TraverseOptions = {\n  convertPropsToArray: boolean;\n  mergeMemberProperties: boolean;\n  allowUndefinedReturn: boolean;\n};\n\nexport function identifyResource(resource: any): TraversableEntityTypes {\n  if (typeof resource === 'undefined' || resource === null) {\n    throw new Error('Null or undefined is not a valid entity.');\n  }\n  if (Array.isArray(resource)) {\n    throw new Error('Array is not a valid entity');\n  }\n  if (typeof resource !== 'object') {\n    throw new Error(`${typeof resource} is not a valid entity`);\n  }\n\n  if (typeof resource['@type'] === 'string') {\n    const hasType = types.indexOf(resource['@type'] as any);\n    if (hasType !== -1) {\n      return types[hasType]!;\n    }\n  }\n\n  if (resource.profile) {\n    return 'Service';\n  }\n\n  if (resource.format) {\n    return 'ContentResource';\n  }\n\n  // Big o'l fallback.\n  if (resource['@type']) {\n    return 'ContentResource';\n  }\n\n  throw new Error('Resource type is not known');\n}\n\nexport class Traverse<\n  T extends {\n    Collection: any;\n    Manifest: any;\n    Canvas: any;\n    AnnotationList: any;\n    Sequence: any;\n    Annotation: any;\n    ContentResource: any;\n    Choice: any;\n    Range: any;\n    Service: any;\n    Layer: any;\n  } = {\n    Collection: Collection;\n    Manifest: Manifest;\n    Canvas: Canvas;\n    AnnotationList: AnnotationList;\n    Sequence: Sequence;\n    Annotation: Annotation;\n    ContentResource: CommonContentResource;\n    Choice: ChoiceEmbeddedContent;\n    Range: Range;\n    Service: Service;\n    Layer: Layer;\n  },\n> {\n  private traversals: Required<TraversalMap>;\n  private options: TraverseOptions;\n\n  constructor(traversals: Partial<TraversalMap>, options: Partial<TraverseOptions> = {}) {\n    this.traversals = {\n      collection: [],\n      manifest: [],\n      canvas: [],\n      annotationList: [],\n      sequence: [],\n      annotation: [],\n      contentResource: [],\n      choice: [],\n      range: [],\n      service: [],\n      layer: [],\n      ...traversals,\n    };\n    this.options = {\n      convertPropsToArray: true,\n      mergeMemberProperties: true,\n      allowUndefinedReturn: false,\n      ...options,\n    };\n  }\n\n  static all(traversal: (resource: any) => any) {\n    return new Traverse({\n      collection: [traversal],\n      manifest: [traversal],\n      canvas: [traversal],\n      annotationList: [traversal],\n      sequence: [traversal],\n      annotation: [traversal],\n      contentResource: [traversal],\n      choice: [traversal],\n      range: [traversal],\n      service: [traversal],\n      layer: [traversal],\n    });\n  }\n\n  traverseCollection(collection: Collection): T['Collection'] {\n    return this.traverseType(\n      this.traverseDescriptive(this.traverseLinking(this.traverseCollectionItems(collection))),\n      this.traversals.collection\n    );\n  }\n\n  traverseCollectionItems(collection: Collection): Collection {\n    if (this.options.mergeMemberProperties) {\n      const members = [\n        ...(collection.manifests || []).map((manifest) => {\n          if (typeof manifest === 'string') {\n            return { '@id': manifest, '@type': 'sc:Manifest' };\n          }\n          return manifest;\n        }),\n        ...(collection.collections || []).map((subCollection) => {\n          if (typeof subCollection === 'string') {\n            return { '@id': subCollection, '@type': 'sc:Collection' };\n          }\n          return subCollection;\n        }),\n        ...(collection.members || []),\n      ];\n\n      const seenIds: string[] = [];\n      const filteredMembers = members.filter((resource) => {\n        if (seenIds.includes(resource['@id'])) {\n          return false;\n        }\n        seenIds.push(resource['@id']);\n        return true;\n      });\n\n      delete collection.collections;\n      delete collection.manifests;\n      collection.members = filteredMembers;\n    }\n\n    if (collection.manifests) {\n      collection.manifests = collection.manifests.map((manifest) =>\n        this.traverseManifest(\n          typeof manifest === 'string'\n            ? ({ '@id': manifest, '@type': 'sc:Manifest' } as Manifest)\n            : (manifest as Manifest)\n        )\n      );\n    }\n\n    if (collection.collections) {\n      collection.collections = collection.collections.map((subCollection) =>\n        this.traverseCollection(\n          typeof subCollection === 'string'\n            ? ({ '@id': subCollection, '@type': 'sc:Collection' } as Collection)\n            : (subCollection as Collection)\n        )\n      );\n    }\n\n    if (collection.members) {\n      collection.members = collection.members.map((member) => {\n        if (typeof member === 'string') {\n          return member;\n        }\n        if (member['@type'] === 'sc:Collection') {\n          return this.traverseCollection(member);\n        }\n        if (member['@type'] === 'sc:Manifest') {\n          return this.traverseManifest(member as any);\n        }\n        return this.traverseUnknown(member);\n      });\n    }\n\n    return collection;\n  }\n\n  traverseManifest(manifest: Manifest): T['Manifest'] {\n    return this.traverseType(\n      this.traverseDescriptive(this.traverseLinking(this.traverseManifestItems(manifest))),\n      this.traversals.manifest\n    );\n  }\n\n  traverseManifestItems(manifest: Manifest): Manifest {\n    if (manifest.sequences) {\n      manifest.sequences = manifest.sequences.map((sequence) => this.traverseSequence(sequence));\n    }\n    if (manifest.structures) {\n      manifest.structures = manifest.structures.map((structure) => this.traverseRange(structure));\n    }\n    return manifest;\n  }\n\n  traverseSequence(sequence: Sequence): T['Sequence'] {\n    return this.traverseType(\n      this.traverseDescriptive(this.traverseLinking(this.traverseSequenceItems(sequence))),\n      this.traversals.sequence\n    );\n  }\n\n  traverseSequenceItems(sequence: Sequence): Sequence {\n    if (sequence.canvases) {\n      sequence.canvases = sequence.canvases.map((canvas) => this.traverseCanvas(canvas));\n    }\n    return sequence;\n  }\n\n  traverseCanvas(canvas: Canvas): T['Canvas'] {\n    return this.traverseType(\n      this.traverseDescriptive(this.traverseLinking(this.traverseCanvasItems(canvas))),\n      this.traversals.canvas\n    );\n  }\n\n  traverseCanvasItems(canvas: Canvas): Canvas {\n    if (canvas.images) {\n      canvas.images = canvas.images.map((image) => this.traverseAnnotation(image));\n    }\n    if (canvas.otherContent) {\n      canvas.otherContent = canvas.otherContent.map((annotationList) => this.traverseAnnotationList(annotationList));\n    }\n    return canvas;\n  }\n\n  traverseRange(range: Range): T['Range'] {\n    if (range['@type'] !== 'sc:Range') {\n      range['@type'] = 'sc:Range';\n    }\n    return this.traverseType(\n      this.traverseDescriptive(this.traverseLinking(this.traverseRangeItems(range))),\n      this.traversals.range\n    );\n  }\n\n  traverseRangeItems(range: Range): Range {\n    if (this.options.mergeMemberProperties) {\n      const members = [\n        ...(range.ranges || []).map((innerRange: any) => {\n          if (typeof innerRange === 'string') {\n            return { '@id': innerRange, '@type': 'sc:Range' };\n          }\n          return innerRange;\n        }),\n        ...(range.canvases || []).map((canvas: any) => {\n          if (typeof canvas === 'string') {\n            return { '@id': canvas, '@type': 'sc:Canvas' };\n          }\n          return canvas;\n        }),\n        ...(range.members || []),\n      ];\n\n      delete range.ranges;\n      delete range.canvases;\n      range.members = members.length\n        ? members.map((member) => {\n            // Enable if seen.\n            // if (\n            //   member.type === 'sc:Canvas' &&\n            //   (('canvases' in member && member.canvases?.length) ||\n            //     ('ranges' in member && member.ranges?.length) ||\n            //     ('members' in member && member.members?.length))\n            // ) {\n            //   // This is likely a Range, not a canvas.\n            //   member['@type'] = 'sc:Range';\n            // }\n\n            return this.traverseUnknown(member);\n          })\n        : undefined;\n    }\n    return range;\n  }\n\n  traverseAnnotationList(annotationList: AnnotationList): T['AnnotationList'] {\n    const list =\n      typeof annotationList === 'string'\n        ? ({ '@id': annotationList, '@type': 'sc:AnnotationList' } as any)\n        : annotationList;\n\n    return this.traverseType(\n      this.traverseDescriptive(this.traverseAnnotationListItems(list)),\n      this.traversals.annotationList\n    );\n  }\n\n  traverseAnnotationListItems(annotationList: AnnotationList): AnnotationList {\n    if (annotationList.resources) {\n      annotationList.resources = annotationList.resources.map((annotation) => this.traverseAnnotation(annotation));\n    }\n\n    return annotationList;\n  }\n\n  traverseAnnotation(annotation: Annotation): T['Annotation'] {\n    return this.traverseType(\n      this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationItems(annotation))),\n      this.traversals.annotation\n    );\n  }\n\n  traverseAnnotationItems(annotation: Annotation): Annotation {\n    if (annotation.resource) {\n      if (Array.isArray(annotation.resource)) {\n        annotation.resource = annotation.resource.map((res) =>\n          this.traverseContentResource(res as CommonContentResource)\n        );\n      } else {\n        annotation.resource = this.traverseContentResource(annotation.resource as CommonContentResource);\n      }\n    }\n\n    if (annotation.on) {\n      // selector - just traverse the annotations.\n      // annotation.on = this.traverseSelector(annotation.on);\n    }\n\n    return annotation;\n  }\n\n  traverseLayer(layer: Layer): T['Layer'] {\n    return this.traverseType(this.traverseLinking(this.traverseLayerItems(layer)), this.traversals.layer);\n  }\n\n  traverseLayerItems(layer: Layer): Layer {\n    if (layer.otherContent) {\n      layer.otherContent = layer.otherContent.map((annotationList) => this.traverseAnnotationList(annotationList));\n    }\n    return layer;\n  }\n\n  traverseChoice(choice: ChoiceEmbeddedContent): T['Choice'] {\n    return this.traverseType(this.traverseChoiceItems(choice), this.traversals.choice);\n  }\n\n  traverseChoiceItems(choice: ChoiceEmbeddedContent) {\n    if (choice.default && choice.default !== 'rdf:nil') {\n      choice.default = this.traverseContentResource(choice.default);\n    }\n    if (choice.item && choice.item !== 'rdf:nil') {\n      choice.item = choice.item.map((item) => this.traverseContentResource(item));\n    }\n\n    return choice;\n  }\n\n  traverseService(service: Service): T['Service'] {\n    return this.traverseType(this.traverseLinking(service as any), this.traversals.service);\n  }\n\n  traverseContentResource(contentResource: CommonContentResource): T['ContentResource'] {\n    if (contentResource['@type'] === 'oa:Choice') {\n      return this.traverseChoice(contentResource as any);\n    }\n\n    return this.traverseType(\n      this.traverseDescriptive(this.traverseLinking(contentResource as any)),\n      this.traversals.contentResource\n    );\n  }\n\n  traverseUnknown(item: any) {\n    if (!item['@type'] || typeof item === 'string') {\n      // Unknown item.\n      return item;\n    }\n    switch (identifyResource(item)) {\n      case 'sc:Collection':\n        return this.traverseCollection(item);\n      case 'sc:Manifest':\n        return this.traverseManifest(item);\n      case 'sc:Canvas':\n        return this.traverseCanvas(item);\n      case 'sc:Sequence':\n        return this.traverseSequence(item);\n      case 'sc:Range':\n        return this.traverseRange(item);\n      case 'oa:Annotation':\n        return this.traverseAnnotation(item);\n      case 'sc:AnnotationList':\n        return this.traverseAnnotationList(item);\n      case 'sc:Layer':\n        return this.traverseLayer(item);\n      case 'Service':\n        return this.traverseService(item);\n      case 'oa:Choice':\n        return this.traverseChoice(item);\n      case 'ContentResource':\n        return this.traverseContentResource(item);\n    }\n\n    if (item.profile) {\n      return this.traverseService(item);\n    }\n\n    return item;\n  }\n\n  traverseImageResource(contentResource: OneOrMany<string | ContentResource>) {\n    const wasArray = Array.isArray(contentResource);\n    const resourceList = Array.isArray(contentResource) ? contentResource : [contentResource];\n    const newResourceList: any[] = [];\n\n    for (const singleResource of resourceList) {\n      if (typeof singleResource === 'string') {\n        newResourceList.push(\n          this.traverseContentResource({\n            '@id': singleResource,\n            '@type': 'dctypes:Image',\n          })\n        );\n      } else {\n        newResourceList.push(this.traverseContentResource(singleResource as any));\n      }\n    }\n\n    if (!wasArray && !this.options.convertPropsToArray) {\n      return newResourceList[0];\n    }\n\n    return newResourceList;\n  }\n\n  traverseDescriptive<T extends Partial<DescriptiveProperties & RightsProperties>>(resource: T) {\n    if (resource.thumbnail) {\n      resource.thumbnail = this.traverseImageResource(resource.thumbnail);\n    }\n\n    if (resource.logo) {\n      resource.logo = this.traverseImageResource(resource.logo);\n    }\n\n    return resource;\n  }\n\n  traverseOneOrMoreServices(allServices: OneOrMany<any>) {\n    const wasArray = Array.isArray(allServices);\n    const services = Array.isArray(allServices) ? allServices : [allServices];\n    const newServices = [];\n    for (const service of services) {\n      newServices.push(this.traverseService(service));\n    }\n\n    if (!wasArray && !this.options.convertPropsToArray) {\n      return newServices[0];\n    }\n\n    return newServices;\n  }\n\n  traverseLinking<T extends Partial<LinkingProperties>>(resource: T) {\n    if (resource.related) {\n      resource.related = this.traverseOneOrManyType(resource.related, this.traversals.contentResource);\n    }\n    if (resource.rendering) {\n      resource.rendering = this.traverseOneOrManyType(resource.rendering, this.traversals.contentResource);\n    }\n    if (resource.service) {\n      resource.service = this.traverseOneOrMoreServices(resource.service);\n    }\n    if (resource.seeAlso) {\n      resource.seeAlso = this.traverseOneOrManyType(resource.seeAlso, this.traversals.contentResource);\n    }\n    if (resource.within) {\n      if (typeof resource.within === 'string') {\n        // I don't know. skip?\n      } else {\n        resource.within = this.traverseOneOrManyType(\n          resource.within as CommonContentResource,\n          this.traversals.contentResource\n        );\n      }\n    }\n    if (resource.startCanvas) {\n      if (typeof resource.startCanvas === 'string') {\n        resource.startCanvas = this.traverseType(\n          { '@id': resource.startCanvas, '@type': 'sc:Canvas' } as Canvas,\n          this.traversals.canvas\n        );\n      } else if (resource.startCanvas) {\n        this.traverseType(resource.startCanvas as any, this.traversals.canvas);\n      }\n    }\n    if (resource.contentLayer) {\n      if (typeof resource.contentLayer === 'string') {\n        resource.contentLayer = this.traverseLayer({\n          '@id': resource.contentLayer,\n          '@type': 'sc:Layer',\n        });\n      } else {\n        resource.contentLayer = this.traverseLayer(resource.contentLayer);\n      }\n    }\n    return resource;\n  }\n\n  traverseOneOrManyType<T, Return = T>(object: T | T[], traversals: Array<Traversal<T>>): Return {\n    if (!Array.isArray(object)) {\n      if (this.options.convertPropsToArray) {\n        object = [object] as T[];\n      } else {\n        return this.traverseType(object, traversals);\n      }\n    }\n    return object.map((singleObj) => this.traverseType(singleObj, traversals)) as any;\n  }\n\n  traverseType<T, Return = T>(object: T, traversals: Array<Traversal<T>>): Return {\n    return traversals.reduce((acc: T, traversal: Traversal<T>): T => {\n      const returnValue = traversal(acc);\n      if (typeof returnValue === 'undefined' && !this.options.allowUndefinedReturn) {\n        return acc;\n      }\n      return returnValue;\n    }, object) as any;\n  }\n}\n", "export const STANFORD_IIIF_IMAGE_COMPLIANCE_0 = 'http://library.stanford.edu/iiif/image-api/compliance.html#level0';\nexport const STANFORD_IIIF_IMAGE_COMPLIANCE_1 = 'http://library.stanford.edu/iiif/image-api/compliance.html#level1';\nexport const STANFORD_IIIF_IMAGE_COMPLIANCE_2 = 'http://library.stanford.edu/iiif/image-api/compliance.html#level2';\nexport const STANFORD_IIIF_IMAGE_CONFORMANCE_0 = 'http://library.stanford.edu/iiif/image-api/conformance.html#level0';\nexport const STANFORD_IIIF_IMAGE_CONFORMANCE_1 = 'http://library.stanford.edu/iiif/image-api/conformance.html#level1';\nexport const STANFORD_IIIF_IMAGE_CONFORMANCE_2 = 'http://library.stanford.edu/iiif/image-api/conformance.html#level2';\nexport const STANFORD_IIIF_1_IMAGE_COMPLIANCE_0 =\n  'http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0';\nexport const STANFORD_IIIF_1_IMAGE_COMPLIANCE_1 =\n  'http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1';\nexport const STANFORD_IIIF_1_IMAGE_COMPLIANCE_2 =\n  'http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2';\nexport const STANFORD_IIIF_1_IMAGE_CONFORMANCE_0 =\n  'http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0';\nexport const STANFORD_IIIF_1_IMAGE_CONFORMANCE_1 =\n  'http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1';\nexport const STANFORD_IIIF_1_IMAGE_CONFORMANCE_2 =\n  'http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2';\nexport const IIIF_1_IMAGE_LEVEL_0 = 'http://iiif.io/api/image/1/level0.json';\nexport const IIIF_1_IMAGE_LEVEL_0_PROFILE = 'http://iiif.io/api/image/1/profiles/level0.json';\nexport const IIIF_1_IMAGE_LEVEL_1 = 'http://iiif.io/api/image/1/level1.json';\nexport const IIIF_1_IMAGE_LEVEL_1_PROFILE = 'http://iiif.io/api/image/1/profiles/level1.json';\nexport const IIIF_1_IMAGE_LEVEL_2 = 'http://iiif.io/api/image/1/level2.json';\nexport const IIIF_1_IMAGE_LEVEL_2_PROFILE = 'http://iiif.io/api/image/1/profiles/level2.json';\nexport const IIIF_2_IMAGE_LEVEL_0 = 'http://iiif.io/api/image/2/level0.json';\nexport const IIIF_2_IMAGE_LEVEL_0_PROFILE = 'http://iiif.io/api/image/2/profiles/level0.json';\nexport const IIIF_2_IMAGE_LEVEL_1 = 'http://iiif.io/api/image/2/level1.json';\nexport const IIIF_2_IMAGE_LEVEL_1_PROFILE = 'http://iiif.io/api/image/2/profiles/level1.json';\nexport const IIIF_2_IMAGE_LEVEL_2 = 'http://iiif.io/api/image/2/level2.json';\nexport const IIIF_2_IMAGE_LEVEL_2_PROFILE = 'http://iiif.io/api/image/2/profiles/level2.json';\nexport const IIIF_3_IMAGE_LEVEL_0 = 'level0';\nexport const IIIF_3_IMAGE_LEVEL_1 = 'level1';\nexport const IIIF_3_IMAGE_LEVEL_2 = 'level2';\n\n// Non-standard\nexport const IIIF_2_IMAGE_LEVEL_0_NO_JSON = 'http://iiif.io/api/image/2/level0';\nexport const IIIF_2_IMAGE_LEVEL_1_NO_JSON = 'http://iiif.io/api/image/2/level1';\nexport const IIIF_2_IMAGE_LEVEL_2_NO_JSON = 'http://iiif.io/api/image/2/level2';\n\nexport const level1Support = [\n  IIIF_2_IMAGE_LEVEL_1_NO_JSON,\n  IIIF_2_IMAGE_LEVEL_2_NO_JSON,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_1,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_2,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_1,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_2,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_1,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_2,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_1,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_2,\n  IIIF_1_IMAGE_LEVEL_1,\n  IIIF_1_IMAGE_LEVEL_1_PROFILE,\n  IIIF_1_IMAGE_LEVEL_2,\n  IIIF_1_IMAGE_LEVEL_2_PROFILE,\n  IIIF_2_IMAGE_LEVEL_1,\n  IIIF_2_IMAGE_LEVEL_1_PROFILE,\n  IIIF_2_IMAGE_LEVEL_2,\n  IIIF_2_IMAGE_LEVEL_2_PROFILE,\n  IIIF_3_IMAGE_LEVEL_1,\n  IIIF_3_IMAGE_LEVEL_2,\n];\n\nexport const imageServiceProfiles = [\n  IIIF_2_IMAGE_LEVEL_0_NO_JSON,\n  IIIF_2_IMAGE_LEVEL_1_NO_JSON,\n  IIIF_2_IMAGE_LEVEL_2_NO_JSON,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_0,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_1,\n  STANFORD_IIIF_IMAGE_COMPLIANCE_2,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_0,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_1,\n  STANFORD_IIIF_IMAGE_CONFORMANCE_2,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_0,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_1,\n  STANFORD_IIIF_1_IMAGE_COMPLIANCE_2,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_0,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_1,\n  STANFORD_IIIF_1_IMAGE_CONFORMANCE_2,\n  IIIF_1_IMAGE_LEVEL_0,\n  IIIF_1_IMAGE_LEVEL_0_PROFILE,\n  IIIF_1_IMAGE_LEVEL_1,\n  IIIF_1_IMAGE_LEVEL_1_PROFILE,\n  IIIF_1_IMAGE_LEVEL_2,\n  IIIF_1_IMAGE_LEVEL_2_PROFILE,\n  IIIF_2_IMAGE_LEVEL_0,\n  IIIF_2_IMAGE_LEVEL_0_PROFILE,\n  IIIF_2_IMAGE_LEVEL_1,\n  IIIF_2_IMAGE_LEVEL_1_PROFILE,\n  IIIF_2_IMAGE_LEVEL_2,\n  IIIF_2_IMAGE_LEVEL_2_PROFILE,\n  IIIF_3_IMAGE_LEVEL_0,\n  IIIF_3_IMAGE_LEVEL_1,\n  IIIF_3_IMAGE_LEVEL_2,\n];\n", "import * as Presentation3 from '@iiif/presentation-3';\nimport * as Presentation2 from '@iiif/presentation-2';\nimport { imageServiceProfiles, level1Support } from '../shared/image-api-profiles';\nimport { Traverse } from './traverse';\nimport { ensureArray } from '../shared/ensure-array';\nimport { removeUndefinedProperties } from '../shared/remove-undefined-properties';\nimport { level0Support, level2Support } from '../image-3/profiles/profiles';\n\nconst configuration = {\n  attributionLabel: 'Attribution',\n  lang: 'none',\n  providerId: 'http://example.org/provider',\n  providerName: '',\n};\n\nfunction compatLanguageMap(inputLangProperty?: unknown): Array<Presentation2.LanguageProperty> {\n  if (typeof inputLangProperty === 'string') {\n    return [inputLangProperty];\n  }\n  if (!inputLangProperty) {\n    return [];\n  }\n  const arrayOfValues = Array.isArray(inputLangProperty) ? inputLangProperty : [inputLangProperty];\n\n  const languageArray: Presentation2.LanguageProperty[] = [];\n  for (const language of arrayOfValues) {\n    if (typeof language === 'string') {\n      languageArray.push(language);\n      continue;\n    }\n    languageArray.push({\n      '@language': language['@language'] || language.language,\n      '@value': language['@value'] || language.value,\n    });\n  }\n  return languageArray;\n}\n\nexport function convertLanguageMapping(\n  inputLangProperty?: Presentation2.OneOrMany<Presentation2.LanguageProperty>,\n  defaultLang = 'none'\n): Presentation3.InternationalString {\n  if (!inputLangProperty) {\n    return { none: [''] };\n  }\n\n  const arrayOfValues = compatLanguageMap(inputLangProperty);\n\n  const languageMap: Presentation3.InternationalString = {};\n\n  for (const language of arrayOfValues) {\n    // For strings \"label\": [\"a value\"]\n    if (typeof language === 'string') {\n      languageMap[defaultLang] = languageMap[defaultLang] ? languageMap[defaultLang] : [];\n      (languageMap[defaultLang] as string[]).push(language || '');\n      continue;\n    }\n\n    // For maps without a language\n    if (!language['@language']) {\n      languageMap[defaultLang] = languageMap[defaultLang] ? languageMap[defaultLang] : [];\n      (languageMap[defaultLang] as string[]).push(language['@value'] || '');\n      continue;\n    }\n\n    // Default case with language.\n    const lang = language['@language'];\n    languageMap[lang] = languageMap[lang] ? languageMap[lang] : [];\n    (languageMap[lang] as string[]).push(language['@value'] || '');\n  }\n\n  if (Object.keys(languageMap).length === 0) {\n    return { none: [''] };\n  }\n\n  return languageMap;\n}\n\nexport function getProfile(profile: any | any[]): string | undefined {\n  if (Array.isArray(profile)) {\n    return getProfile(profile.find((s) => typeof s === 'string'));\n  }\n\n  if (level2Support.indexOf(profile) !== -1) {\n    return 'level2';\n  }\n\n  if (level1Support.indexOf(profile) !== -1) {\n    return 'level1';\n  }\n\n  if (level0Support.indexOf(profile) !== -1) {\n    return 'level0';\n  }\n\n  if (typeof profile !== 'string') {\n    return undefined;\n  }\n\n  return profile;\n}\n\nexport function getTypeFromContext(inputContexts: string | string[]): string | undefined {\n  const contexts: string[] = Array.isArray(inputContexts) ? inputContexts : [inputContexts];\n\n  for (const context of contexts) {\n    switch (context) {\n      case 'http://iiif.io/api/image/2/context.json':\n      case 'http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2':\n        return 'ImageService2';\n      case 'http://iiif.io/api/image/1/context.json':\n      case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':\n        return 'ImageService1';\n      case 'http://iiif.io/api/annex/openannotation/context.json':\n        return 'ImageApiSelector';\n    }\n  }\n\n  return undefined;\n}\n\nfunction getTypeFromProfile(inputProfile: string): string | undefined {\n  switch (inputProfile) {\n    case 'http://iiif.io/api/image/2/level0.json':\n    case 'http://iiif.io/api/image/2/level1.json':\n    case 'http://iiif.io/api/image/2/level2.json':\n      return 'ImageService2';\n\n    case 'http://iiif.io/api/auth/1/kiosk':\n    case 'http://iiif.io/api/auth/1/login':\n    case 'http://iiif.io/api/auth/1/clickthrough':\n    case 'http://iiif.io/api/auth/1/external':\n    case 'http://iiif.io/api/auth/0/kiosk':\n    case 'http://iiif.io/api/auth/0/login':\n    case 'http://iiif.io/api/auth/0/clickthrough':\n    case 'http://iiif.io/api/auth/0/external':\n      return 'AuthCookieService1';\n\n    case 'http://iiif.io/api/auth/1/token':\n    case 'http://iiif.io/api/auth/0/token':\n      return 'AuthTokenService1';\n    case 'http://iiif.io/api/auth/1/logout':\n    case 'http://iiif.io/api/auth/0/logout':\n      return 'AuthLogoutService1';\n\n    case 'http://iiif.io/api/search/1/search':\n    case 'http://iiif.io/api/search/0/search':\n      return 'SearchService1';\n    case 'http://iiif.io/api/search/1/autocomplete':\n    case 'http://iiif.io/api/search/0/autocomplete':\n      return 'AutoCompleteService1';\n  }\n\n  return undefined;\n}\n\nfunction removePrefix(str: string) {\n  for (const prefix of ['sc', 'oa', 'dcterms', 'dctypes', 'iiif']) {\n    if (str.startsWith(`${prefix}:`)) {\n      return str.slice(prefix.length + 1);\n    }\n  }\n\n  return str;\n}\n\nconst knownTypes = ['Collection', 'Manifest', 'Annotation', 'AnnotationPage', 'Range', 'Service'];\n\nfunction getNewType(resource: any): string {\n  const id = resource['@id'] || resource.id;\n  let oldType: string | string[] = resource['@type'] || resource.type;\n  const profile: any = resource.profile || undefined;\n  const context: any = resource['@context'] || undefined;\n\n  if (profile) {\n    const possibleType = getTypeFromProfile(profile);\n    if (possibleType) {\n      return possibleType;\n    }\n  }\n\n  if (context) {\n    const possibleType = getTypeFromContext(context);\n    if (possibleType) {\n      return possibleType;\n    }\n  }\n\n  if (oldType) {\n    if (Array.isArray(oldType)) {\n      if (oldType.indexOf('oa:CssStylesheet') !== -1) {\n        return 'CssStylesheet';\n      }\n      if (oldType.indexOf('cnt:ContentAsText') !== -1) {\n        return 'TextualBody';\n      }\n      // Nothing we can do?\n      oldType = oldType[0]!;\n    }\n\n    for (const prefix of ['sc', 'oa', 'dcterms', 'dctypes', 'iiif']) {\n      if (oldType.startsWith(`${prefix}:`)) {\n        oldType = oldType.slice(prefix.length + 1);\n        break;\n      }\n    }\n\n    switch (oldType) {\n      case 'Layer':\n        return 'AnnotationCollection';\n      case 'AnnotationList':\n        return 'AnnotationPage';\n      case 'cnt:ContentAsText':\n        return 'TextualBody';\n      // @todo There are definitely some missing annotation types here.\n    }\n  }\n\n  if (oldType && knownTypes.indexOf(oldType) !== -1) {\n    return oldType;\n  }\n\n  if (resource.format) {\n    if (resource.format.startsWith('image/')) {\n      return 'Image';\n    }\n    if (resource.format.startsWith('text/')) {\n      return 'Text';\n    }\n    if (resource.format === 'application/pdf') {\n      return 'Text';\n    }\n    if (resource.format.startsWith('application/')) {\n      return 'Dataset';\n    }\n  }\n\n  if (id && (id.endsWith('.jpg') || id.endsWith('.png') || id.endsWith('.jpeg'))) {\n    return 'Image';\n  }\n\n  if (!oldType) {\n    return 'unknown';\n  }\n\n  // Again, nothing we can do.\n  return oldType as string;\n}\n\nconst licenseRegex = /http(s)?:\\/\\/(creativecommons.org|rightsstatements.org)[^\"'\\\\<\\n]+/gm;\n\nfunction extractLicense(license: string) {\n  const matches = license.match(licenseRegex);\n  if (matches) {\n    return matches[0];\n  }\n\n  return license;\n}\n\nasync function getContentTypeOfRemoteResource(resourceId: string): Promise<string | undefined> {\n  try {\n    const response = await fetch(resourceId, { method: 'HEAD' });\n    const headers = response.headers;\n\n    return headers.get('content-type') || undefined;\n  } catch (e) {\n    // do nothing.\n  }\n\n  return undefined;\n}\n\nfunction fixLicense(\n  license: Presentation2.RightsProperties['license'],\n  licenseLabel = 'Rights/License',\n  lang = 'none'\n): [Presentation3.DescriptiveProperties['rights'], Presentation3.DescriptiveProperties['metadata']] {\n  let rights: Presentation3.DescriptiveProperties['rights'] = null;\n  const metadata: Presentation3.DescriptiveProperties['metadata'] = [];\n\n  const licenseList = Array.isArray(license) ? license : [license];\n\n  for (const rawLicense of licenseList) {\n    const singleLicense = rawLicense ? extractLicense(rawLicense) : undefined;\n\n    if (\n      singleLicense &&\n      (singleLicense.indexOf('creativecommons.org') !== -1 || singleLicense.indexOf('rightsstatements.org') !== -1)\n    ) {\n      if (singleLicense.startsWith('https://')) {\n        rights = `http://${singleLicense.slice(8)}`;\n      } else {\n        rights = singleLicense;\n      }\n      continue;\n    }\n    if (singleLicense) {\n      metadata.push({\n        label: { [lang]: [licenseLabel] },\n        value: { [lang]: [singleLicense] },\n      });\n    }\n  }\n\n  return [rights, metadata];\n}\n\nconst removeContexts = [\n  'http://iiif.io/api/presentation/2/context.json',\n  'http://iiif.io/api/image/2/context.json',\n  'http://iiif.io/api/image/1/context.json',\n  'http://library.stanford.edu/iiif/image-api/1.1/context.json',\n  'http://iiif.io/api/search/1/context.json',\n  'http://iiif.io/api/search/0/context.json',\n  'http://iiif.io/api/auth/1/context.json',\n  'http://iiif.io/api/auth/0/context.json',\n  'http://iiif.io/api/annex/openannotation/context.json',\n];\n\nfunction fixContext(inputContext: string | string[] | undefined): string | string[] | undefined {\n  if (inputContext) {\n    const contexts = Array.isArray(inputContext) ? inputContext : [inputContext];\n\n    const newContexts = [];\n    for (const context of contexts) {\n      if (context === 'http://iiif.io/api/presentation/2/context.json') {\n        newContexts.push('http://iiif.io/api/presentation/3/context.json');\n      }\n      if (removeContexts.indexOf(context) !== -1) {\n        continue;\n      }\n      newContexts.push(context);\n    }\n\n    if (contexts.length) {\n      return newContexts.length === 1 ? newContexts[0] : newContexts;\n    }\n  }\n\n  return undefined;\n}\n\nfunction convertMetadata(\n  metadata: Presentation2.DescriptiveProperties['metadata']\n): Presentation3.DescriptiveProperties['metadata'] {\n  if (!metadata) {\n    return [];\n  }\n\n  return metadata.map((item): Presentation3.MetadataItem => {\n    return {\n      label: convertLanguageMapping(item.label),\n      value: convertLanguageMapping(item.value),\n    };\n  });\n}\n\nlet mintedIdCounter = 0;\n\nfunction mintNewIdFromResource(\n  resource: Presentation3.SomeRequired<Presentation2.TechnicalProperties, '@type'>,\n  subResource?: string\n) {\n  const origId = encodeURI((resource as { id?: string }).id || resource['@id'] || '').trim();\n\n  if (origId && subResource) {\n    return `${origId}/${subResource}`;\n  }\n\n  if (origId) {\n    return origId;\n  }\n\n  mintedIdCounter++;\n\n  // @todo.\n  return `http://example.org/${resource['@type']}${subResource ? `/${subResource}` : ''}/${mintedIdCounter}`;\n}\n\n// @todo this was removed due to identifiers not being able to be used externally after upgrading.\nfunction resolveDecodedURI(uri: string) {\n  return encodeURI(decodeURIComponent(uri)).trim();\n}\n\nfunction technicalProperties<T extends Partial<Presentation3.TechnicalProperties>>(\n  resource: Presentation3.SomeRequired<Presentation2.TechnicalProperties, '@type'> & {\n    motivation?: string | string[] | null;\n    format?: string;\n    profile?: any;\n    '@context'?: string | string[] | undefined;\n  }\n) {\n  const allBehaviors = [...(resource.behavior || [])];\n\n  if (resource.viewingHint) {\n    allBehaviors.push(resource.viewingHint);\n  }\n\n  let motivation: string | string[] | undefined;\n  if (Array.isArray(resource.motivation)) {\n    motivation = resource.motivation.map(removePrefix);\n  } else if (resource.motivation) {\n    motivation = removePrefix(resource.motivation);\n  }\n\n  return {\n    '@context': resource['@context'] ? fixContext(resource['@context']) : undefined,\n    id: (resource['@id'] || mintNewIdFromResource(resource)).trim(),\n    type: getNewType(resource) as any,\n    behavior: allBehaviors.length ? allBehaviors : undefined,\n    // format: This will be an optional async post-process step.\n    height: resource.height ? resource.height : undefined,\n    width: resource.width ? resource.width : undefined,\n    motivation,\n    viewingDirection: resource.viewingDirection,\n    profile: resource.profile,\n    format: resource.format ? resource.format : undefined,\n    duration: undefined,\n    timeMode: undefined,\n  } as any;\n}\n\nfunction descriptiveProperties<T extends Partial<Presentation3.DescriptiveProperties>>(\n  resource: Presentation2.DescriptiveProperties &\n    Presentation2.RightsProperties &\n    Partial<Presentation2.TechnicalProperties>\n): T {\n  const [rights, extraMetadata] = fixLicense(resource.license);\n  const allMetadata = [...(resource.metadata ? convertMetadata(resource.metadata) : []), ...extraMetadata];\n\n  return {\n    rights,\n    metadata: allMetadata.length ? allMetadata : undefined,\n    label: resource.label ? convertLanguageMapping(resource.label) : undefined,\n    requiredStatement: resource.attribution\n      ? {\n        label: convertLanguageMapping(configuration.attributionLabel),\n        value: convertLanguageMapping(resource.attribution),\n      }\n      : undefined,\n    navDate: resource.navDate,\n    summary: resource.description ? convertLanguageMapping(resource.description) : undefined,\n    thumbnail: compatThumbnail(resource.thumbnail as any),\n  } as T;\n}\n\nfunction compatThumbnail(thumb: any) {\n  if (thumb) {\n    const arrayOfThumbs = Array.isArray(thumb) ? thumb : [thumb];\n    return arrayOfThumbs.map((t) => {\n      if (typeof t === 'string') {\n        return { id: t, type: 'Image' };\n      }\n      if (t.type === 'unknown') {\n        t.type = 'Image';\n      }\n      return t;\n    });\n  }\n  return thumb;\n}\n\nfunction parseWithin(resource: Presentation2.AbstractResource): undefined | Presentation3.LinkingProperties['partOf'] {\n  if (!resource.within) {\n    return undefined;\n  }\n\n  const withinProperties = Array.isArray(resource.within) ? resource.within : [resource.within];\n  const returnPartOf: Presentation3.LinkingProperties['partOf'] = [];\n\n  for (const within of withinProperties) {\n    if (typeof within === 'string') {\n      if (within) {\n        switch (resource['@type']) {\n          case 'sc:Manifest':\n            returnPartOf.push({ id: within, type: 'Collection' });\n            break;\n          // @todo are there more cases?\n        }\n      }\n    } else if ((within as any)['@id']) {\n      returnPartOf.push({\n        id: (within as any)['@id'], // as any since content resources don't require an `@id`\n        type: getNewType(within) as any,\n      });\n    } else {\n      // Content resource.\n    }\n  }\n\n  return returnPartOf.length ? returnPartOf : undefined;\n}\n\nfunction linkingProperties(resource: Presentation2.LinkingProperties & Presentation2.RightsProperties) {\n  // @todo related links to metadata.\n\n  const related = resource.related ? (Array.isArray(resource.related) ? resource.related : [resource.related]) : [];\n  const layer = resource.contentLayer as Presentation2.Layer;\n\n\n  return {\n    provider:\n      resource.logo || related.length\n        ? [\n          {\n            id: configuration.providerId,\n            type: 'Agent' as const,\n            homepage: related.length ? [related[0] as any] : undefined,\n            logo: resource.logo ? (Array.isArray(resource.logo) ? resource.logo : [resource.logo]) : undefined,\n            label: convertLanguageMapping(configuration.providerName),\n          },\n        ]\n        : undefined,\n    partOf: parseWithin(resource),\n    rendering: resource.rendering,\n    seeAlso: resource.seeAlso,\n    start: resource.startCanvas as any,\n    service: resource.service ? ensureArray(resource.service as any) : undefined,\n    supplementary: layer ? [layer as any] : undefined,\n  };\n}\n\n// FIXME: Is this function really needed?\nfunction embeddedContentProperties(resource: Presentation2.CharsEmbeddedContent) {\n  return {\n    chars: resource.chars,\n    format: resource.format ? resource.format : undefined,\n    language: resource.language,\n  };\n}\n\nfunction stringOrRefToRef(object: any, type: string) {\n  if (!object) return null;\n  if (typeof object === 'string') {\n    return {\n      id: object,\n      type,\n    };\n  }\n\n  if (typeof object?.['@id'] === 'string') {\n    return {\n      id: object['@id'],\n      type,\n    };\n  }\n\n  if (typeof object.id === 'string') {\n    return {\n      id: object.id,\n      type,\n    };\n  }\n\n  return null;\n}\n\nfunction paginationProperties(collection: Presentation2.Collection) {\n  // This is a sort of \"IIIF Presentation 3.1\" upgrade before 4.0 adds Collections and CollectionPages.\n  // v2 supports paged Collections, so this is a stop-gap solution. Strict implementations can ignore it.\n  // Properties:\n  //  - first\n  //  - total\n  //  - prev\n  //  - next\n  const additionalProperties: any = {};\n\n  if ((collection as any).first) {\n    // Note: This is a stop-gap solution for \"v3.1\", which does not have CollectionPages.\n    const ref = stringOrRefToRef((collection as any).first, 'Collection');\n    if (ref) {\n      additionalProperties.first = ref;\n    }\n  }\n\n  if ((collection as any).total || (collection as any).total === 0) {\n    additionalProperties.total = (collection as any).total;\n  }\n\n  if ((collection as any).prev) {\n    const ref = stringOrRefToRef((collection as any).prev, 'Collection');\n    if (ref) {\n      additionalProperties.prev = ref;\n    }\n  }\n\n  if ((collection as any).next) {\n    const ref = stringOrRefToRef((collection as any).next, 'Collection');\n    if (ref) {\n      additionalProperties.next = ref;\n    }\n  }\n\n  return additionalProperties as any;\n}\n\nfunction removeEmptyItems(resources: any[]) {\n  const toReturn = [];\n  for (const originalResource of resources) {\n    const resource = {...originalResource};\n    if (resource.items && resource.items.length === 0) {\n      delete resource.items;\n    }\n    toReturn.push(resource);\n  }\n  return toReturn;\n}\n\nfunction upgradeCollection(collection: Presentation2.Collection): Presentation3.Collection {\n  return removeUndefinedProperties({\n    ...technicalProperties(collection),\n    ...descriptiveProperties<Presentation3.SomeRequired<Presentation3.CollectionDescriptive, 'label'>>(collection),\n    ...linkingProperties(collection),\n    ...paginationProperties(collection),\n    items: removeEmptyItems(collection.members as any),\n  });\n}\n\nfunction flattenArray<T>(array: T[][]): T[] {\n  const returnArr: T[] = [];\n  for (const arr of array || []) {\n    returnArr.push(...arr);\n  }\n  return returnArr;\n}\n\nfunction upgradeManifest(manifest: Presentation2.Manifest): Presentation3.Manifest {\n  const allCanvases = [];\n  const behavior = [];\n  let start = undefined;\n  let viewingDirection = undefined;\n  for (const sequence of manifest.sequences || []) {\n    if (sequence.canvases.length) {\n      allCanvases.push(...sequence.canvases);\n    }\n    if (sequence.behavior) {\n      behavior.push(...sequence.behavior);\n    }\n    if (sequence.viewingDirection) {\n      viewingDirection = sequence.viewingDirection;\n    }\n    if (sequence.startCanvas) {\n      start = sequence.startCanvas;\n    }\n  }\n\n  // This comes from the sequence.\n  const technical = technicalProperties(manifest);\n  if (behavior.length) {\n    if (technical.behavior) {\n      technical.behavior.push(...behavior);\n    } else {\n      technical.behavior = behavior;\n    }\n  }\n\n  return removeUndefinedProperties({\n    ...technical,\n    ...descriptiveProperties(manifest),\n    ...linkingProperties(manifest),\n    viewingDirection,\n    start: start,\n    items: allCanvases,\n    structures: flattenStructures(manifest.structures as any),\n  });\n}\n\nfunction flattenStructures(structures: Presentation3.Range[]): Presentation3.Range[] {\n  if (!structures) {\n    return structures;\n  }\n  const ranges = new Map<string, Presentation3.Range>();\n  for (const range of structures) {\n    ranges.set(range.id, range);\n  }\n\n  let found: string[] = [];\n\n  for (const range of structures) {\n    if (range.items) {\n      const items = range.items.map((item) => {\n        if (typeof item === 'string') {\n          found.push(item);\n          return ranges.get(item) || item;\n        }\n        if (item && item.id) {\n          found.push(item.id);\n          return ranges.get(item.id) || item;\n        }\n        return item;\n      });\n      range.items = items;\n    }\n  }\n\n  return structures.filter((range) => found.indexOf(range.id) === -1);\n}\n\nfunction upgradeCanvas(canvas: Presentation2.Canvas): Presentation3.Canvas {\n  return removeUndefinedProperties({\n    ...technicalProperties(canvas),\n    ...descriptiveProperties(canvas),\n    ...linkingProperties(canvas),\n    annotations: canvas.otherContent && canvas.otherContent.length ? (canvas.otherContent as any[]) : undefined,\n    items:\n      canvas.images && canvas.images.length\n        ? [\n          {\n            id: mintNewIdFromResource(canvas, 'annotation-page'),\n            type: 'AnnotationPage',\n            items: canvas.images as any,\n          },\n        ]\n        : undefined,\n  });\n}\n\nfunction upgradeAnnotationList(annotationPage: Presentation2.AnnotationList): Presentation3.AnnotationPage {\n  return removeUndefinedProperties({\n    ...(technicalProperties(annotationPage) as any),\n    ...(descriptiveProperties(annotationPage) as any),\n    ...(linkingProperties(annotationPage) as any),\n    items: annotationPage.resources && annotationPage.resources.length ? (annotationPage.resources as any) : undefined,\n  });\n}\n\nfunction upgradeSequence(sequence: Presentation2.Sequence): {\n  canvases: Presentation3.Canvas[];\n  behavior?: string[];\n  startCanvas?: Presentation3.Reference<'Canvas'> | undefined;\n  viewingDirection?: 'left-to-right' | 'right-to-left' | 'top-to-bottom' | 'bottom-to-top';\n} {\n  /*\n    rng = {\"id\": s.get('@id', self.mint_uri()), \"type\": \"Range\"}\n    rng['behavior'] = ['sequence']\n    rng['items'] = []\n    for c in s['canvases']:\n      if type(c) == dict:\n        rng['items'].append({\"id\": c['@id'], \"type\": \"Canvas\"})\n      elif type(c) in STR_TYPES:\n        rng['items'].append({\"id\": c, \"type\": \"Canvas\"})\n    # Copy other properties and hand off to _generic\n    del s['canvases']\n    for k in s.keys():\n      if not k in ['@id', '@type']:\n        rng[k] = s[k]\n    self.process_generic(rng)\n    what['_structures'].append(rng)\n   */\n\n  if (!sequence.canvases || sequence.canvases.length === 0) {\n    return {\n      canvases: [],\n      behavior: [],\n    };\n  }\n  // @todo possibly return some ranges too.\n  return {\n    canvases: sequence.canvases as any[],\n    behavior: sequence.viewingHint ? [sequence.viewingHint] : [],\n    viewingDirection: sequence.viewingDirection,\n    startCanvas: sequence.startCanvas as any,\n  };\n}\n\nfunction upgradeAnnotation(annotation: Presentation2.Annotation): Presentation3.Annotation {\n  function upgradeTarget(target: typeof annotation.on): Presentation3.AnnotationTarget {\n    if (Array.isArray(target)) {\n      if (target.length > 1) {\n        return { type: 'List', items: target.map(upgradeTarget) as Presentation3.Target[] };\n      }\n      target = target[0]!;\n    }\n    if (typeof target === 'string') {\n      return encodeURI(target).trim();\n    } else if ('@type' in target) {\n      let source: string | Presentation3.Reference<'Canvas'> | Presentation3.Reference<'Image'>;\n      if (typeof target.full === 'string') {\n        source = target.full;\n      } else if (target.full['@type'] === 'dctypes:Image') {\n        source = { id: target.full['@id'], type: 'Image' };\n      } else if (target.full['@type'] === 'sc:Canvas') {\n        source = { id: target.full['@id'], type: 'Canvas' };\n      } else {\n        throw new Error(`Unsupported source type on annotation: ${target.full['@type']}`);\n      }\n      return {\n        type: 'SpecificResource',\n        source,\n        selector: upgradeSelector(target.selector),\n      };\n    } else {\n      return encodeURI(target['@id']).trim();\n    }\n  }\n  return removeUndefinedProperties({\n    ...(technicalProperties(annotation) as any),\n    ...(descriptiveProperties(annotation) as any),\n    ...(linkingProperties(annotation) as any),\n    target: upgradeTarget(annotation.on),\n    body: Array.isArray(annotation.resource)\n      ? annotation.resource.map(upgradeContentResourceOrChoice)\n      : upgradeContentResourceOrChoice(annotation.resource),\n    // @todo stylesheet upgrade.\n  });\n}\n\nfunction upgradeContentResourceOrChoice(\n  resource: Presentation2.ContentResource | Presentation2.ChoiceEmbeddedContent\n): Presentation3.ContentResource | Presentation3.ChoiceBody {\n  if ((resource as any).type === 'Choice') {\n    return resource as any;\n  }\n  return upgradeContentResource(resource);\n}\n\nfunction upgradeContentResource(inputContentResource: Presentation2.ContentResource): Presentation3.ContentResource {\n  const contentResource = inputContentResource as Presentation2.CommonContentResource;\n\n  // @todo there might be some field dropped here.\n  return removeUndefinedProperties({\n    ...(technicalProperties(contentResource) as any),\n    ...(descriptiveProperties(contentResource) as any),\n    ...(linkingProperties(contentResource as any) as any),\n    ...(embeddedContentProperties(contentResource as any) as any),\n  });\n}\n\nfunction upgradeChoice(choice: Presentation2.ChoiceEmbeddedContent): Presentation3.ChoiceBody {\n  const items = [];\n\n  if (choice.default && choice.default !== 'rdf:nil') {\n    items.push(choice.default);\n  }\n\n  if (choice.item && choice.item !== 'rdf:nil') {\n    items.push(...choice.item);\n  }\n\n  return removeUndefinedProperties({\n    ...technicalProperties(choice),\n    ...descriptiveProperties(choice),\n    items: items as any,\n  });\n}\n\nfunction upgradeRange(range: Presentation2.Range): Presentation3.Range {\n  // range.members;\n  // range.canvases;\n  // Range.\n  // At the moment a range only references other ranges by id.\n  // So we need to first get\n  return removeUndefinedProperties({\n    ...technicalProperties(range),\n    ...descriptiveProperties(range),\n    ...linkingProperties(range),\n    items: range.members as any,\n  } as Presentation3.Range);\n}\n\nfunction upgradeService(service: Presentation2.Service): Presentation3.Service {\n  const { '@id': id, '@type': type, '@context': context, profile, ...additionalProps } = service as any;\n\n  const newService: any = {};\n\n  if (id) {\n    newService['@id'] = id;\n  }\n\n  newService['@type'] = getNewType(service);\n\n  if (newService['@type'] === 'unknown') {\n    // @todo handle case where there might be multiple contexts.\n    if (context && context.length) {\n      newService['@context'] = context;\n    }\n    newService['@type'] = 'Service'; // optional on services.\n  }\n\n  if (profile) {\n    newService.profile = getProfile(profile);\n  }\n\n  return removeUndefinedProperties({\n    ...newService,\n    ...additionalProps,\n  });\n}\n\nfunction upgradeLayer(layer: Presentation2.Layer): Presentation3.AnnotationCollection {\n  return removeUndefinedProperties({\n    ...technicalProperties(layer),\n    ...descriptiveProperties(layer),\n    ...linkingProperties(layer),\n  });\n}\n\nexport const presentation2to3 = new Traverse<{\n  Collection: Presentation3.Collection;\n  Manifest: Presentation3.Manifest;\n  Canvas: Presentation3.Canvas;\n  AnnotationList: Presentation3.AnnotationPage;\n  Sequence: Presentation3.Canvas[];\n  Annotation: Presentation3.Annotation;\n  ContentResource: Presentation3.ContentResource;\n  Choice: Presentation3.ChoiceBody;\n  Range: Presentation3.Range;\n  Service: Presentation3.Service;\n  Layer: Presentation3.AnnotationCollection;\n}>({\n  collection: [upgradeCollection],\n  manifest: [upgradeManifest],\n  canvas: [upgradeCanvas],\n  annotationList: [upgradeAnnotationList],\n  sequence: [upgradeSequence],\n  annotation: [upgradeAnnotation],\n  contentResource: [upgradeContentResource],\n  choice: [upgradeChoice],\n  range: [upgradeRange],\n  service: [upgradeService],\n  layer: [upgradeLayer],\n});\n\nexport function convertPresentation2(entity: any): Presentation3.Manifest | Presentation3.Collection {\n  if (\n    (entity &&\n      entity['@context'] &&\n      (entity['@context'] === 'http://iiif.io/api/presentation/2/context.json' ||\n        entity['@context'].indexOf('http://iiif.io/api/presentation/2/context.json') !== -1 ||\n        // Yale context.\n        entity['@context'] === 'http://www.shared-canvas.org/ns/context.json')) ||\n    entity['@context'] === 'http://iiif.io/api/image/2/context.json' ||\n    // No-context is possible.\n    (entity['@id'] && entity['@type'] === 'sc:Collection') ||\n    (entity['@id'] && entity['@type'] === 'sc:Manifest')\n  ) {\n    if (!entity['@context']) {\n      entity['@context'] = 'http://iiif.io/api/presentation/2/context.json';\n    }\n    return presentation2to3.traverseUnknown(entity);\n  }\n  return entity;\n}\n\nfunction upgradeSelector(\n  selector: Presentation2.ContentResourceSelector\n): Presentation3.Selector | Presentation3.Selector[] {\n  const isSvgSelector =\n    ((Array.isArray(selector['@type']) && selector['@type'].includes('oa:SvgSelector')) ||\n      selector['@type'] == 'oa:SvgSelector') &&\n    ('chars' in selector || 'value' in selector);\n  if (isSvgSelector) {\n    return {\n      type: 'SvgSelector',\n      value: 'chars' in selector ? selector.chars : selector.value,\n    };\n  }\n  if (selector['@type'] === 'oa:FragmentSelector') {\n    return {\n      type: 'FragmentSelector',\n      value: selector.value,\n    };\n  }\n  if (selector['@type'] === 'oa:Choice') {\n    return [\n      upgradeSelector(selector.default) as Presentation3.Selector,\n      ...((Array.isArray(selector.item) ? selector.item : [selector.item]).map(\n        upgradeSelector\n      ) as Presentation3.Selector[]),\n    ];\n  }\n  if (selector['@type'] == 'iiif:ImageApiSelector') {\n    return {\n      type: 'ImageApiSelector',\n      region: 'region' in selector ? selector.region : undefined,\n      rotation: 'rotation' in selector ? selector.rotation : undefined,\n    };\n  }\n  throw new Error(`Unsupported selector type: ${selector['@type']}`);\n}\n", "import { Reference } from '@iiif/presentation-3';\nimport { isSpecificResource } from './is-specific-resource';\n\nexport function toRef<T extends string = any>(reference: any, _typeHint?: T): Reference<T> | undefined {\n  const type = (_typeHint || 'unknown') as T;\n\n  if (!reference) {\n    return undefined;\n  }\n\n  if (typeof reference === 'string') {\n    return { id: reference, type };\n  }\n\n  if (isSpecificResource(reference)) {\n    return toRef(reference.source, _typeHint);\n  }\n\n  let _type = type && type !== 'unknown' ? type : (reference as any).type || (reference as any)['@type'];\n  const _id = (reference as any).id || (reference as any)['@id'];\n\n  if (_type && _type.indexOf(':') !== -1) {\n    _type = _type.split(':').pop();\n  }\n\n  if (_id && _type) {\n    return { id: _id, type: _type };\n  }\n\n  return undefined;\n}\n", "import { CompatibleStore, NormalizedEntity } from './serialize';\nimport { toRef } from '../shared/to-ref';\n\nexport const WILDCARD = {};\nexport const HAS_PART = 'iiif-parser:hasPart';\nexport const PART_OF = 'iiif-parser:partOf';\nexport const IS_EXTERNAL = 'iiif-parser:isExternal';\nexport const UNSET = '__$UNSET$__';\nexport const UNWRAP = '__$UNWRAP$__';\nexport const EMPTY = [];\n\n// Prevent accidental mutation\nObject.freeze(EMPTY);\nObject.freeze(WILDCARD);\n\nexport function isWildcard(object: any) {\n  if (object === WILDCARD || Object.keys(object).length === 0) {\n    return true;\n  }\n  for (const i in object) {\n    return false;\n  }\n  return true;\n}\n\nexport function frameResource(resource: any, framing: any) {\n  if (framing && framing['@explicit']) {\n    const newEntity: any = {};\n    const keys = Object.keys(framing);\n    for (const key of keys) {\n      if (key === PART_OF || key === '@explicit') {\n        continue;\n      }\n      if (isWildcard(framing[key])) {\n        newEntity[key] = resource[key];\n      } else {\n        newEntity[key] = framing[key];\n      }\n    }\n    return newEntity;\n  }\n\n  return resource;\n}\n\nexport function resolveIfExists<T extends NormalizedEntity>(\n  state: CompatibleStore,\n  urlOrResource: any,\n  parent?: any\n): readonly [T | undefined, T | undefined] {\n  const ref = toRef(urlOrResource);\n  if (!ref) {\n    return [undefined, undefined];\n  }\n\n  const request = state.requests[ref.id];\n  // Return the resource.\n  const resourceType = ref.type || state.mapping[ref.id];\n  if (!resourceType || (request && request.resourceUri && (!state.entities[resourceType] || !state.entities[resourceType]![request.resourceUri]))) {\n    // Continue refetching resource, this is an invalid state.\n    return [undefined, undefined];\n  }\n\n  const fullEntity: any = state.entities[resourceType]![request ? request.resourceUri : ref.id] as T;\n\n  if (ref.type && !fullEntity) {\n    return resolveIfExists(state, { id: ref.id }, parent);\n  }\n\n  if (fullEntity && fullEntity[HAS_PART]) {\n    const framing = fullEntity[HAS_PART].find((t: any) => {\n      return parent ? t[PART_OF] === parent.id : t[PART_OF] === fullEntity.id;\n    });\n\n    const newEntity = frameResource(fullEntity, framing);\n    return [newEntity, fullEntity];\n  }\n\n  return [fullEntity, fullEntity];\n}\n", "import {\n  AnnotationNormalized,\n  AnnotationPageNormalized,\n  CanvasNormalized,\n  CollectionNormalized,\n  ManifestNormalized,\n  RangeNormalized,\n  ResourceProviderNormalized,\n} from '@iiif/presentation-3-normalized';\nimport { _ServiceNormalized } from './serialize';\nimport { EMPTY } from './utilities';\n\nexport const emptyAnnotation: AnnotationNormalized = {\n  id: 'https://iiif-parser/annotation',\n  type: 'Annotation',\n  behavior: EMPTY,\n  label: null,\n  thumbnail: EMPTY,\n  summary: null,\n  requiredStatement: null,\n  metadata: EMPTY,\n  seeAlso: EMPTY,\n  homepage: EMPTY,\n  rendering: EMPTY,\n  service: EMPTY,\n  accessibility: EMPTY,\n  audience: EMPTY,\n  body: EMPTY,\n  bodyValue: null,\n  canonical: null,\n  created: null,\n  creator: EMPTY,\n  generated: null,\n  generator: EMPTY,\n  modified: null,\n  motivation: EMPTY,\n  rights: null as any, // @todo bug? should not be array of strings.\n  stylesheet: null,\n  target: EMPTY,\n  timeMode: undefined, // @todo bug? should be null.\n  via: EMPTY,\n  partOf: EMPTY,\n};\n\nexport const emptyAnnotationPage: AnnotationPageNormalized = {\n  id: 'https://iiif-parser/annotation-page',\n  type: 'AnnotationPage',\n  behavior: EMPTY,\n  label: null,\n  thumbnail: EMPTY,\n  summary: null,\n  requiredStatement: null,\n  metadata: EMPTY,\n  rights: null,\n  provider: EMPTY,\n  items: EMPTY,\n  seeAlso: EMPTY,\n  homepage: EMPTY,\n  rendering: EMPTY,\n  service: EMPTY,\n};\n\nexport const emptyCanvas: CanvasNormalized = {\n  id: 'https://iiif-parser/empty-canvas',\n  type: 'Canvas',\n  label: null,\n  behavior: EMPTY,\n  thumbnail: EMPTY,\n  accompanyingCanvas: null,\n  placeholderCanvas: null,\n  summary: null,\n  requiredStatement: null,\n  metadata: EMPTY,\n  rights: null,\n  navDate: null,\n  provider: EMPTY,\n  items: EMPTY,\n  annotations: EMPTY,\n  seeAlso: EMPTY,\n  homepage: EMPTY,\n  partOf: EMPTY,\n  rendering: EMPTY,\n  service: EMPTY,\n  duration: 0,\n  height: 0,\n  width: 0,\n};\n\nexport const emptyCollection: CollectionNormalized = {\n  id: 'https://iiif-parser/empty-collection',\n  type: 'Collection',\n  label: null,\n  viewingDirection: 'left-to-right',\n  behavior: EMPTY,\n  thumbnail: EMPTY,\n  accompanyingCanvas: null,\n  placeholderCanvas: null,\n  summary: null,\n  requiredStatement: null,\n  metadata: EMPTY,\n  rights: null,\n  navDate: null,\n  provider: EMPTY,\n  items: EMPTY,\n  annotations: EMPTY,\n  seeAlso: EMPTY,\n  homepage: EMPTY,\n  partOf: EMPTY,\n  rendering: EMPTY,\n  service: EMPTY,\n  services: EMPTY,\n};\n\nexport const emptyManifest: ManifestNormalized = {\n  id: 'https://iiif-parser/empty-manifest',\n  type: 'Manifest',\n  annotations: EMPTY,\n  behavior: EMPTY,\n  homepage: EMPTY,\n  items: EMPTY,\n  label: null,\n  metadata: EMPTY,\n  navDate: null,\n  provider: EMPTY,\n  partOf: EMPTY,\n  accompanyingCanvas: null,\n  placeholderCanvas: null,\n  rendering: EMPTY,\n  requiredStatement: null,\n  rights: null,\n  seeAlso: EMPTY,\n  service: EMPTY,\n  services: EMPTY,\n  start: null,\n  structures: EMPTY,\n  summary: null,\n  thumbnail: EMPTY,\n  viewingDirection: 'left-to-right',\n};\n\nexport const emptyRange: RangeNormalized = {\n  id: 'https://iiif-parser/empty-canvas',\n  type: 'Range',\n  label: null,\n  behavior: EMPTY,\n  thumbnail: EMPTY,\n  accompanyingCanvas: null,\n  placeholderCanvas: null,\n  summary: null,\n  requiredStatement: null,\n  metadata: EMPTY,\n  rights: null,\n  navDate: null,\n  provider: EMPTY,\n  items: EMPTY,\n  annotations: EMPTY,\n  seeAlso: EMPTY,\n  homepage: EMPTY,\n  partOf: EMPTY,\n  rendering: EMPTY,\n  service: EMPTY,\n  start: null,\n  supplementary: null,\n  viewingDirection: 'left-to-right',\n};\n\nexport const emptyAgent: ResourceProviderNormalized = {\n  id: 'https://iiif-parser/empty-agent',\n  type: 'Agent',\n  label: {},\n  logo: EMPTY,\n  seeAlso: EMPTY,\n  homepage: EMPTY,\n};\n\nexport const emptyService: _ServiceNormalized = {\n  id: 'https://iiif-parser/empty-service',\n  type: 'UnknownService',\n} as any;\n", "import type { ExternalWebResource, SpecificResource, W3CAnnotationTarget } from '@iiif/presentation-3';\n\nexport function expandTargetToSpecificResource(\n  target: W3CAnnotationTarget | W3CAnnotationTarget[],\n  options: {\n    typeMap?: Record<string, string>;\n    typeHint?: string;\n  } = {}\n): SpecificResource {\n  if (Array.isArray(target)) {\n    // Don't support multiple targets for now.\n    return expandTargetToSpecificResource(target[0]!);\n  }\n\n  if (typeof target === 'string') {\n    const [id, fragment] = target.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: {\n          id,\n          type: (options.typeMap && (options.typeMap[id!] as any)) || options.typeHint || 'Unknown',\n        },\n      };\n    }\n\n    return {\n      type: 'SpecificResource',\n      source: { id, type: options.typeHint || 'Unknown' },\n      selector: {\n        type: 'FragmentSelector',\n        value: fragment,\n      },\n    };\n  }\n\n  // @todo, how do we want to support choices for targets.\n  if (\n    target.type === 'Choice' ||\n    target.type === 'List' ||\n    target.type === 'Composite' ||\n    target.type === 'Independents'\n  ) {\n    // we also don't support these, just choose the first.\n    return expandTargetToSpecificResource(target.items[0]!);\n  }\n\n  if (!target.type && 'source' in target) {\n    (target as any).type = 'SpecificResource';\n  }\n\n  if (target.type === 'SpecificResource') {\n    if (target.source.type === 'Canvas' && target.source.partOf && typeof target.source.partOf === 'string') {\n      target.source.partOf = [\n        {\n          id: target.source.partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n    const targetId = typeof target.source === 'string' ? target.source : target.source.id;\n    if (targetId?.includes('#')) {\n      const parsed = expandTargetToSpecificResource(targetId, options);\n      if (parsed) {\n        target.selector = parsed.selector;\n        target.source = parsed.source;\n      }\n    }\n\n    if (target.selector) {\n      return {\n        ...target,\n        type: 'SpecificResource',\n        source: target.source,\n        selector: target.selector,\n      };\n    }\n    return {\n      ...target,\n      type: 'SpecificResource',\n      source: target.source,\n    };\n  }\n\n  if (target.id) {\n    if ((target as any).type === 'Canvas' && (target as any).partOf && typeof (target as any).partOf === 'string') {\n      (target as any).partOf = [\n        {\n          id: (target as any).partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n\n    const [id, fragment] = target.id.split('#');\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: {\n          ...(target as any),\n          id,\n        },\n      };\n    }\n\n    return {\n      type: 'SpecificResource',\n      source: {\n        ...(target as any),\n        id,\n      },\n      selector: {\n        type: 'FragmentSelector',\n        value: fragment,\n      },\n    };\n  }\n\n  return {\n    type: 'SpecificResource',\n    source: target as ExternalWebResource,\n  };\n}\n", "import type {\n  Annotation,\n  AnnotationPage,\n  Canvas,\n  Collection,\n  Manifest,\n  PolyEntity,\n  Range,\n  Reference,\n  ResourceProvider,\n  Selector,\n  Service,\n  SpecificResource,\n} from '@iiif/presentation-3';\nimport type {\n  AnnotationPageNormalized,\n  CanvasNormalized,\n  CollectionNormalized,\n  ManifestNormalized,\n  RangeNormalized,\n  ResourceProviderNormalized,\n} from '@iiif/presentation-3-normalized';\nimport { convertPresentation2 } from '../presentation-2';\nimport { expandTargetToSpecificResource } from '../shared/expand-target';\nimport { isSpecificResource } from '../shared/is-specific-resource';\nimport {\n  emptyAgent,\n  emptyAnnotationPage,\n  emptyCanvas,\n  emptyCollection,\n  emptyManifest,\n  emptyRange,\n  emptyService,\n} from './empty-types';\nimport type { CompatibleStore, NormalizedEntity } from './serialize';\nimport { type TraversalContext, Traverse } from './traverse';\nimport { EMPTY, HAS_PART, IS_EXTERNAL, PART_OF, WILDCARD } from './utilities';\n\nexport const defaultEntities = {\n  Collection: {},\n  Manifest: {},\n  Canvas: {},\n  AnnotationPage: {},\n  AnnotationCollection: {},\n  Annotation: {},\n  ContentResource: {},\n  Range: {},\n  Service: {},\n  Selector: {},\n  Agent: {},\n};\n\nexport function getDefaultEntities() {\n  return {\n    Collection: {},\n    Manifest: {},\n    Canvas: {},\n    AnnotationPage: {},\n    AnnotationCollection: {},\n    Annotation: {},\n    ContentResource: {},\n    Range: {},\n    Service: {},\n    Selector: {},\n    Agent: {},\n  };\n}\n\nfunction getResource(entityOrString: PolyEntity, type: string): Reference {\n  if (typeof entityOrString === 'string') {\n    return { id: entityOrString, type };\n  }\n  if (!entityOrString.id) {\n    throw new Error(`Invalid resource does not have an ID (${JSON.stringify(entityOrString)}, ${type})`);\n  }\n  return entityOrString as Reference;\n}\n\nfunction mapToEntities(entities: Record<string, Record<string, NormalizedEntity>>, topLevel: any) {\n  return <T extends Reference | string>(type: string, defaultStringType?: string) => {\n    const storeType = entities[type] ? entities[type]! : {};\n    return (r: T, context: TraversalContext): T => {\n      const resource = getResource(r, defaultStringType || type);\n      if (resource && resource.id && type) {\n        storeType[resource.id] = storeType[resource.id]\n          ? (mergeEntities(storeType[resource.id]!, resource, {\n              parent: context.parent,\n              isTopLevel: topLevel.id === resource.id,\n            }) as any)\n          : mergeEntities({ id: resource.id, type: resource.type } as any, resource, {\n              parent: context.parent,\n              isTopLevel: topLevel.id === resource.id,\n            });\n        return {\n          id: resource.id,\n          type: type === 'ContentResource' ? type : resource.type,\n        } as T;\n      }\n      return resource as T;\n    };\n  };\n}\n\nexport function merge(existing: any, incoming: any, context?: { parent?: any; isTopLevel?: boolean }): any {\n  if (!incoming) {\n    // Falsy values are ignored\n    return existing;\n  }\n  if (Array.isArray(existing)) {\n    if (!Array.isArray(incoming)) {\n      throw new Error('Cannot merge array with non-array');\n    }\n    // For arrays, we check if any of the incoming values are not already in the\n    // existing values and add them if this is not the case. If the incoming\n    // value is an entity that is already in the existing values, it will be\n    // merged with the existing value.\n    const merged = [...existing];\n    for (const item of incoming) {\n      if (item['@id'] && !item.id) {\n        item.id = item['@id'];\n      }\n      if (item['@type'] && !item.type) {\n        item.type = item['@type'];\n      }\n      if (item === null || item === undefined) {\n        continue;\n      }\n      if (Array.isArray(item)) {\n        // FIXME: How to handle this properly?\n        merged.push(item);\n      } else if (typeof item === 'object' && item.id && item.type) {\n        const existingIdx = merged.findIndex((e) => e.id === item.id && e.type === item.type);\n        if (existingIdx >= 0) {\n          merged[existingIdx] = merge(merged[existingIdx], item);\n        }\n      } else if (existing.indexOf(item) === -1) {\n        merged.push(item);\n      }\n    }\n    return merged;\n  } else if (typeof existing === 'object') {\n    if (Array.isArray(incoming) || typeof incoming !== 'object') {\n      throw new Error('Cannot merge object with non-object');\n    }\n    // For objects, we check the existing object for non-existing or \"empty\"\n    // properties and use the value from the incoming object for them\n    const merged = { ...existing };\n    const added: string[] = [];\n    const unchanged: string[] = [];\n    const existingKeys = Object.keys(existing).filter((key) => key !== HAS_PART && key !== 'id' && key !== 'type');\n    const previouslyChangedValues: any = {};\n    const incomingChangedValues: any = {};\n    for (const [key, val] of Object.entries(incoming)) {\n      if (key === HAS_PART || key === 'id' || key === 'type') {\n        continue;\n      }\n      const currentVal = merged[key];\n      if (currentVal === val) {\n        unchanged.push(key);\n      } else if (currentVal === EMPTY || !currentVal) {\n        added.push(key);\n        merged[key] = val;\n      } else {\n        if (currentVal && val) {\n          previouslyChangedValues[key] = currentVal;\n          incomingChangedValues[key] = val;\n        }\n        merged[key] = merge(currentVal, val);\n        if (merged[key] === previouslyChangedValues[key]) {\n          unchanged.push(key);\n          delete previouslyChangedValues[key];\n        }\n      }\n    }\n\n    if (context && ((context.parent && context.parent.id) || context.isTopLevel)) {\n      const newHasPart: any[] = [];\n      const part: any = {};\n      if (context.parent) {\n        part[PART_OF] = context.parent.id;\n      } else if (context.isTopLevel) {\n        part[PART_OF] = existing.id;\n      }\n\n      if (merged[HAS_PART] && merged[HAS_PART].length) {\n        const noExplicit = !(merged[HAS_PART] || []).find((r: any) => r['@explicit']);\n        const hasDiverged = added.length > 0 || unchanged.length !== existingKeys.length;\n        // We already have one, it may conflict here.\n        // 1. Fix the first part.\n        if (noExplicit && hasDiverged) {\n          for (const item of merged[HAS_PART]) {\n            const first = { ...item };\n            const changedKeys = Object.keys(previouslyChangedValues);\n            if (first) {\n              first['@explicit'] = true;\n              for (const addedProperty of existingKeys) {\n                if (addedProperty !== HAS_PART) {\n                  first[addedProperty] = WILDCARD;\n                }\n              }\n              for (const changedKey of changedKeys) {\n                first[changedKey] = previouslyChangedValues[changedKey];\n              }\n            }\n            newHasPart.push(first);\n          }\n        } else {\n          newHasPart.push(...merged[HAS_PART]);\n        }\n\n        if (hasDiverged) {\n          // Add the framing.\n          const changedKeys = Object.keys(incomingChangedValues);\n          part['@explicit'] = true;\n          for (const addedProperty of added) {\n            part[addedProperty] = WILDCARD;\n          }\n          for (const unchangedValue of unchanged) {\n            part[unchangedValue] = WILDCARD;\n          }\n          for (const changedKey of changedKeys) {\n            part[changedKey] = incomingChangedValues[changedKey];\n          }\n        }\n      }\n\n      part.id = merged.id;\n      part.type = merged.type;\n      newHasPart.push(part);\n\n      merged[HAS_PART] = newHasPart;\n    }\n\n    return merged;\n  } else if (existing) {\n    return existing;\n  }\n  return incoming;\n}\n\nexport function mergeEntities(\n  existing: NormalizedEntity,\n  incoming: any,\n  context?: { parent?: any; isTopLevel?: boolean }\n): NormalizedEntity {\n  if (typeof existing === 'string') {\n    return existing;\n  }\n\n  if (incoming.id !== (existing as any).id || incoming.type !== (existing as any).type) {\n    if (incoming.type === 'ImageService3') {\n      return incoming;\n    }\n    if ((existing as any).type === 'ImageService3') {\n      return existing;\n    }\n\n    throw new Error(\n      `Can only merge entities with identical identifiers and type! ${incoming.type}(${incoming.id}) => ${\n        (existing as any).type\n      }(${(existing as any).id})`\n    );\n  }\n  return merge({ ...existing }, incoming, context);\n}\n\nfunction recordTypeInMapping(mapping: Record<string, string>) {\n  return <T extends Reference | string>(type: string, defaultStringType?: string) => {\n    return (r: T): T => {\n      const { id, type: foundType } = getResource(r, defaultStringType || type);\n      if (typeof id === 'undefined') {\n        throw new Error('Found invalid entity without an ID.');\n      }\n      if (type === 'ContentResource' || type === 'Service') {\n        mapping[id] = type;\n      } else {\n        mapping[id] = foundType as any;\n      }\n      return r;\n    };\n  };\n}\n\nfunction normalizeService(_service: any): any {\n  const service = Object.assign({}, _service);\n  if (service['@id']) {\n    service.id = service['@id'];\n  }\n\n  if (service['@type']) {\n    service.type = service['@type'];\n  }\n\n  if (service.service) {\n    const serviceReferences = [];\n    service.service = Array.isArray(service.service) ? service.service : [service.service];\n    for (const innerService of service.service) {\n      serviceReferences.push({\n        id: innerService['@id'] || innerService.id,\n        type: innerService['@type'] || innerService.type,\n      });\n    }\n    service.service = serviceReferences;\n  }\n\n  return Object.assign({}, emptyService, service);\n}\n\nfunction recordServiceForLoading(store: CompatibleStore['entities']) {\n  return (resource: Service) => {\n    store.Service = store.Service ? store.Service : {};\n    const id: string = (resource as any).id || (resource as any)['@id'];\n    const normalizedResource = normalizeService(resource);\n\n    // @todo add loading status for image services.\n\n    if (normalizedResource && normalizedResource.id) {\n      if (store.Service[normalizedResource.id]) {\n        // We need to merge.\n        store.Service[id] = mergeEntities(store.Service[id]!, normalizedResource);\n      } else {\n        store.Service[id] = normalizedResource as any;\n      }\n    }\n\n    // Keep original on resource - this is a parallel copy for READING\n    return resource;\n  };\n}\n\n/**\n * A string hashing function based on Daniel J. Bernstein's popular 'times 33' hash algorithm.\n * @author MatthewBarker <mrjbarker@hotmail.com>\n */\nfunction hash(object: any): string {\n  const text = JSON.stringify(object);\n\n  let numHash = 5381,\n    index = text.length;\n\n  while (index) {\n    numHash = (numHash * 33) ^ text.charCodeAt(--index);\n  }\n\n  const num = numHash >>> 0;\n\n  const hexString = num.toString(16);\n  if (hexString.length % 2) {\n    return '0' + hexString;\n  }\n  return hexString;\n}\n\nfunction addMissingIdToContentResource<T extends Partial<Reference>>(type: string) {\n  return (resource: T | string): T => {\n    if (typeof resource === 'string') {\n      return { id: resource, type } as T;\n    }\n    if (!resource.id) {\n      return { id: `vault://${hash(resource)}`, type, ...resource };\n    }\n    if (!resource.type) {\n      return { type, ...resource };\n    }\n    return resource;\n  };\n}\n\nfunction ensureDefaultFields<T, R>(defaultResource: R) {\n  return (resource: T): R => {\n    return {\n      ...defaultResource,\n      ...resource,\n    };\n  };\n}\n\nfunction ensureArray<T>(maybeArray: T | T[]): T[] {\n  if (Array.isArray(maybeArray)) {\n    return maybeArray;\n  }\n  return [maybeArray];\n}\n\nfunction ensureArrayOnAnnotation(annotation: Annotation): Annotation {\n  if (annotation.body) {\n    annotation.body = ensureArray(annotation.body);\n  }\n  if (annotation.seeAlso) {\n    annotation.seeAlso = ensureArray(annotation.seeAlso);\n  }\n  if (annotation.audience) {\n    annotation.audience = ensureArray(annotation.audience);\n  }\n  if (annotation.accessibility) {\n    annotation.accessibility = ensureArray(annotation.accessibility);\n  }\n  if (annotation.motivation) {\n    annotation.motivation = ensureArray(annotation.motivation);\n  }\n\n  return annotation;\n}\n\nfunction toSpecificResource(\n  target: string | Reference<any> | SpecificResource | Partial<Canvas>,\n  { typeHint, partOfTypeHint }: { typeHint?: string; partOfTypeHint?: string } = {}\n): SpecificResource {\n  if (typeof target === 'string') {\n    target = { id: target, type: typeHint || 'unknown' };\n  }\n\n  if (isSpecificResource(target)) {\n    if (typeof target.source === 'string') {\n      target.source = { id: target.source, type: typeHint || 'unknown' };\n    }\n\n    if (target.source.type === 'Canvas' && target.source.partOf && typeof target.source.partOf === 'string') {\n      target.source.partOf = [\n        {\n          id: target.source.partOf,\n          type: partOfTypeHint || 'Manifest', // Most common is manifest.\n        },\n      ];\n    }\n\n    return target;\n  }\n\n  let selector: Selector | undefined;\n  if ((target.id || '').indexOf('#') !== -1) {\n    const [id, fragment] = (target.id || '').split('#');\n    target.id = id;\n    if (fragment) {\n      selector = {\n        type: 'FragmentSelector',\n        value: fragment,\n      };\n    }\n  }\n\n  return {\n    type: 'SpecificResource',\n    source: target,\n    selector,\n  };\n}\n\nfunction rangeItemToSpecificResource(range: Range): Range {\n  const _range = Object.assign({}, range);\n  if (range && range.items) {\n    _range.items = range.items.map((rangeItem) => {\n      if (typeof rangeItem === 'string' || rangeItem.type === 'Canvas') {\n        return toSpecificResource(rangeItem);\n      }\n      return rangeItem;\n    });\n  }\n  return _range;\n}\n\nfunction startCanvasToSpecificResource(manifest: Manifest): Manifest {\n  const _manifest = Object.assign({}, manifest);\n  if (_manifest.start) {\n    _manifest.start = toSpecificResource(_manifest.start, {\n      typeHint: 'Canvas',\n    }) as any;\n    return _manifest;\n  }\n  return manifest;\n}\n\nfunction annotationTargetToSpecificResource(annotation: Annotation): Annotation {\n  const _annotation = Object.assign({}, annotation);\n  if (_annotation.target) {\n    _annotation.target = expandTargetToSpecificResource(_annotation.target as any, { typeHint: 'Canvas' }) as any;\n    return _annotation;\n  }\n  return annotation;\n}\n\nexport function traverseSpecificResource(specificResource: SpecificResource): SpecificResource {\n  return specificResource;\n}\n\nexport function addFlagForExternalResource<T extends AnnotationPage | Manifest | Collection>(resource: T): T {\n  if (typeof resource.items === 'undefined') {\n    (resource as any)[IS_EXTERNAL] = true;\n  }\n  return resource;\n}\n\nexport function normalize(unknownEntity: unknown) {\n  const entity = convertPresentation2(unknownEntity);\n  const entities = getDefaultEntities();\n  const mapping = {};\n  const addToEntities = mapToEntities(entities, entity);\n  const addToMapping = recordTypeInMapping(mapping);\n\n  const traversal = new Traverse({\n    collection: [\n      addFlagForExternalResource,\n      ensureDefaultFields<Collection, CollectionNormalized>(emptyCollection),\n      addToMapping<Collection>('Collection'),\n      addToEntities<Collection>('Collection'),\n    ],\n    manifest: [\n      addFlagForExternalResource,\n      ensureDefaultFields<Manifest, ManifestNormalized>(emptyManifest),\n      startCanvasToSpecificResource,\n      addToMapping<Manifest>('Manifest'),\n      addToEntities<Manifest>('Manifest'),\n    ],\n    canvas: [\n      ensureDefaultFields<Canvas, CanvasNormalized>(emptyCanvas),\n      addToMapping<Canvas>('Canvas'),\n      addToEntities<Canvas>('Canvas'),\n    ],\n    annotationPage: [\n      addFlagForExternalResource,\n      addMissingIdToContentResource('AnnotationPage'),\n      ensureDefaultFields<AnnotationPage, AnnotationPageNormalized>(emptyAnnotationPage),\n      addToMapping<AnnotationPage>('AnnotationPage'),\n      addToEntities<AnnotationPage>('AnnotationPage'),\n    ],\n    annotation: [\n      // This won't be normalized before going into the state.\n      // It will be normalized through selectors and pattern matching.\n      addMissingIdToContentResource('Annotation'),\n      ensureArrayOnAnnotation,\n      annotationTargetToSpecificResource,\n      addToMapping<Annotation>('Annotation'),\n      addToEntities<Annotation>('Annotation'),\n    ],\n    contentResource: [\n      // This won't be normalized before going into the state.\n      // It will be normalized through selectors and pattern matching.\n      addMissingIdToContentResource<any>('ContentResource'),\n      addToMapping<any>('ContentResource'),\n      addToEntities<any>('ContentResource'),\n    ],\n    range: [\n      // This will add a LOT to the state, maybe this will be configurable down the line.\n      ensureDefaultFields<Range, RangeNormalized>(emptyRange),\n      rangeItemToSpecificResource,\n      addToMapping<Range>('Range', 'Canvas'),\n      addToEntities<Range>('Range', 'Canvas'),\n    ],\n    agent: [\n      ensureDefaultFields<ResourceProvider, ResourceProviderNormalized>(emptyAgent),\n      addToMapping<ResourceProvider>('Agent'),\n      addToEntities<ResourceProvider>('Agent'),\n    ],\n    specificResource: [\n      // Special-case changes to this type of resource.\n      traverseSpecificResource,\n    ],\n    service: [\n      // Only record, don't replace.\n      recordServiceForLoading(entities),\n    ],\n  });\n  const resource = traversal.traverseUnknown(entity) as Reference;\n\n  return { entities, resource, mapping };\n}\n", "import { AnnotationCollection, ContentResource, Reference, Selector } from '@iiif/presentation-3';\nimport {\n  AnnotationCollectionNormalized,\n  AnnotationNormalized,\n  AnnotationPageNormalized,\n  CanvasNormalized,\n  CollectionNormalized,\n  ManifestNormalized,\n  RangeNormalized,\n  ResourceProviderNormalized,\n  ServiceNormalized,\n} from '@iiif/presentation-3-normalized';\nimport { resolveIfExists, UNSET, UNWRAP } from './utilities';\n\nexport type Field = any[];\n\nexport type CompatibleStore<T extends string = string> = {\n  requests: {\n    [url: string]: { resourceUri?: string } & any;\n  };\n  entities: {\n    [type in T]: {\n      [id: string]: NormalizedEntity;\n    };\n  };\n  mapping: {\n    [id: string]: T;\n  };\n};\n\nexport type _ServiceNormalized = ServiceNormalized & { id: string; type: string };\n\nexport type NormalizedEntity =\n  | CollectionNormalized\n  | ManifestNormalized\n  | CanvasNormalized\n  | AnnotationPageNormalized\n  | AnnotationCollectionNormalized\n  | AnnotationCollection\n  | AnnotationNormalized\n  | ContentResource\n  | RangeNormalized\n  | _ServiceNormalized\n  | Selector\n  | ResourceProviderNormalized\n  | { id?: string; '@id'?: string; type?: string; '@type'?: string; [key: string]: any };\n\ntype SerializerContext = {\n  isTopLevel?: boolean;\n  parent?: any;\n  fullResource?: any;\n};\n\nexport type Serializer<Type extends NormalizedEntity> = (\n  entity: Type,\n  state: any,\n  context: SerializerContext\n) => Generator<Reference | Reference[], typeof UNSET | Field[], any>;\n\nexport type SerializeConfig = {\n  Collection?: Serializer<CollectionNormalized>;\n  Manifest?: Serializer<ManifestNormalized>;\n  Canvas?: Serializer<CanvasNormalized>;\n  AnnotationPage?: Serializer<AnnotationPageNormalized>;\n  AnnotationCollection?: Serializer<AnnotationCollectionNormalized>;\n  Annotation?: Serializer<AnnotationNormalized>;\n  ContentResource?: Serializer<ContentResource>;\n  Range?: Serializer<RangeNormalized>;\n  Service?: Serializer<_ServiceNormalized>;\n  Selector?: Serializer<Selector>;\n  Agent?: Serializer<ResourceProviderNormalized>;\n};\n\nexport function serializedFieldsToObject<T>(fields: Field[] | [string]): T {\n  const object: any = {};\n\n  for (const [key, value] of fields) {\n    if (key === UNWRAP && value !== UNSET) {\n      return value as T;\n    }\n    if (value !== UNSET && typeof value !== 'undefined' && value !== null) {\n      object[key] = value;\n    }\n  }\n\n  return object as T;\n}\n\nexport function serialize<Return>(state: CompatibleStore, subject: Reference, config: SerializeConfig): Return {\n  if (!subject.type || !subject.id) {\n    throw new Error('Unknown entity');\n  }\n\n  if (!config[subject.type as keyof SerializeConfig]) {\n    throw new Error(`Serializer not found for ${subject.type}`);\n  }\n\n  function flatten(sub: Reference, parent?: any, depth = 0) {\n    const generator = config[sub.type as keyof SerializeConfig];\n    if (!generator) {\n      return UNSET;\n    }\n    if (depth > 20) {\n      throw new Error('Circular reference: ' + sub.id + ' ' + sub.type);\n    }\n    const [resource, fullResource] =\n      resolveIfExists(state, sub.type ? sub : sub.id, parent) || (sub.id && sub.type ? sub : null);\n    if (!resource) {\n      return UNSET;\n    }\n    const iterator = generator(resource as any, state, {\n      parent,\n      isTopLevel: subject.id === sub.id,\n      fullResource,\n    });\n    let current = iterator.next();\n    while (!current.done) {\n      const requestToHydrate: Reference | Reference[] = current.value as any;\n      let next: any = UNSET;\n\n      if (requestToHydrate) {\n        if (Array.isArray(requestToHydrate)) {\n          const nextList: any[] = [];\n          for (const req of requestToHydrate) {\n            nextList.push(flatten(req, sub, depth + 1));\n          }\n          next = nextList;\n        } else {\n          next = flatten(requestToHydrate, sub, depth + 1);\n        }\n      }\n      current = iterator.next(next);\n    }\n\n    if (current.value === UNSET) {\n      return UNSET;\n    }\n\n    return serializedFieldsToObject(current.value);\n  }\n\n  return flatten(subject) as Return;\n}\n", "import { SpecificResource } from '@iiif/presentation-3';\n\nexport function compressSpecificResource(\n  target: undefined | SpecificResource,\n  { allowSourceString = true, allowString = false, allowedStringType }: { allowString?: boolean; allowSourceString?: boolean; allowedStringType?: string } = {}\n): any {\n  const fixSource = (resource: any) => {\n    if (allowSourceString && resource && resource.source && typeof resource.source !== 'string') {\n      const keys = Object.keys(resource.source);\n      if (resource.source.id && resource.source.type && keys.length === 2) {\n        return { ...resource, source: resource.source.id };\n      }\n    }\n    return resource;\n  };\n\n  if (target) {\n    if (target.source && target.source.partOf) {\n      // Ignore if we have a partOf\n      return fixSource(target);\n    }\n    const keys = Object.keys(target);\n    if (\n      (keys.length === 2 && target.type && target.source) ||\n      (keys.length === 3 && target.type && target.source && keys.indexOf('selector') !== -1 && !target.selector)\n    ) {\n      if (allowString && (!allowedStringType || allowedStringType === target.source.type)) {\n        return target.source.id;\n      }\n\n      if (target.source.type === 'ContentResource') {\n        return { type: 'SpecificResource', source: target.source.id };\n      }\n\n      // If all we have is the wrapped source, just return the ID.\n      return target.source;\n    }\n    if (target.selector) {\n      if (\n        !Array.isArray(target.selector) &&\n        typeof target.selector !== 'string' &&\n        target.selector.type === 'FragmentSelector'\n      ) {\n        const newId = `${target.source.id}#${target.selector.value}`;\n        return allowString ? newId : { id: newId, type: target.source.type };\n      }\n    }\n  }\n  return fixSource(target);\n}\n", "import { SerializeConfig } from './serialize';\nimport {\n  FragmentSelector,\n  InternationalString,\n  Reference,\n  Selector,\n  SpecificResource,\n  TechnicalProperties,\n} from '@iiif/presentation-3';\nimport { DescriptiveNormalized, LinkingNormalized } from '@iiif/presentation-3-normalized';\nimport * as Presentation2 from '@iiif/presentation-2';\nimport { compressSpecificResource } from '../shared/compress-specific-resource';\n\nexport function languageString2to3(\n  value: InternationalString | null | undefined\n): Presentation2.LanguageProperty | Presentation2.LanguageProperty[] | undefined {\n  if (!value) {\n    return undefined;\n  }\n\n  const languages = Object.keys(value);\n\n  if (languages.length === 0) {\n    return undefined;\n  }\n\n  // If there is only one, then return it as a string.\n  if (languages.length === 1) {\n    const language = languages[0];\n    if (!language) {\n      return '';\n    }\n\n    const singleValue = (value[language] || []).join('');\n\n    if (language === '@none' || language === 'none' || language === 'en') {\n      return singleValue;\n    }\n\n    return {\n      '@language': language,\n      '@value': singleValue,\n    };\n  }\n\n  return languages.map((language) => {\n    return {\n      '@language': language,\n      '@value': (value[language] || []).join(''),\n    };\n  });\n}\n\nfunction parseCanvasTarget(target: any): any {\n  if (Array.isArray(target)) {\n    return target.map((t) => parseCanvasTarget(t));\n  }\n\n  if (typeof target === 'string') {\n    return target;\n  }\n\n  if (target.type && target.type === 'Canvas') {\n    return target.id;\n  }\n\n  return target;\n}\n\nfunction unNestArray<T>(oneOrArray: T[] | undefined, onlyOne = false): T | T[] | undefined {\n  if (!oneOrArray) {\n    return undefined;\n  }\n\n  if (oneOrArray.length > 1 && !onlyOne) {\n    return oneOrArray;\n  }\n  return oneOrArray[0] || undefined;\n}\n\nfunction convertService(service: any) {\n  if (!service) {\n    return undefined;\n  }\n\n  if (typeof service === 'string') {\n    return {\n      '@id': service,\n    };\n  }\n\n  if ('@id' in service) {\n    const newService = { ...service };\n    delete newService['@type'];\n    return newService;\n  }\n\n  // @todo support auth.\n  return {\n    '@context': 'http://iiif.io/api/image/2/context.json',\n    '@id': service.id,\n    profile: `http://iiif.io/api/image/2/profiles/${service.profile}.json`,\n  };\n}\n\nfunction technicalProperties(props: Partial<TechnicalProperties>, type?: string) {\n  return [\n    ['@id', props.id],\n    ['@type', type],\n    ['format', props.format],\n    ['height', props.height],\n    ['width', props.width],\n    ['viewingDirection', props.viewingDirection !== 'left-to-right' ? props.viewingDirection : undefined],\n\n    // Non-standard property.\n    ['license', (props as any).license ? (props as any).license : undefined],\n    // @todo Viewing hint is merged with behavior\n    // ['viewingHint', props.]\n  ];\n}\n\nfunction* descriptiveProperties(prop: Partial<DescriptiveNormalized>): Generator<any, any, any> {\n  const provider = prop.provider ? yield prop.provider[0] : undefined;\n\n  return [\n    ['label', languageString2to3(prop.label)],\n    [\n      'metadata',\n      prop.metadata && prop.metadata.length\n        ? prop.metadata.map((item) => ({\n            label: languageString2to3(item.label) || '',\n            value: languageString2to3(item.value) || '',\n          }))\n        : undefined,\n    ],\n    ['description', languageString2to3(prop.summary)],\n    ['thumbnail', unNestArray(yield prop.thumbnail)],\n    ['navDate', prop.navDate],\n    // @todo these needs consideration if the way provider is parsed changes.\n    ['logo', provider ? unNestArray(provider.logo) : undefined],\n    ['homepage', provider ? provider.homepage : undefined],\n    ['attribution', prop.requiredStatement ? languageString2to3(prop.requiredStatement.value) : undefined],\n  ];\n}\n\nfunction* linkingProperties(prop: Partial<LinkingNormalized>) {\n  const startProp =\n    prop.start && prop.start.type && (prop.start as any).type === 'SpecificResource'\n      ? compressSpecificResource(prop.start as any)\n      : prop.start;\n\n  return [\n    ['seeAlso', unNestArray(yield prop.seeAlso)],\n    // @todo support more services (like auth)\n    ['service', unNestArray((prop.service || []).map(convertService))],\n    ['rendering', unNestArray(yield prop.rendering)],\n    // @todo part of to within\n    // ['within', unNestArray(yield prop.partOf)],\n    // @todo this may not work completely.\n    ['startCanvas', startProp ? startProp.id : undefined],\n  ];\n}\n\nfunction isSpecificResource(resource: unknown): resource is SpecificResource {\n  return (resource as any).type === 'SpecificResource';\n}\nfunction isFragmentSelector(resource: unknown): resource is FragmentSelector {\n  return (resource as any) && (resource as any).type === 'FragmentSelector';\n}\n\nfunction specificResourceToString(resource: Reference<any> | SpecificResource) {\n  if (resource && isSpecificResource(resource)) {\n    let id = resource.id;\n    const selector: Selector | undefined = resource.selector\n      ? Array.isArray(resource.selector)\n        ? resource.selector[0]\n        : resource.selector\n      : undefined;\n\n    if (isFragmentSelector(selector)) {\n      id += '#' + selector.value;\n    }\n    return id;\n  }\n  return resource?.id;\n}\n\nexport const serializeConfigPresentation2: SerializeConfig = {\n  Manifest: function* (entity, state, { isTopLevel }) {\n    return [\n      ...(isTopLevel ? [['@context', 'http://iiif.io/api/presentation/2/context.json']] : []),\n      ...technicalProperties(entity, 'sc:Manifest'),\n      ...(yield* descriptiveProperties(entity)),\n      ...(yield* linkingProperties(entity)),\n      // Structural.\n      // @todo structures\n      [\n        'sequences',\n        [\n          {\n            '@id': `${entity.id}/sequence0`,\n            '@type': 'sc:Sequence',\n            canvases: yield entity.items,\n          },\n        ],\n      ],\n      ['structures', yield entity.structures],\n    ];\n  },\n\n  Canvas: function* (entity) {\n    const paintingPage = yield entity.items;\n    const resources = paintingPage[0];\n    return [\n      // Items.\n      ...technicalProperties(entity, 'sc:Canvas'),\n      ...(yield* descriptiveProperties(entity)),\n      ...(yield* linkingProperties(entity)),\n      ['images', resources ? [resources.resources] : undefined],\n      [\n        // @todo use otherContent if they are inlined\n        'annotations',\n        entity.annotations && entity.annotations.length ? unNestArray(yield entity.annotations) : undefined,\n      ],\n    ];\n  },\n\n  AnnotationPage: function* (entity) {\n    return [\n      ...technicalProperties(entity, 'sc:AnnotationList'),\n      ...(yield* descriptiveProperties(entity)),\n      ['resources', entity.items && entity.items.length ? unNestArray(yield entity.items) : undefined],\n    ];\n  },\n\n  Annotation: function* (entity) {\n    return [\n      ['@id', entity.id],\n      ['@type', 'oa:Annotation'],\n      // This could be improved.\n      ['motivation', 'sc:painting'],\n      ['on', parseCanvasTarget(entity.target)],\n      ['resource', unNestArray(yield entity.body, true)],\n    ];\n  },\n\n  ContentResource: function* (entity: any) {\n    switch (entity.type) {\n      case 'Image':\n        return [\n          // Image properties.\n          ...technicalProperties(entity, 'dctypes:Image'),\n          ...(yield* descriptiveProperties(entity)),\n          ...(yield* linkingProperties(entity)),\n        ];\n      case 'Text':\n      case 'Dataset':\n      default:\n        return [...technicalProperties(entity, undefined), ...(yield* descriptiveProperties(entity))];\n    }\n  },\n\n  AnnotationCollection: function* (entity) {\n    return [\n      // @todo expand properties if they are actually used.\n      ['@id', entity.id],\n      ['@type', 'sc:Layer'],\n      ['label', languageString2to3(entity.label)],\n    ];\n  },\n\n  Collection: function* (entity) {\n    return [\n      ...technicalProperties(entity, 'sc:Collection'),\n      ...(yield* descriptiveProperties(entity)),\n      ...(yield* linkingProperties(entity)),\n      ['members', yield* entity.items],\n    ];\n  },\n\n  Range: function* (entity) {\n    const members = [];\n    const canvases = [];\n\n    if (entity.items) {\n      for (const _item of entity.items) {\n        const item = _item.type === 'SpecificResource' ? _item.source : _item;\n        if (item) {\n          const canvas = yield item;\n          members.push({\n            '@id': specificResourceToString(_item),\n            '@type': item.type,\n            label: canvas ? canvas.label : undefined,\n            within: entity.id,\n          });\n          if (item.type === 'Canvas') {\n            canvases.push(item.id);\n          }\n        }\n      }\n    }\n\n    return [\n      ...technicalProperties(entity, 'sc:Range'),\n      ...(yield* descriptiveProperties(entity)),\n      ...(yield* linkingProperties(entity)),\n      ['canvases', canvases.length === members.length ? canvases : undefined],\n      ['members', canvases.length !== members.length ? members : undefined],\n    ];\n  },\n};\n", "import { SerializeConfig } from './serialize';\nimport {\n  ImageService,\n  ImageService2,\n  ImageService3,\n  ResourceProvider,\n  TechnicalProperties,\n} from '@iiif/presentation-3';\nimport { compressSpecificResource } from '../shared/compress-specific-resource';\nimport { DescriptiveNormalized, LinkingNormalized } from '@iiif/presentation-3-normalized';\nimport { HAS_PART, IS_EXTERNAL, PART_OF, UNSET, UNWRAP } from './utilities';\nimport { isSpecificResource } from '../shared/is-specific-resource';\n\nfunction technicalProperties(entity: Partial<TechnicalProperties>): Array<[keyof TechnicalProperties, any]> {\n  return [\n    // Technical\n    ['id', !entity.id?.startsWith('vault://') ? entity.id : undefined],\n    ['type', entity.type],\n    ['format', entity.format],\n    ['profile', entity.profile],\n    ['height', entity.height || undefined],\n    ['width', entity.width || undefined],\n    ['duration', entity.duration || undefined],\n    ['viewingDirection', entity.viewingDirection !== 'left-to-right' ? entity.viewingDirection : undefined],\n    ['behavior', entity.behavior && entity.behavior.length ? entity.behavior : undefined],\n    ['timeMode', entity.timeMode],\n    ['motivation', Array.isArray(entity.motivation) ? entity.motivation[0] : entity.motivation],\n    [HAS_PART as any, UNSET],\n  ];\n}\n\nfunction filterEmpty<T>(item?: T[] | typeof UNSET): T[] | undefined | typeof UNSET {\n  if (item === UNSET) {\n    return undefined;\n  }\n\n  if (!item || item.length === 0) {\n    return undefined;\n  }\n  const filtered = item.filter((item) => (item as any) !== UNSET);\n\n  if (filtered.length === 0) {\n    return undefined;\n  }\n\n  return filtered;\n}\n\nfunction service2compat(service: ImageService3 | ImageService): ImageService2 | ImageService3 {\n  if (service && service.type && service.type === 'ImageService2') {\n    const { id, type, profile: _profile, ..._service } = service as any;\n\n    const profile =\n      typeof _profile === 'string'\n        ? _profile\n        : Array.isArray(_profile)\n          ? _profile.find((p) => typeof p === 'string')\n          : '';\n\n    return {\n      '@id': id,\n      '@type': type,\n      profile: profile\n        ? profile.startsWith('http')\n          ? profile\n          : `http://iiif.io/api/image/2/${profile}.json`\n        : 'http://iiif.io/api/image/2/level0.json',\n      ..._service,\n    } as any;\n  }\n\n  return service as ImageService3;\n}\n\nfunction filterService2Compat(services?: any[]) {\n  if (!Array.isArray(services)) {\n    services = services ? [services] : [];\n  }\n\n  if (!services || services.length === 0) {\n    return undefined;\n  }\n\n  return (services as any[]).map(service2compat);\n}\n\nfunction* descriptiveProperties(\n  entity: Partial<DescriptiveNormalized>\n): Generator<any, any, Array<[keyof DescriptiveNormalized, any]>> {\n  return [\n    ['label', entity.label],\n    ['metadata', filterEmpty(entity.metadata)],\n    ['summary', entity.summary],\n    ['requiredStatement', entity.requiredStatement],\n    ['rights', Array.isArray(entity.rights) ? entity.rights[0] || undefined : entity.rights || undefined],\n    ['navDate', entity.navDate],\n    ['language', entity.language],\n    // We yield these fully as they are embedded in here.\n    ['thumbnail', filterEmpty(yield entity.thumbnail)],\n    ['placeholderCanvas', yield entity.placeholderCanvas],\n    ['accompanyingCanvas', yield entity.accompanyingCanvas],\n\n    // @todo need to test this one.\n    ['provider', filterEmpty(yield entity.provider)],\n  ];\n}\n\nfunction* linkingProperties(\n  entity: Partial<LinkingNormalized>,\n  parent?: any\n): Generator<any, any, Array<[keyof LinkingNormalized, any]>> {\n  let filteredPartOf = [];\n  for (let partOf of entity.partOf || []) {\n    if (partOf.type === 'Manifest' && parent.type === 'Manifest') continue;\n    filteredPartOf.push(yield partOf);\n  }\n\n  return [\n    ['seeAlso', filterEmpty(yield entity.seeAlso)],\n    ['service', filterEmpty(filterService2Compat(entity.service))],\n    ['services', filterEmpty(filterService2Compat(entity.services))],\n    ['rendering', filterEmpty(yield entity.rendering)],\n    ['supplementary', filterEmpty(yield entity.supplementary)],\n    ['homepage', filterEmpty(yield entity.homepage)],\n    ['logo', filterEmpty(yield (entity as ResourceProvider).logo)],\n\n    // Don't yield these, they are references.\n    ['partOf', filterEmpty(filteredPartOf)],\n    [\n      'start',\n      // @todo remove once types updated.\n      entity.start ? compressSpecificResource(entity.start) : entity.start,\n    ],\n  ];\n}\n\nexport const serializeConfigPresentation3: SerializeConfig = {\n  Manifest: function* (entity, state, { isTopLevel }) {\n    if (!isTopLevel) {\n      return [\n        // Only a snippet.\n        ...technicalProperties(entity),\n        ...(yield* descriptiveProperties(entity)),\n        ['navPlace', (entity as any).navPlace],\n      ];\n    }\n\n    let context: any = 'http://iiif.io/api/presentation/3/context.json';\n\n    if (entity.navPlace || itemsHaveNavPlace(entity)) {\n      context = [\n        'http://iiif.io/api/presentation/3/context.json',\n        'http://iiif.io/api/extension/navplace/context.json',\n      ];\n    }\n\n    return [\n      [\n        '@context',\n        (entity as any)['@context'] ? (entity as any)['@context'] : context,\n      ],\n      ...technicalProperties(entity),\n      ...(yield* descriptiveProperties(entity)),\n      ...(yield* linkingProperties(entity)),\n      ['items', yield entity.items],\n      ['structures', filterEmpty(yield entity.structures)],\n      ['annotations', filterEmpty(yield entity.annotations)],\n      ['navPlace', (entity as any).navPlace], // @todo remove when types are updated\n    ];\n  },\n\n  Canvas: function* (entity, state, { parent }) {\n    if (parent && parent.type !== 'Manifest' && parent.type !== 'Canvas') {\n      return [['id', entity.id]];\n    }\n\n    return [\n      // Items.\n      ...technicalProperties(entity),\n      ...(yield* descriptiveProperties(entity)),\n      ...(yield* linkingProperties(entity, parent)),\n      ['items', yield entity.items],\n      ['annotations', filterEmpty(yield entity.annotations)],\n      ['navPlace', (entity as any).navPlace], // @todo remove when types are updated\n    ];\n  },\n\n  Agent: function* (entity) {\n    return [\n      //\n      ['id', entity.id],\n      ['type', 'Agent'],\n      ['label', entity.label],\n      ...(yield* linkingProperties(entity as any)),\n    ];\n  },\n\n  AnnotationPage: function* (entity) {\n    const entries = Object.entries(entity)\n      .map(([key, item]) => {\n        return [key, Array.isArray(item) ? filterEmpty(item as any) : item];\n      })\n      .filter(([key, value]) => {\n        return key !== 'items' && key !== 'id' && key !== HAS_PART && key !== PART_OF && key !== IS_EXTERNAL;\n      });\n\n    const items = yield entity.items;\n\n    return [\n      // Any more properties?\n      ['id', !entity.id?.startsWith('vault://') ? entity.id : undefined],\n      ...entries,\n      ...(yield* linkingProperties(entity)),\n      ['items', items.length || (entity as any)[IS_EXTERNAL] === false ? items : UNSET],\n    ];\n  },\n\n  Service: function* (entity) {\n    // Are there other properties on a service?\n    return [[UNWRAP, service2compat(entity as any)]];\n  },\n\n  Annotation: function* (entity) {\n    const entries = Object.entries(entity)\n      .map(([key, item]) => {\n        if (key === 'motivation') {\n          // Annotation non-array items can be added here.\n          return [key, Array.isArray(item) ? item[0] : item];\n        }\n\n        if (key === 'target') {\n          return [\n            key,\n            compressSpecificResource(item, { allowString: true, allowSourceString: true, allowedStringType: 'Canvas' }),\n          ];\n        }\n\n        return [key, Array.isArray(item) ? filterEmpty(item as any) : item];\n      })\n      .filter(([key]) => {\n        return key !== 'body' && key !== HAS_PART && key !== IS_EXTERNAL;\n      });\n\n    let resolvedBody: any = undefined;\n\n    if (Array.isArray(entity.body)) {\n      const resolved = [];\n      for (const body of entity.body as any[]) {\n        if (body && isSpecificResource(body)) {\n          const single = {\n            ...(body as any),\n          };\n\n          if (body.source.type !== 'Canvas') {\n            single.source = yield body.source;\n          } else {\n            single.source = body.source;\n          }\n\n          resolved.push(compressSpecificResource(single, { allowSourceString: true }));\n        } else {\n          resolved.push(yield body);\n        }\n      }\n      resolvedBody = resolved;\n    } else {\n      if (entity.body && isSpecificResource(entity.body)) {\n        resolvedBody = {\n          ...(entity.body as any),\n        };\n        resolvedBody.source = yield (entity.body as any).source;\n      } else {\n        resolvedBody = yield entity.body;\n      }\n    }\n\n    // const resolvedBody = yield entity.body;\n\n    return [\n      ...entries,\n      ...(yield* descriptiveProperties(entity as any)),\n      ...(yield* linkingProperties(entity)),\n      ['body', resolvedBody.length === 1 ? resolvedBody[0] : resolvedBody],\n    ];\n  },\n\n  ContentResource: function* (entity: any) {\n    return mergeRemainingProperties(\n      [\n        // Image properties.\n        ...technicalProperties(entity),\n        ...(yield* descriptiveProperties(entity)),\n        ...(yield* linkingProperties(entity)),\n        ['annotations', filterEmpty(yield entity.annotations)],\n        ['items', filterEmpty(yield entity.items)],\n      ],\n      entity\n    );\n  },\n\n  AnnotationCollection: function* (entity) {\n    return [\n      // @todo expand properties if they are actually used.\n      ['id', entity.id],\n      ['type', 'AnnotationCollection'],\n      ['label', entity.label],\n    ];\n  },\n\n  Collection: function* (entity, state, { isTopLevel }) {\n    if (isTopLevel) {\n      let context: any = 'http://iiif.io/api/presentation/3/context.json';\n\n      if (entity.navPlace || itemsHaveNavPlace(entity)) {\n        context = [\n          'http://iiif.io/api/extension/navplace/context.json',\n          'http://iiif.io/api/presentation/3/context.json',\n        ];\n      }\n\n      return [\n        ['@context', context],\n        ...technicalProperties(entity),\n        ...(yield* descriptiveProperties(entity)),\n        ...(yield* linkingProperties(entity)),\n        ['items', filterEmpty(yield entity.items)],\n        ['navPlace', (entity as any).navPlace], // @todo remove when types are updated\n      ];\n    }\n    return [\n      ...technicalProperties(entity),\n      ...(yield* descriptiveProperties(entity)),\n      ['navPlace', (entity as any).navPlace],\n    ];\n  },\n\n  Range: function* (entity) {\n    const rangeItems = [];\n\n    for (const item of entity.items) {\n      if (item.type === 'Range') {\n        // Resolve the full range\n        rangeItems.push(yield item);\n      } else {\n        // Just push the reference.\n        // @todo could also push in the label of the item?\n        if (item && item.type === 'SpecificResource') {\n          rangeItems.push(compressSpecificResource(item));\n        } else {\n          rangeItems.push(item);\n        }\n      }\n    }\n\n    return [\n      ...technicalProperties(entity),\n      ...(yield* descriptiveProperties(entity)),\n      ...(yield* linkingProperties(entity)),\n      ['items', rangeItems],\n      ['annotations', filterEmpty(yield entity.annotations)],\n      ['navPlace', (entity as any).navPlace], // @todo remove when types are updated\n    ];\n  },\n};\n\nfunction mergeRemainingProperties(entries: [string, any][], object: any): [string, any][] {\n  const keys = Object.keys(object);\n  const alreadyParsed = entries.map(([a]) => a);\n\n  for (const key of keys) {\n    if (key === HAS_PART || key === IS_EXTERNAL) {\n      continue;\n    }\n    if (alreadyParsed.indexOf(key) === -1 && typeof object[key] !== 'undefined') {\n      entries.push([key, object[key]]);\n    }\n  }\n  return entries;\n}\n\n\nfunction itemsHaveNavPlace(item: any) {\n  if (!item.items || !Array.isArray(item.items)) {\n    return false;\n  }\n\n  for (const singleItem of item.items) {\n    if (singleItem.navPlace) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "import { Traverse } from '@iiif/parser';\nimport { Canvas, Collection, InternationalString, Manifest } from '@iiif/presentation-3';\n\nexport function getClosestLanguage(\n  i18nLanguage: string | undefined,\n  languages: string[],\n  i18nLanguages: string[] = [],\n  strictFallback = false,\n  skipLanguages: string[] = []\n) {\n  if (skipLanguages.length) {\n    languages = languages.filter((l) => skipLanguages.indexOf(l) === -1);\n  }\n\n  if (!languages || languages.length === 0) {\n    return undefined;\n  }\n\n  // Only one option.\n  if (languages.length === 1) {\n    return languages[0];\n  }\n\n  if (!i18nLanguage) {\n    if (languages.indexOf('none') !== -1) {\n      return 'none';\n    }\n    return languages[0];\n  }\n\n  // Exact match.\n  if (languages.indexOf(i18nLanguage) !== -1) {\n    return i18nLanguage;\n  }\n\n  // Root match (en-us === en)\n  const root = i18nLanguage.indexOf('-') !== -1 ? i18nLanguage.slice(0, i18nLanguage.indexOf('-')) : null;\n  if (root && languages.indexOf(root) !== -1) {\n    return root;\n  }\n\n  // All of the fall backs.\n  for (const lang of i18nLanguages) {\n    if (languages.indexOf(lang) !== -1) {\n      return lang;\n    }\n  }\n\n  if (!strictFallback && i18nLanguage) {\n    // Inverse root match (en === en-us)\n    const inverseRoot = languages.map((l) => (l.indexOf('-') !== -1 ? l.slice(0, l.indexOf('-')) : null));\n    const inverseIdx = inverseRoot.indexOf(i18nLanguage);\n    if (inverseIdx !== -1) {\n      return languages[inverseIdx];\n    }\n\n    // Inverse root (fallback)\n    for (const lang of i18nLanguages) {\n      const root = lang.indexOf('-') !== -1 ? lang.slice(0, lang.indexOf('-')) : null;\n      const inverseIdx = root ? languages.indexOf(root) : -1;\n      if (inverseIdx !== -1) {\n        return languages[inverseIdx];\n      }\n    }\n  }\n\n  if (languages.indexOf('none') !== -1) {\n    return 'none';\n  }\n\n  // Catch some legacy\n  if (languages.indexOf('@none') !== -1) {\n    return '@none';\n  }\n\n  // Finally, fall back to the first.\n  return languages[0];\n}\n\nexport function buildLocaleString(\n  inputText: string | InternationalString | null | undefined,\n  i18nLanguage: string | undefined,\n  options: {\n    strictFallback?: boolean;\n    defaultText?: string;\n    separator?: string;\n    fallbackLanguages?: string[];\n    closest?: boolean;\n    skipLanguages?: string[];\n  } = {}\n) {\n  const {\n    strictFallback = false,\n    defaultText = '',\n    separator = '\\n',\n    fallbackLanguages = [],\n    closest,\n    skipLanguages,\n  } = options;\n  const languages = Object.keys(inputText || {});\n  const language = closest\n    ? i18nLanguage\n    : getClosestLanguage(i18nLanguage, languages, fallbackLanguages, strictFallback, skipLanguages);\n\n  if (!inputText) {\n    return defaultText;\n  }\n\n  if (typeof inputText === 'string') {\n    return inputText;\n  }\n\n  const candidateText = language ? inputText[language] : undefined;\n  if (candidateText && language) {\n    // Slightly tolerant of typos in IIIF like: `{\"en\": \"Some value\"}`\n    if (typeof candidateText === 'string') {\n      return candidateText;\n    }\n    // Skip empty strings.\n    if (candidateText.length === 1 && candidateText[0] === '') {\n      const skip: string[] = options.skipLanguages || [];\n      return buildLocaleString(inputText, i18nLanguage, {\n        ...options,\n        skipLanguages: [...skip, language],\n      });\n    }\n    return candidateText.join(separator);\n  }\n\n  return '';\n}\n\nexport function getValue(\n  inputText: string | InternationalString | null | undefined,\n  options: { language?: string; defaultText?: string; separator?: string; fallbackLanguages?: string[] } = {}\n) {\n  return buildLocaleString(\n    inputText,\n    options.language || (typeof navigator !== 'undefined' ? navigator.language : 'en'),\n    options\n  );\n}\n\nfunction getLanguagesFromLanguageMap(languageMap: InternationalString) {\n  if (!languageMap) return [];\n  if (typeof languageMap === 'string') return [];\n  if (Array.isArray(languageMap)) return [];\n  return Object.keys(languageMap).filter((l) => l !== 'none');\n}\n\nexport function getAvailableLanguagesFromResource(item: Collection | Manifest | Canvas | Range) {\n  const foundLanguages = new Set();\n\n  const findLanguages = Traverse.all((resource: any) => {\n    // List of properties that can contain language.\n    // - language\n    // - summary\n    // - required statement (label, value)\n    // - metadata pairs (array of label, value)\n\n    if ('label' in resource) {\n      const languages = getLanguagesFromLanguageMap(resource.label);\n      languages.forEach((l) => foundLanguages.add(l));\n    }\n\n    if ('summary' in resource) {\n      const languages = getLanguagesFromLanguageMap(resource.summary);\n      languages.forEach((l) => foundLanguages.add(l));\n    }\n\n    if ('language' in resource) {\n      if (typeof resource.language === 'string') {\n        foundLanguages.add(resource.language);\n      }\n    }\n\n    if ('requiredStatement' in resource) {\n      if (resource.requiredStatement && !Array.isArray(resource.requiredStatement)) {\n        if ('label' in resource.requiredStatement) {\n          const languages = getLanguagesFromLanguageMap(resource.requiredStatement.label);\n          languages.forEach((l) => foundLanguages.add(l));\n        }\n        if ('value' in resource.requiredStatement) {\n          const languages = getLanguagesFromLanguageMap(resource.requiredStatement.value);\n          languages.forEach((l) => foundLanguages.add(l));\n        }\n      }\n    }\n\n    if ('metadata' in resource) {\n      if (Array.isArray(resource.metadata)) {\n        (resource.metadata as any[]).forEach((m) => {\n          if ('label' in m) {\n            const languages = getLanguagesFromLanguageMap(m.label);\n            languages.forEach((l) => foundLanguages.add(l));\n          }\n          if ('value' in m) {\n            const languages = getLanguagesFromLanguageMap(m.value);\n            languages.forEach((l) => foundLanguages.add(l));\n          }\n        });\n      }\n    }\n  });\n\n  findLanguages.traverseUnknown(item);\n\n  return Array.from(foundLanguages);\n}\n\nexport const iiifString = createStringHelper();\n\nexport function createStringHelper(options: { language?: string; defaultText?: string; separator?: string; fallbackLanguages?: string[] } = {}) {\n  return (template: TemplateStringsArray, ...params: Array<null | string[] | undefined | string | InternationalString>) => {\n    let result = '';\n\n    for (let i = 0; i < template.length; i++) {\n      // Add the template part\n      result += template[i];\n\n      // If there's a parameter for this position\n      if (i < params.length) {\n        const param = params[i];\n\n        if (param === null || param === undefined) {\n          // Skip null or undefined params\n          continue;\n        } else if (typeof param === 'string') {\n          // Add string params directly\n          result += param;\n        } else {\n          // For InternationalString objects, get the value using the getValue function\n          // which will handle localization based on the user's language\n          result += getValue(param as any, options);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n", "var e=Object.create,t=Object.defineProperty,n=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,i=Object.getPrototypeOf,a=Object.prototype.hasOwnProperty,o=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),s=(e,n)=>{for(var r in n)t(e,r,{get:n[r],enumerable:!0})},c=(e,i,o,s)=>{if(i&&typeof i==`object`||typeof i==`function`)for(var c=r(i),l=0,u=c.length,d;l<u;l++)d=c[l],!a.call(e,d)&&d!==o&&t(e,d,{get:(e=>i[e]).bind(null,d),enumerable:!(s=n(i,d))||s.enumerable});return e},l=(n,r,a)=>(a=n==null?{}:e(i(n)),c(r||!n||!n.__esModule?t(a,`default`,{value:n,enumerable:!0}):a,n));export{o as __commonJSMin,s as __export,l as __toESM};", "/** Code to \"flatten\" quadratic and cubic Bzier curves to polylines.\n *\n * All code in this module is based on JavaScript code by Raph Levien, published on his blog at\n * https://raphlinus.github.io/.\n * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.\n *\n * Flattening of quadratic Bzier curves:\n * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html\n * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212\n *\n * Flattening of cubic Bzier curves: https://levien.com/tmp/flatten.html\n *\n * Note that the code in this module has a different license than the rest of the package,\n * due to the inclusion of Apache-licensed third party code.\n *\n * @license\n * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>\n * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type Point = { x: number; y: number };\n\nexport function flattenQuadraticBezier(start: Point, control: Point, end: Point, tolerance = 1): Point[] {\n  return new QuadraticBezier(start, control, end).subdivide(tolerance);\n}\n\nexport function flattenCubicBezier(\n  start: Point,\n  startControl: Point,\n  end: Point,\n  endControl: Point,\n  tolerance = 1\n): Point[] {\n  return new CubicBezier(\n    new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])\n  ).subdivide(tolerance) as Point[];\n}\n\nfunction hypot2(p: Point): number {\n  return p.x * p.x + p.y * p.y;\n}\n\n// Compute an approximation to int (1 + 4x^2) ^ -0.25 dx\nfunction approx_myint(x: number): number {\n  const d = 0.67;\n  return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));\n}\n\n// Approximate the inverse of `approx_myint`\nfunction approx_inv_myint(x: number): number {\n  const b = 0.39;\n  return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));\n}\n\n// Parameters for a basic parabola corresponding to a quadratic bzier curve\ntype QuadraticBezierBasicParams = {\n  x0: number;\n  x2: number;\n  scale: number;\n  cross: number;\n};\n\nclass QuadraticBezier {\n  start: Point;\n  control: Point;\n  end: Point;\n\n  constructor(start: Point, control: Point, end: Point) {\n    this.start = start;\n    this.control = control;\n    this.end = end;\n  }\n\n  eval(t: number): Point {\n    const mt = 1 - t;\n    return {\n      x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,\n      y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t,\n    };\n  }\n\n  mapToBasic(): QuadraticBezierBasicParams {\n    const { x: x0, y: y0 } = this.start;\n    const { x: x1, y: y1 } = this.control;\n    const { x: x2, y: y2 } = this.end;\n\n    // Determine the x values and scaling to map to y=x^2\n    const ddx = 2 * x1 - x0 - x2;\n    const ddy = 2 * y1 - y0 - y2;\n    const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;\n    const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;\n    const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;\n    const paramX0 = u0 / cross;\n    const paramX2 = u2 / cross;\n\n    // There's probably a more elegant formulation of this...\n    const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));\n\n    return { x0, x2, scale, cross };\n  }\n\n  subdivide(tolerance: number): Point[] {\n    const params = this.mapToBasic();\n    const a0 = approx_myint(params.x0);\n    const a2 = approx_myint(params.x2);\n    const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);\n    const n = Math.ceil(count);\n    const u0 = approx_inv_myint(a0);\n    const u2 = approx_inv_myint(a2);\n    const tValues = [0];\n    for (let i = 1; i < n; i++) {\n      const u = approx_inv_myint(a0 + ((a2 - a0) * i) / n);\n      const t = (u - u0) / (u2 - u0);\n      tValues.push(t);\n    }\n    tValues.push(1);\n    return tValues.map((t) => this.eval(t));\n  }\n}\n\nclass CubicBezier {\n  private c: Float64Array;\n\n  /// Argument is array of coordinate values [x0, y0, x1, y1, x2, y2, x3, y3].\n  constructor(coords: Float64Array) {\n    this.c = coords;\n  }\n\n  weightsum(c0: number, c1: number, c2: number, c3: number): Point {\n    const x = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];\n    const y = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];\n    return { x, y };\n  }\n\n  eval(t: number): Point {\n    const mt = 1 - t;\n    const c0 = mt * mt * mt;\n    const c1 = 3 * mt * mt * t;\n    const c2 = 3 * mt * t * t;\n    const c3 = t * t * t;\n    return this.weightsum(c0, c1, c2, c3);\n  }\n\n  deriv(t: number): Point {\n    const mt = 1 - t;\n    const c0 = -3 * mt * mt;\n    const c3 = 3 * t * t;\n    const c1 = -6 * t * mt - c0;\n    const c2 = 6 * t * mt - c3;\n    return this.weightsum(c0, c1, c2, c3);\n  }\n\n  // quadratic bezier with matching endpoints and minimum max vector error\n  midpoint_quadbez(): QuadraticBezier {\n    const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);\n    return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });\n  }\n\n  subsegment(t0: number, t1: number): CubicBezier {\n    const c = new Float64Array(8);\n    const p0 = this.eval(t0);\n    const p3 = this.eval(t1);\n    c[0] = p0.x;\n    c[1] = p0.y;\n    const scale = (t1 - t0) / 3;\n    const d1 = this.deriv(t0);\n    c[2] = p0.x + scale * d1.x;\n    c[3] = p0.y + scale * d1.y;\n    const d2 = this.deriv(t1);\n    c[4] = p3.x - scale * d2.x;\n    c[5] = p3.y - scale * d2.y;\n    c[6] = p3.x;\n    c[7] = p3.y;\n    return new CubicBezier(c);\n  }\n\n  // Very fancy subdivision scheme\n  subdivide(tol: number) {\n    const tol1 = 0.1 * tol; // error for subdivision into quads\n    const tol2 = tol - tol1; // error for subdivision of quads into lines\n    const sqrt_tol2 = Math.sqrt(tol2);\n    const err2 = hypot2(this.weightsum(1, -3, 3, -1));\n    const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));\n    const quads = [];\n    let sum = 0;\n    for (let i = 0; i < n_quads; i++) {\n      const t0 = i / n_quads;\n      const t1 = (i + 1) / n_quads;\n      const quad = this.subsegment(t0, t1).midpoint_quadbez();\n      const params = quad.mapToBasic();\n      const a0 = approx_myint(params.x0);\n      const a2 = approx_myint(params.x2);\n      const scale = Math.sqrt(params.scale);\n      let val = Math.abs(a2 - a0) * scale;\n      if (Math.sign(params.x0) != Math.sign(params.x2)) {\n        // min x value in basic parabola to make sure we don't skip cusp\n        const xmin = sqrt_tol2 / scale;\n        const cusp_val = (sqrt_tol2 * Math.abs(a2 - a0)) / approx_myint(xmin);\n        // I *think* it will always be larger, but just in case...\n        val = Math.max(val, cusp_val);\n      }\n      quads.push({\n        quad: quad,\n        a0: a0,\n        a2: a2,\n        val: val,\n      });\n      sum += val;\n    }\n    const count = (0.5 * sum) / sqrt_tol2;\n    const n = Math.ceil(count);\n    const result = [{ x: this.c[0], y: this.c[1] }];\n    let val = 0; // sum of vals from [0..i]\n    let i = 0;\n    for (let j = 1; j < n; j++) {\n      const target = (sum * j) / n;\n      while (val + quads[i].val < target) {\n        val += quads[i].val;\n        i++;\n      }\n      const a0 = quads[i].a0;\n      const a2 = quads[i].a2;\n      // Note: we can cut down on recomputing these\n      const u0 = approx_inv_myint(a0);\n      const u2 = approx_inv_myint(a2);\n      const a = a0 + ((a2 - a0) * (target - val)) / quads[i].val;\n      const u = approx_inv_myint(a);\n      const t = (u - u0) / (u2 - u0);\n      result.push(quads[i].quad.eval(t));\n    }\n    result.push({ x: this.c[6], y: this.c[7] });\n    return result;\n  }\n}\n", "import type { BoxStyle, SelectorStyle } from './selector-types';\n\nexport function parseCssToBoxStyleMap(css: string): Record<string, BoxStyle> {\n  const result: Record<string, BoxStyle> = {};\n\n  // Remove comments and normalize whitespace\n  const cleanCss = css\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\n  // Match CSS rules with selectors and their properties\n  const ruleRegex = /([^{]+)\\{([^}]+)\\}/g;\n  let match;\n\n  while ((match = ruleRegex.exec(cleanCss)) !== null) {\n    const selectorPart = match[1].trim();\n    const propertiesPart = match[2].trim();\n\n    // Extract class name from selector (remove . prefix)\n    const classMatch = selectorPart.match(/\\.([a-zA-Z0-9_-]+)/);\n    if (!classMatch) continue;\n\n    const className = classMatch[1];\n\n    // Parse properties\n    const properties = propertiesPart.split(';').filter((prop) => prop.trim());\n    const style: BoxStyle = {};\n\n    for (const prop of properties) {\n      const [key, value] = prop.split(':').map((s) => s.trim());\n      if (!key || !value) continue;\n\n      // Convert CSS property names to camelCase and map to BoxStyle properties\n      switch (key) {\n        case 'background-color':\n          style.backgroundColor = value;\n          break;\n        case 'opacity':\n          style.opacity = parseFloat(value);\n          break;\n        case 'box-shadow':\n          style.boxShadow = value;\n          break;\n        case 'border-color':\n          style.borderColor = value;\n          break;\n        case 'border-width':\n          style.borderWidth = value;\n          break;\n        case 'border-style':\n          style.borderStyle = value;\n          break;\n        case 'outline-color':\n          style.outlineColor = value;\n          break;\n        case 'outline-width':\n          style.outlineWidth = value;\n          break;\n        case 'outline-offset':\n          style.outlineOffset = value;\n          break;\n        case 'outline-style':\n          style.outlineStyle = value;\n          break;\n        case 'border':\n          style.border = value;\n          break;\n        case 'outline':\n          style.outline = value;\n          break;\n        case 'background':\n          style.background = value;\n          break;\n      }\n    }\n\n    result[className] = style;\n  }\n\n  return result;\n}\n\nexport function convertSelectorStyleToBoxStyle(style?: SelectorStyle): BoxStyle {\n  const result: BoxStyle = {};\n\n  if (!style) {\n    return result;\n  }\n\n  if (style.fill) {\n    result.backgroundColor = style.fill;\n    if (style.fillOpacity) {\n      // @todo.\n    }\n  }\n\n  if (style.stroke) {\n    result.borderColor = style.stroke;\n  }\n\n  if (style.strokeWidth) {\n    result.borderWidth = style.strokeWidth;\n  }\n\n  return result;\n}\n\nexport function convertBoxStyleToSelectorStyle(style: BoxStyle): SelectorStyle {\n  const result: SelectorStyle = {};\n\n  // Map backgroundColor to fill\n  if (style.backgroundColor) {\n    result.fill = style.backgroundColor;\n  }\n\n  // Map background to fill if backgroundColor is not available\n  if (!result.fill && style.background) {\n    result.fill = style.background;\n  }\n\n  // Map opacity to fillOpacity\n  if (typeof style.opacity !== 'undefined') {\n    result.fillOpacity = style.opacity;\n  }\n\n  // Map border properties to stroke\n  if (style.borderColor) {\n    result.stroke = style.borderColor;\n  }\n\n  // Map border shorthand to stroke if borderColor is not available\n  if (!result.stroke && style.border) {\n    // Extract color from border shorthand (simplified approach)\n    const borderParts = style.border.split(' ');\n    const colorPart = borderParts.find(\n      (part) => part.startsWith('#') || part.startsWith('rgb') || part.match(/^[a-z]+$/i)\n    );\n    if (colorPart) {\n      result.stroke = colorPart;\n    }\n  }\n\n  // Map borderWidth to strokeWidth\n  if (style.borderWidth) {\n    result.strokeWidth = style.borderWidth;\n  }\n\n  // Extract stroke width from border shorthand if borderWidth is not available\n  if (!result.strokeWidth && style.border) {\n    const borderParts = style.border.split(' ');\n    const widthPart = borderParts.find((part) => part.match(/^\\d+(?:px|em|rem|%)?$/));\n    if (widthPart) {\n      result.strokeWidth = widthPart;\n    }\n  }\n\n  return result;\n}\n\nconst styleParsedCache = new Map<string, Record<string, BoxStyle>>();\n\nexport function cachedParseCssToBoxStyleMap(id: string, css: string) {\n  if (styleParsedCache.has(id)) {\n    return styleParsedCache.get(id)!;\n  }\n\n  const styleMap = parseCssToBoxStyleMap(css);\n  styleParsedCache.set(id, Object.fromEntries(Object.entries(styleMap).map(([key, value]) => [key, value])));\n\n  return styleMap;\n}\n\nexport function resolveSelectorStyle(\n  styleClass?: string,\n  loadedStylesheets?: Record<string, string>,\n  existingStyle: SelectorStyle = {}\n): BoxStyle {\n  if (!styleClass || !loadedStylesheets) {\n    return convertSelectorStyleToBoxStyle(existingStyle || {});\n  }\n\n  const newStyle = convertSelectorStyleToBoxStyle(existingStyle || {});\n  const stylesheetEntries = Object.entries(loadedStylesheets);\n\n  for (const [id, css] of stylesheetEntries) {\n    if (!css) continue;\n    const styleMap = cachedParseCssToBoxStyleMap(id, css);\n    const classes = Object.entries(styleMap);\n    for (const [className, classStyle] of classes) {\n      if (className === styleClass) {\n        Object.assign(newStyle, classStyle);\n      }\n    }\n  }\n\n  return newStyle;\n}\n", "var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexport default arcToBezier;", "\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n", "\nmodule.exports = absolutize\n\n/**\n * redefine `path` with absolute coordinates\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction absolutize(path){\n\tvar startX = 0\n\tvar startY = 0\n\tvar x = 0\n\tvar y = 0\n\n\treturn path.map(function(seg){\n\t\tseg = seg.slice()\n\t\tvar type = seg[0]\n\t\tvar command = type.toUpperCase()\n\n\t\t// is relative\n\t\tif (type != command) {\n\t\t\tseg[0] = command\n\t\t\tswitch (type) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tseg[6] += x\n\t\t\t\t\tseg[7] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'v':\n\t\t\t\t\tseg[1] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'h':\n\t\t\t\t\tseg[1] += x\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tfor (var i = 1; i < seg.length;) {\n\t\t\t\t\t\tseg[i++] += x\n\t\t\t\t\t\tseg[i++] += y\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update cursor state\n\t\tswitch (command) {\n\t\t\tcase 'Z':\n\t\t\t\tx = startX\n\t\t\t\ty = startY\n\t\t\t\tbreak\n\t\t\tcase 'H':\n\t\t\t\tx = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'V':\n\t\t\t\ty = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'M':\n\t\t\t\tx = startX = seg[1]\n\t\t\t\ty = startY = seg[2]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tx = seg[seg.length - 2]\n\t\t\t\ty = seg[seg.length - 1]\n\t\t}\n\n\t\treturn seg\n\t})\n}\n", "/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport arcToCurve from 'svg-arc-to-cubic-bezier';\nimport parseSvgPath from 'parse-svg-path';\nimport absSvgPath, {\n  AbsoluteCubicBezierCommand,\n  AbsoluteLineCommand,\n  AbsoluteMoveCommand,\n  AbsoluteQuadraticBezierCommand,\n} from 'abs-svg-path';\n\nexport type NormalizedSvgPathCommand =\n  | AbsoluteMoveCommand\n  | AbsoluteLineCommand\n  | AbsoluteCubicBezierCommand\n  | AbsoluteQuadraticBezierCommand;\n\nexport type NormalizedSvgPathCommandType = 'M' | 'L' | 'C' | 'Q';\n\n/** Parse an SVG path and normalize it so it only contains Moves, Lines and Cubic or Quadratic Bzier curves\n *  in their absolute form. */\nexport function parseAndNormalizeSvgPath(path: string): NormalizedSvgPathCommand[] {\n  const parsed = parseSvgPath(path);\n  const absolute = absSvgPath(parsed);\n\n  let prevCmd: 'M' | 'L' | 'H' | 'V' | 'C' | 'S' | 'Q' | 'T' | 'A' | 'Z' | undefined;\n  let startX = 0;\n  let startY = 0;\n  let bezierX = 0;\n  let bezierY = 0;\n  let quadX: number | undefined;\n  let quadY: number | undefined;\n  let x = 0;\n  let y = 0;\n  const out: NormalizedSvgPathCommand[] = [];\n  for (let i = 0; i < absolute.length; i++) {\n    let seg = absolute[i];\n    const cmd = seg[0];\n    switch (cmd) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n      case 'H':\n        seg = ['L', seg[1], startY];\n        break;\n      case 'V':\n        seg = ['L', startX, seg[1]];\n        break;\n      case 'S':\n        {\n          let cx = x;\n          let cy = y;\n          if (prevCmd === 'C' || prevCmd == 'S') {\n            cx += cx - bezierX;\n            cy += cy - bezierY;\n          }\n          seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        }\n        break;\n      case 'T':\n        if (prevCmd === 'Q' || prevCmd == 'T') {\n          quadX = x * 2 - quadX!;\n          quadY = y * 2 - quadY!;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n        seg = ['Q', quadX, quadY, seg[1], seg[2]];\n        break;\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        break;\n      case 'A':\n        {\n          const curves = arcToCurve({\n            px: x,\n            py: y,\n            cx: seg[6],\n            cy: seg[7],\n            rx: seg[1],\n            ry: seg[2],\n            xAxisRotation: seg[3],\n            largeArcFlag: seg[4],\n            sweepFlag: seg[5],\n          });\n          if (!curves.length) {\n            continue;\n          }\n          for (const [j, curve] of curves.entries()) {\n            seg = ['C', curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];\n            if (j < curves.length - 1) {\n              out.push(seg);\n            }\n          }\n          // FIXME: Why do we need this cast?\n          seg = seg as NormalizedSvgPathCommand;\n        }\n        break;\n      case 'Z':\n        seg = ['L', startX, startY];\n        break;\n    }\n\n    prevCmd = cmd;\n    x = seg[seg.length - 2] as number;\n    y = seg[seg.length - 1] as number;\n    if (['C', 'Q', 'A'].indexOf(cmd) > -1) {\n      bezierX = seg[seg.length - 4] as number;\n      bezierY = seg[seg.length - 3] as number;\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n    out.push(seg);\n  }\n\n  return out;\n}\n", "/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\nimport type { ImageApiSelector, Selector } from '@iiif/presentation-3';\nimport { flattenCubicBezier, flattenQuadraticBezier } from './bezier';\nimport { resolveSelectorStyle } from './css-selectors';\nimport {\n  type NormalizedSvgPathCommand,\n  type NormalizedSvgPathCommandType,\n  parseAndNormalizeSvgPath,\n} from './normalize-svg';\nimport {\n  type ParsedSelector,\n  type SelectorStyle,\n  type SupportedSelectors,\n  type SvgSelector,\n  type SvgShapeType,\n  TemporalBoxSelector,\n  type TemporalSelector,\n} from './selector-types';\n\nconst BOX_SELECTOR =\n  /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?)/;\n\n// Does not support 00:00:00 or 00:00 formats.\nconst TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(\\.[0-9]+)?)?(,([0-9]+(\\.[0-9]+)?))?/;\n\nconst RGBA_COLOR = /^rgba\\((\\d+),(\\d+),(\\d+),([0-9.]+)\\)$/;\n\nexport function parseSelector(\n  source: Selector | Selector[],\n  {\n    domParser,\n    svgPreprocessor,\n    iiifRenderingHints,\n    loadedStylesheets,\n  }: {\n    domParser?: DOMParser;\n    svgPreprocessor?: (svg: string) => string;\n    iiifRenderingHints?: ImageApiSelector;\n    loadedStylesheets?: Record<string, string>;\n  } = {},\n  { styleClass }: { styleClass?: string } = {}\n): ParsedSelector {\n  if (Array.isArray(source)) {\n    return resolveHints(\n      (source as Array<string | Selector>).reduce(\n        <ParseSelector>(data: ParsedSelector, nextSource: string | Selector) => {\n          const {\n            selector,\n            selectors,\n            iiifRenderingHints: newIiifRenderingHints,\n          } = parseSelector(\n            nextSource,\n            {\n              domParser,\n              svgPreprocessor,\n              iiifRenderingHints,\n            },\n            { styleClass }\n          );\n          if (selector) {\n            if (!data.selector) {\n              data.selector = selector;\n            } else {\n              // @todo we could be smarter about the \"main\" selector.\n              if (!data.selector.temporal && selector.temporal) {\n                data.selector.temporal = selector.temporal;\n              }\n              if (!data.selector.spatial && selector.spatial) {\n                data.selector.spatial = selector.spatial;\n              }\n\n              // There is a bug here where the type won't resolve correctly... \"TemporalSVGSelector\" or whatever.\n              if (!data.selector.svg && selector.svg) {\n                data.selector.svg = selector.svg;\n              }\n              if (!data.selector.svgShape && selector.svgShape) {\n                data.selector.svgShape = selector.svgShape;\n              }\n            }\n            data.selectors.push(...selectors);\n          }\n          if (newIiifRenderingHints) {\n            data.iiifRenderingHints = data.iiifRenderingHints || {\n              type: 'ImageApiSelector',\n            };\n            Object.assign(data.iiifRenderingHints, newIiifRenderingHints);\n          }\n          return data;\n        },\n        {\n          selector: null,\n          selectors: [],\n          iiifRenderingHints,\n        } as ParsedSelector\n      )\n    );\n  }\n\n  if (!source) {\n    return resolveHints({\n      selector: null,\n      selectors: [],\n      iiifRenderingHints,\n    });\n  }\n\n  if (typeof source === 'string') {\n    const [id, fragment] = source.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return resolveHints({\n        selector: null,\n        selectors: [],\n        iiifRenderingHints,\n      });\n    }\n\n    return parseSelector(\n      { type: 'FragmentSelector', value: fragment },\n      { svgPreprocessor, iiifRenderingHints, domParser },\n      { styleClass }\n    );\n  }\n\n  if (source.type) {\n    if (source.type === 'PointSelector' && (source.t || source.t === 0)) {\n      const selector: TemporalSelector = {\n        type: 'TemporalSelector',\n        temporal: {\n          startTime: source.t,\n        },\n      };\n\n      return resolveHints({\n        selector,\n        selectors: [selector],\n        iiifRenderingHints,\n      });\n    }\n\n    if (source.type === 'PointSelector' && source.x && source.y) {\n      const selector: SupportedSelectors = {\n        type: 'PointSelector',\n        spatial: {\n          x: source.x,\n          y: source.y,\n        },\n      };\n\n      return resolveHints({\n        selector,\n        selectors: [selector],\n        iiifRenderingHints,\n      });\n    }\n  }\n\n  if (isImageApiSelector(source)) {\n    const selectors: SupportedSelectors[] = [];\n    if (source.region) {\n      const parsedRegion = parseSelector(\n        { type: 'FragmentSelector', value: 'xywh=' + source.region },\n        { domParser, svgPreprocessor, iiifRenderingHints },\n        { styleClass }\n      );\n      selectors.push(...parsedRegion.selectors);\n    }\n\n    return resolveHints({\n      selector: selectors[0],\n      selectors: selectors,\n      iiifRenderingHints: iiifRenderingHints ? { ...iiifRenderingHints, ...source } : source,\n    });\n  }\n\n  if (source.type === 'FragmentSelector') {\n    const matchBoxSelector = BOX_SELECTOR.exec(source.value);\n    if (matchBoxSelector) {\n      let selector: SupportedSelectors = {\n        type: 'BoxSelector',\n        spatial: {\n          unit: matchBoxSelector[2] === 'percent:' || matchBoxSelector[2] === 'pct:' ? 'percent' : 'pixel',\n          x: Number.parseFloat(matchBoxSelector[3]),\n          y: Number.parseFloat(matchBoxSelector[4]),\n          width: Number.parseFloat(matchBoxSelector[5]),\n          height: Number.parseFloat(matchBoxSelector[6]),\n        },\n        boxStyle: resolveSelectorStyle(styleClass, loadedStylesheets),\n      };\n\n      const matchBoxTimeSelector = source.value.match(TEMPORAL_SELECTOR);\n      if (matchBoxTimeSelector) {\n        selector = {\n          type: 'TemporalBoxSelector',\n          spatial: selector.spatial,\n          temporal: {\n            startTime: matchBoxTimeSelector[3] ? Number.parseFloat(matchBoxTimeSelector[3]) : 0,\n            endTime: matchBoxTimeSelector[6] ? Number.parseFloat(matchBoxTimeSelector[6]) : undefined,\n          },\n          boxStyle: resolveSelectorStyle(styleClass, loadedStylesheets),\n        };\n      }\n\n      return resolveHints({\n        selector,\n        selectors: [selector],\n        iiifRenderingHints,\n      });\n    }\n\n    const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);\n    if (matchTimeSelector) {\n      const selector: TemporalSelector = {\n        type: 'TemporalSelector',\n        temporal: {\n          startTime: matchTimeSelector[3] ? Number.parseFloat(matchTimeSelector[3]) : 0,\n          endTime: matchTimeSelector[6] ? Number.parseFloat(matchTimeSelector[6]) : undefined,\n        },\n      };\n\n      return resolveHints({\n        selector,\n        selectors: [selector],\n        iiifRenderingHints,\n      });\n    }\n\n    return resolveHints({\n      selector: null,\n      selectors: [],\n      iiifRenderingHints,\n    });\n  }\n\n  if (source.type === 'SvgSelector' && 'value' in source) {\n    if (!domParser) {\n      if (typeof window !== 'undefined') {\n        domParser = new window.DOMParser();\n      } else {\n        console.warn(\n          'No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized.'\n        );\n      }\n    }\n    let points: [number, number][] = [];\n    let rect: [number, number, number, number] | undefined;\n    let style: SelectorStyle | undefined;\n    let svg = svgPreprocessor?.(source.value) ?? source.value;\n    let svgShape: SvgShapeType | undefined;\n    if (domParser) {\n      const svgElement: SVGElement | null = domParser\n        .parseFromString(source.value, 'image/svg+xml')\n        .querySelector('svg');\n      if (!svgElement) {\n        console.warn(`Illegal SVG selector: ${source.value}`);\n        return resolveHints({\n          selector: null,\n          selectors: [],\n          iiifRenderingHints,\n        });\n      }\n      const selectorElem = getSelectorElement(svgElement);\n      if (selectorElem) {\n        points = selectorElem.points;\n        svgShape = selectorElem.shapeType;\n        rect = [\n          Math.min(...points.map((p) => p[0])), // llx\n          Math.min(...points.map((p) => p[1])), // lly\n          Math.max(...points.map((p) => p[0])), // urx\n          Math.max(...points.map((p) => p[1])), // ury\n        ];\n        ({ style, svg } = extractStyles(selectorElem.element) ?? { svg });\n      }\n    }\n    const sel: SvgSelector = {\n      type: 'SvgSelector',\n      svg,\n      svgShape,\n      style,\n      boxStyle: resolveSelectorStyle(styleClass, loadedStylesheets, style),\n      points: points.length ? points : undefined,\n      spatial: rect\n        ? {\n            unit: 'pixel',\n            x: rect[0],\n            y: rect[1],\n            width: rect[2] - rect[0],\n            height: rect[3] - rect[1],\n          }\n        : undefined,\n    };\n    return resolveHints({\n      selector: sel,\n      selectors: [sel],\n      iiifRenderingHints,\n    });\n  }\n  return resolveHints({\n    selector: null,\n    selectors: [],\n    iiifRenderingHints,\n  });\n}\n\nexport type SelectorElement = {\n  element: SVGElement;\n  points: [number, number][];\n  shapeType: SvgShapeType;\n};\n\nfunction getShapeTypeFromPath(svgPath: NormalizedSvgPathCommand[]): SvgShapeType {\n  const cmdFrequencies = svgPath\n    .map((seg) => seg[0])\n    .reduce(\n      (acc: Record<NormalizedSvgPathCommandType, number>, cmd) => {\n        acc[cmd] += 1;\n        return acc;\n      },\n      { C: 0, Q: 0, L: 0, M: 0 }\n    );\n  const cmdTypes = new Set(svgPath.map((seg) => seg[0]));\n  if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {\n    return 'path';\n  }\n  if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || (cmdTypes.size === 2 && cmdTypes.has('M')))) {\n    // Only lines and moves: rectangle, polygon or polyline?\n    if (cmdFrequencies.L === 4) {\n      return 'rect';\n    }\n\n    // Check if the path is closed to decide if we have a polygon or a polyline\n    const lastSeg = svgPath.slice(-1)[0];\n    if (\n      (svgPath[0][0] === 'M' && lastSeg[0] === 'L' && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2]) ||\n      (lastSeg[1] === 0 && lastSeg[2] === 0)\n    ) {\n      return 'polygon';\n    } else {\n      return 'polyline';\n    }\n  }\n  return 'path';\n}\n\nfunction getSelectorElement(svgElem: SVGElement): SelectorElement | null {\n  for (const element of Array.from(svgElem.children) as SVGElement[]) {\n    switch (element?.tagName.toLowerCase()) {\n      case 'g':\n        {\n          // Check if any of the children in the container can be converted to points\n          const res = getSelectorElement(element as SVGElement);\n          if (res) {\n            return res;\n          }\n        }\n        continue;\n      case 'path': {\n        const p = element.getAttribute('d');\n        if (!p) {\n          continue;\n        }\n        const normalized = parseAndNormalizeSvgPath(p);\n        return {\n          element,\n          points: pathToPoints(normalized),\n          shapeType: getShapeTypeFromPath(normalized),\n        };\n      }\n      case 'circle': {\n        const cx = Number.parseFloat(element.getAttribute('cx') ?? '0');\n        const cy = Number.parseFloat(element.getAttribute('cy') ?? '0');\n        const r = Number.parseFloat(element.getAttribute('r') ?? '0');\n        if (!r) {\n          continue;\n        }\n        const points: [number, number][] = [];\n        // TODO: Get rid of the degree -> radian conversion and use radians from the beginning\n        for (let angle = 0; angle <= 360; angle += 12) {\n          const rad = (angle * Math.PI) / 180;\n          points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);\n        }\n        return { element, points, shapeType: 'circle' };\n      }\n      case 'ellipse': {\n        const cx = Number.parseFloat(element.getAttribute('cx') ?? '0');\n        const cy = Number.parseFloat(element.getAttribute('cy') ?? '0');\n        const rx = Number.parseFloat(element.getAttribute('rx') ?? '0');\n        const ry = Number.parseFloat(element.getAttribute('ry') ?? '0');\n        if (!rx && !ry) {\n          continue;\n        }\n        const points: [number, number][] = [];\n        for (let angle = 0; angle <= 360; angle += 12) {\n          const t = Math.tan((angle / 360) * Math.PI);\n          const px = (rx * (1 - t ** 2)) / (1 + t ** 2);\n          const py = (ry * 2 * t) / (1 + t ** 2);\n          points.push([cx + px, cy + py]);\n        }\n        return { element, points, shapeType: 'ellipse' };\n      }\n      case 'line': {\n        const x0 = Number.parseFloat(element.getAttribute('x0') ?? '0');\n        const y0 = Number.parseFloat(element.getAttribute('y0') ?? '0');\n        const x1 = Number.parseFloat(element.getAttribute('x1') ?? '0');\n        const y1 = Number.parseFloat(element.getAttribute('y1') ?? '0');\n        if (x0 === x1 && y0 === y1) {\n          continue;\n        }\n        return {\n          element,\n          points: [\n            [x0, y0],\n            [x1, y1],\n          ],\n          shapeType: 'polyline',\n        };\n      }\n      case 'polygon':\n      case 'polyline': {\n        const points =\n          element\n            .getAttribute('points')\n            ?.split(' ')\n            .map((ps) => ps.split(',').map(Number.parseFloat) as [number, number]) ?? [];\n        if (!points.length) {\n          continue;\n        }\n        let shapeType: SvgShapeType = 'polyline';\n        if (element.tagName.toLowerCase() === 'polygon') {\n          // A polygon is a closed path, so the last point is the same as the first.\n          points.push(points[0]);\n          shapeType = 'polygon';\n        }\n        return { element, points, shapeType };\n      }\n      case 'rect': {\n        const x = Number.parseFloat(element.getAttribute('x') ?? '0');\n        const y = Number.parseFloat(element.getAttribute('y') ?? '0');\n        const width = Number.parseFloat(element.getAttribute('width') ?? '0');\n        const height = Number.parseFloat(element.getAttribute('height') ?? '0');\n        if (!width || !height) {\n          continue;\n        }\n        return {\n          element,\n          points: [\n            [x, y],\n            [x + width, y],\n            [x + width, y + height],\n            [x, y + height],\n            [x, y],\n          ],\n          shapeType: 'rect',\n        };\n      }\n      default:\n        // Try next element\n        continue;\n    }\n  }\n  return null;\n}\n\nfunction pathToPoints(normalizedPath: NormalizedSvgPathCommand[]): [number, number][] {\n  const out: [number, number][] = [];\n  for (let i = 0; i < normalizedPath.length; i++) {\n    const startPoint = out[out.length - 1] ?? [0, 0];\n    const seg = normalizedPath[i];\n    switch (seg[0]) {\n      case 'M':\n      case 'L':\n        out.push([seg[1], seg[2]]);\n        continue;\n      case 'C':\n        out.push(\n          ...flattenCubicBezier(\n            { x: startPoint[0], y: startPoint[1] },\n            { x: seg[1], y: seg[2] },\n            { x: seg[3], y: seg[4] },\n            { x: seg[5], y: seg[6] }\n          )\n            .map((p) => [p.x, p.y] as [number, number])\n            .slice(1) // skip first point, already part of output\n        );\n        continue;\n      case 'Q':\n        out.push(\n          ...flattenQuadraticBezier(\n            { x: startPoint[0], y: startPoint[1] },\n            { x: seg[1], y: seg[2] },\n            { x: seg[3], y: seg[4] }\n          )\n            .map((p) => [p.x, p.y] as [number, number])\n            .slice(1) // skip first point, already part of output\n        );\n        continue;\n    }\n  }\n  return out;\n}\n\n/** Extract styling information from SVG selector.\n *\n * Will remove all styling information from the SVG element\n * and normalize `rgba` colors for `fill` and `stroke` to\n * `rgb` and store the opacity in `fillOpacity` and `strokeOpacity`.\n */\nfunction extractStyles(selectorElement: SVGElement): { style?: SelectorStyle; svg: string } | undefined {\n  // TODO: Can this be simplified somehow?\n  const style: SelectorStyle = {};\n  if (selectorElement.hasAttribute('fill')) {\n    style.fill = selectorElement.getAttribute('fill')!;\n    selectorElement.removeAttribute('fill');\n  } else if (selectorElement.style && selectorElement.style.fill) {\n    style.fill = selectorElement.style.fill;\n  }\n  if (style.fill) {\n    const rgbaMatch = RGBA_COLOR.exec(style.fill);\n    if (rgbaMatch) {\n      style.fillOpacity = Number.parseFloat(rgbaMatch[4]);\n      style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;\n    }\n  }\n  if (selectorElement.hasAttribute('fill-opacity')) {\n    style.fillOpacity = Number.parseFloat(selectorElement.getAttribute('fill-opacity')!);\n    selectorElement.removeAttribute('fill-opacity');\n  } else if (selectorElement.style && selectorElement.style.fillOpacity) {\n    style.fillOpacity = Number.parseFloat(selectorElement.style.fillOpacity);\n  }\n\n  if (selectorElement.hasAttribute('stroke')) {\n    style.stroke = selectorElement.getAttribute('stroke')!;\n    selectorElement.removeAttribute('stroke');\n  } else if (selectorElement.style && selectorElement.style.stroke) {\n    style.stroke = selectorElement.style.stroke;\n  }\n  if (style.stroke) {\n    const rgbaMatch = RGBA_COLOR.exec(style.stroke);\n    if (rgbaMatch) {\n      style.strokeOpacity = Number.parseFloat(rgbaMatch[4]);\n      style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;\n    }\n  }\n  if (selectorElement.hasAttribute('stroke-opacity')) {\n    style.strokeOpacity = Number.parseFloat(selectorElement.getAttribute('stroke-opacity')!);\n    selectorElement.removeAttribute('stroke-opacity');\n  } else if (selectorElement.style && selectorElement.style.strokeOpacity) {\n    style.strokeOpacity = Number.parseFloat(selectorElement.style.strokeOpacity);\n  }\n  if (selectorElement.hasAttribute('stroke-width')) {\n    style.strokeWidth = selectorElement.getAttribute('stroke-width')!;\n    selectorElement.removeAttribute('stroke-width');\n  } else if (selectorElement.style && selectorElement.style.strokeWidth) {\n    style.strokeWidth = selectorElement.style.strokeWidth;\n  }\n  if (selectorElement.hasAttribute('stroke-dasharray')) {\n    style.strokeDasharray = selectorElement.getAttribute('stroke-dasharray')!;\n    selectorElement.removeAttribute('stroke-dasharray');\n  } else if (selectorElement.style && selectorElement.style.strokeDasharray) {\n    style.strokeDasharray = selectorElement.style.strokeDasharray;\n  }\n\n  let rootElem: SVGElement | null = selectorElement;\n  while (rootElem.tagName.toLowerCase() !== 'svg') {\n    rootElem = rootElem.parentElement as SVGElement | null;\n    if (rootElem === null) {\n      throw new Error('Could not find root SVG element');\n    }\n  }\n  return {\n    svg: rootElem.outerHTML,\n    style: Object.keys(style).length > 0 ? style : undefined,\n  };\n}\n\nexport function isImageApiSelector(t: unknown): t is ImageApiSelector {\n  if (!t) return false;\n  const type = (t as any).type || (t as any)['@type'];\n\n  return type === 'iiif:ImageApiSelector' || type === 'ImageApiSelector';\n}\n\nfunction resolveHints(supported: ParsedSelector): ParsedSelector {\n  if (supported.iiifRenderingHints) {\n    const source = supported.iiifRenderingHints;\n    if (source.rotation) {\n      const parsedRotation = parseRotation(`${source.rotation}`);\n      if (parsedRotation) {\n        if (supported.selectors.length) {\n          for (const selector of supported.selectors) {\n            selector.rotation = parsedRotation;\n          }\n        } else {\n          supported.selectors.push({\n            type: 'RotationSelector',\n            rotation: parsedRotation,\n          });\n        }\n      }\n    }\n  } else {\n    delete supported.iiifRenderingHints;\n  }\n\n  return supported;\n}\n\n/**\n * Parse rotation \"90\", \"180\", \"!90\"\n */\nexport function parseRotation(input: string) {\n  let num = Number.parseFloat(input);\n  if (num && input.startsWith('!')) {\n    // @note we don't support mirroring..\n    num = 360 - num;\n  }\n  if (num) {\n    num = num % 360;\n  }\n  if (num !== num) {\n    return 0;\n  }\n  return num || 0;\n}\n", "import type { ExternalWebResource, W3CAnnotationTarget } from '@iiif/presentation-3';\nimport { parseSelector } from './parse-selector';\nimport type { ParsedSelector, SupportedSelector } from './selector-types';\nimport type { SupportedTarget } from './target-types';\n\nexport function expandTarget(\n  target: W3CAnnotationTarget | W3CAnnotationTarget[],\n  options: {\n    typeMap?: Record<string, string>;\n    domParser?: DOMParser;\n    svgPreprocessor?: (svg: string) => string;\n    loadedStylesheets?: Record<string, string>;\n    defaultType?: string;\n    styleClass?: string;\n  } = {}\n): SupportedTarget {\n  if (Array.isArray(target)) {\n    // Don't support multiple targets for now.\n    return expandTarget(target[0]);\n  }\n\n  if (typeof target === 'string') {\n    const [id, fragment] = target.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: {\n          id,\n          type: (options.typeMap && (options.typeMap[id] as any)) || options.defaultType || 'Canvas',\n        },\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return expandTarget(\n      {\n        type: 'SpecificResource',\n        source: { id, type: (options.typeMap && (options.typeMap[id] as any)) || options.defaultType || 'Canvas' },\n        selector: {\n          type: 'FragmentSelector',\n          value: fragment,\n        },\n      },\n      options\n    );\n  }\n\n  // @todo, how do we want to support choices for targets.\n  if (\n    target.type === 'Choice' ||\n    target.type === 'List' ||\n    target.type === 'Composite' ||\n    target.type === 'Independents'\n  ) {\n    // we also don't support these, just choose the first.\n    return expandTarget(target.items[0], options);\n  }\n\n  if (!target.type && 'source' in target) {\n    (target as any).type = 'SpecificResource';\n  }\n\n  if (target.type === 'SpecificResource') {\n    if (target.source.type === 'Canvas' && target.source.partOf && typeof target.source.partOf === 'string') {\n      target.source.partOf = [\n        {\n          id: target.source.partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n    const styleClass = target.styleClass || options.styleClass;\n\n    let preParsedSelector = { selector: null, selectors: [] } as ParsedSelector;\n    if (typeof target.source === 'string' && target.source.includes('#')) {\n      const expandedAgain = expandTarget(target.source, { ...options, styleClass });\n      target.source = expandedAgain.source;\n      preParsedSelector = {\n        selector: expandedAgain.selector,\n        selectors: expandedAgain.selectors,\n      };\n    }\n\n    const { selector, selectors } = target.selector\n      ? parseSelector(target.selector, options, { styleClass })\n      : preParsedSelector;\n\n    return {\n      type: 'SpecificResource',\n      source: target.source,\n      selector,\n      selectors,\n    };\n  }\n\n  if (target.id) {\n    if ((target as any).type === 'Canvas' && (target as any).partOf && typeof (target as any).partOf === 'string') {\n      (target as any).partOf = [\n        {\n          id: (target as any).partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n\n    const [id, fragment] = target.id.split('#');\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: {\n          ...(target as any),\n          id,\n        },\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return expandTarget(\n      {\n        type: 'SpecificResource',\n        source: {\n          ...(target as any),\n          id,\n        },\n        selector: {\n          type: 'FragmentSelector',\n          value: fragment,\n        },\n      },\n      options\n    );\n  }\n\n  return {\n    type: 'SpecificResource',\n    source: target as ExternalWebResource,\n    selector: null,\n    selectors: [],\n  };\n}\n", "import { Annotation, AnyMotivation } from '@iiif/presentation-3';\nimport { expandTarget } from './annotation-targets/expand-target';\nimport { SupportedTarget } from './annotation-targets/target-types';\n\nexport type ContentState =\n  | string\n  | (Annotation & { '@context'?: string })\n  | (StateSource & { '@context'?: string })\n  | Array<string | (Annotation & { '@context'?: string }) | (StateSource & { '@context'?: string })>;\n\nexport type StateSource = {\n  id: string;\n  type: 'Manifest' | 'Canvas' | 'Range';\n  partOf?:\n    | string\n    | { id: string; type: string }\n    | Array<{\n        id: string;\n        type: string;\n      }>;\n};\n\n// Normalised content state?\nexport type NormalisedContentState = {\n  id: string;\n  type: 'Annotation';\n  motivation: ['contentState', ...string[]];\n  target: Array<SupportedTarget>;\n  extensions: Record<string, any>;\n};\n\ntype ValidationResponse = readonly [false, { reason?: string }] | readonly [true];\n\nexport function validateContentState(annotation: ContentState, strict = false): ValidationResponse {\n  // Valid content state.\n  if (typeof annotation === 'string') {\n    if (annotation.startsWith('{')) {\n      try {\n        const parsed = JSON.parse(annotation);\n        return validateContentState(parsed);\n      } catch (err) {\n        return [false, { reason: 'Invalid JSON' }];\n      }\n    }\n    return [true];\n  }\n\n  if (Array.isArray(annotation)) {\n    for (const anno of annotation) {\n      const [valid, reason] = validateContentState(anno);\n      if (!valid && reason) {\n        return [valid, reason] as const;\n      }\n    }\n\n    return [true];\n  }\n\n  if (annotation.type === 'Annotation') {\n    // We are validating the annotation.\n    return [true];\n  }\n\n  if (strict && annotation.type === 'Canvas' && !annotation.partOf) {\n    return [false, { reason: 'Canvas without partOf cannot be loaded' }];\n  }\n\n  return [true];\n}\n\nexport function serialiseContentState(annotation: ContentState): string {\n  return encodeContentState(typeof annotation === 'string' ? annotation : JSON.stringify(annotation));\n}\n\nexport function parseContentState(state: string): ContentState;\nexport function parseContentState(state: string, async: false): ContentState;\nexport async function parseContentState(state: string, async: true): Promise<ContentState>;\nexport function parseContentState(state: string, asyncOrFetcher?: boolean): ContentState | Promise<ContentState> {\n  state = state.trim();\n\n  if (state[0] === '{') {\n    // we might have json.\n    return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);\n  }\n\n  if (state.startsWith('http')) {\n    if (!asyncOrFetcher) {\n      throw new Error('Cannot fetch remote fetch with async=false in parseContentState');\n    }\n    // resolve.\n    return fetch(state).then((r) => r.json());\n  }\n\n  return parseContentState(decodeContentState(state), asyncOrFetcher as any);\n}\n\nexport function encodeContentState(state: string): string {\n  const uriEncoded = encodeURIComponent(state); // using built in function\n  const base64 = typeof btoa === 'undefined' ? Buffer.from(uriEncoded, 'utf-8').toString('base64') : btoa(uriEncoded); // using built in function\n  const base64url = base64.replace(/\\+/g, '-').replace(/\\//g, '_');\n  return base64url.replace(/=/g, '');\n}\n\nexport function decodeContentState(encodedContentState: string): string {\n  const base64url = restorePadding(encodedContentState);\n  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');\n  const base64Decoded = typeof atob === 'undefined' ? Buffer.from(base64, 'base64').toString('utf-8') : atob(base64); // using built in function\n  return decodeURIComponent(base64Decoded).trim(); // using built in function\n}\n\nfunction restorePadding(s: string) {\n  // The length of the restored string must be a multiple of 4\n  const pad = s.length % 4;\n\n  if (pad === 1) {\n    throw new Error('InvalidLengthError: Input base64url string is the wrong length to determine padding');\n  }\n\n  return s + (pad ? '===='.slice(0, 4 - pad) : '');\n}\n\nexport function normaliseContentState(state: ContentState): NormalisedContentState {\n  if (!state) {\n    throw new Error('Content state is empty');\n  }\n\n  if (!Array.isArray(state)) {\n    // We have multiples.\n    // throw new Error('Content state is an [Array] and not yet supported');\n    state = [state];\n  }\n\n  let annoId = 'vault://virtual-annotation/' + new Date().getTime(); // <-- need a virtual id\n  const motivation: AnyMotivation[] = ['contentState'];\n  const targets = [];\n\n  for (const source of state) {\n    if (typeof source === 'string') {\n      // Note: this is unlikely to happen in conjunction with parseContentState()\n      throw new Error('Content state is a [String] type and cannot be inferred');\n    }\n\n    // If we DO have annotation, then this is all we should be returning.\n    if (source.type === 'Annotation') {\n      annoId = source.id;\n      if (Array.isArray(source.motivation)) {\n        for (const singleMotivation of source.motivation) {\n          if (motivation.indexOf(singleMotivation) === -1) {\n            motivation.push(singleMotivation);\n          }\n        }\n      }\n\n      if (Array.isArray(source.target)) {\n        for (const target of source.target) {\n          const expanded = expandTarget(target as any);\n          targets.push(expanded);\n        }\n      } else {\n        const expanded = expandTarget(source.target as any);\n        targets.push(expanded);\n      }\n\n      continue;\n    }\n\n    const target = expandTarget(source as any);\n    targets.push(target);\n  }\n\n  return {\n    id: annoId,\n    type: 'Annotation',\n    motivation: ['contentState', ...((state as any).motivation || [])],\n    target: targets,\n    extensions: {},\n  };\n}\n", "/**\n * A string hashing function based on Daniel J. Bernstein's popular 'times 33' hash algorithm.\n * @author MatthewBarker <mrjbarker@hotmail.com>\n */\nexport function hash(object: any): string {\n  const text = JSON.stringify(object);\n\n  let numHash = 5381,\n    index = text.length;\n\n  while (index) {\n    numHash = (numHash * 33) ^ text.charCodeAt(--index);\n  }\n\n  const num = numHash >>> 0;\n\n  const hexString = num.toString(16);\n  if (hexString.length % 2) {\n    return '0' + hexString;\n  }\n  return hexString;\n}\n", "import { compressSpecificResource } from '@iiif/parser';\nimport type { Canvas, InternationalString, Manifest, Range, Reference, SpecificResource } from '@iiif/presentation-3';\nimport type { CanvasNormalized, ManifestNormalized, RangeNormalized } from '@iiif/presentation-3-normalized';\nimport { type CompatVault, compatVault } from './compat';\nimport { hash } from './shared-utilities';\n\nexport function createRangeHelper(vault: CompatVault = compatVault) {\n  return {\n    findFirstCanvasFromRange: (range: RangeNormalized) => findFirstCanvasFromRange(vault, range),\n    findAllCanvasesInRange: (range: RangeNormalized) => findAllCanvasesInRange(vault, range),\n    findManifestSelectedRange: (manifest: ManifestNormalized, canvasId: string) =>\n      findManifestSelectedRange(vault, manifest, canvasId),\n    findSelectedRange: (range: RangeNormalized, canvasId: string) => findSelectedRange(vault, range, canvasId),\n    rangesToTableOfContentsTree: (\n      rangeRefs: RangeNormalized[],\n      label?: InternationalString | null,\n      options: { showNoNav?: boolean } = {}\n    ) => rangesToTableOfContentsTree(vault, rangeRefs, label, options),\n    rangeToTableOfContentsTree: (\n      rangeRef: RangeNormalized | Reference<'Range'>,\n      options: { showNoNav?: boolean } = {}\n    ) => rangeToTableOfContentsTree(vault, rangeRef, [], options),\n    isContiguous: (\n      rangeRef: RangeNormalized | Reference<'Range'>,\n      canvasesRef: Canvas[] | CanvasNormalized[] | Reference<'Canvas'>[],\n      options: Partial<{ allowGaps: boolean; allowSubset: boolean; detail?: boolean }> = {}\n    ) => isRangeContiguous(vault, rangeRef, canvasesRef, options),\n  };\n}\n\nexport function findFirstCanvasFromRange(vault: CompatVault, range: RangeNormalized): null | Reference<'Canvas'> {\n  for (const inner of range.items) {\n    if (typeof inner === 'string') {\n      return { id: inner, type: 'Canvas' };\n    }\n    if ((inner as any).type === 'Canvas') {\n      return inner as any as Reference<'Canvas'>;\n    }\n    if (inner.type === 'SpecificResource') {\n      if (inner.source?.type === 'Canvas') {\n        return inner.source as Reference<'Canvas'>;\n      }\n    }\n    if (inner.type === 'Range') {\n      const found = findFirstCanvasFromRange(vault, vault.get(inner));\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n\nexport function findFirstCanvasFromRangeWithSelector(\n  vault: CompatVault,\n  range: RangeNormalized\n): null | SpecificResource<Reference<'Canvas'>> {\n  for (const inner of range.items) {\n    if (typeof inner === 'string') {\n      return {\n        type: 'SpecificResource',\n        source: { id: inner, type: 'Canvas' } as Reference<'Canvas'>,\n      };\n    }\n    if ((inner as any).type === 'Canvas') {\n      return {\n        type: 'SpecificResource',\n        source: inner as any as Reference<'Canvas'>,\n      };\n    }\n    if (inner.type === 'SpecificResource') {\n      if (inner.source?.type === 'Canvas') {\n        return inner as SpecificResource<Reference<'Canvas'>>;\n      }\n    }\n    if (inner.type === 'Range') {\n      const found = findFirstCanvasFromRangeWithSelector(vault, vault.get(inner));\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n\nexport function findAllCanvasesInRange(vault: CompatVault, range: RangeNormalized): Array<Reference<'Canvas'>> {\n  const found: Reference<'Canvas'>[] = [];\n  for (const inner of range.items) {\n    if (inner.type === 'SpecificResource' && inner.source?.type === 'Canvas') {\n      if (inner.source.id.indexOf('#') !== -1) {\n        found.push({ id: inner.source.id.split('#')[0], type: 'Canvas' });\n      } else {\n        found.push(inner.source as Reference<'Canvas'>);\n      }\n    }\n    if (inner.type === 'Range') {\n      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));\n    }\n    if ((inner as any).type === 'SpecificResource') {\n      const sourceId = typeof (inner as any).source === 'string' ? (inner as any).source : (inner as any).source.id;\n      found.push({ id: sourceId, type: 'Canvas' });\n    }\n  }\n  return found;\n}\n\nexport function findManifestSelectedRange(\n  vault: CompatVault,\n  manifest: ManifestNormalized,\n  canvasId: string\n): null | RangeNormalized {\n  for (const range of manifest.structures) {\n    const found = findSelectedRange(vault, vault.get(range), canvasId);\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\nexport function findSelectedRange(\n  vault: CompatVault,\n  range: RangeNormalized,\n  canvasId: string\n): null | RangeNormalized {\n  for (const inner of range.items) {\n    const parsedId = (inner as any)?.source?.id?.split('#')[0];\n    if ((inner as any).type === 'SpecificResource' && (inner as any).source === canvasId) {\n      return range;\n    }\n    if (inner.type === 'SpecificResource' && inner.source?.type === 'Canvas' && canvasId === parsedId) {\n      return range;\n    }\n    if (inner.type === 'Range') {\n      const found = findSelectedRange(vault, vault.get(inner), canvasId);\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n\nexport interface RangeTableOfContentsNode {\n  id: string;\n  type: 'Canvas' | 'Range';\n  label: InternationalString | null;\n  resource?: SpecificResource;\n  untitled?: boolean;\n  isCanvasLeaf: boolean;\n  isRangeLeaf: boolean;\n  isVirtual?: boolean;\n  isNoNav?: boolean;\n  firstCanvas?: SpecificResource<Reference<'Canvas'>> | null;\n  items?: Array<RangeTableOfContentsNode>;\n}\n\nexport function rangesToTableOfContentsTree(\n  vault: CompatVault,\n  rangeRefs: RangeNormalized[] | Range[] | Reference<'Range'>[],\n  label?: InternationalString | null,\n  options: { showNoNav?: boolean } = {}\n): RangeTableOfContentsNode | null {\n  if (rangeRefs.length === 0) {\n    return null;\n  }\n\n  const ranges = vault.get(rangeRefs);\n\n  if (ranges.length === 1) {\n    return rangeToTableOfContentsTree(vault, ranges[0] as any, [], options);\n  }\n\n  const virtualRoot: Range = {\n    id: `vault://virtual-root/${hash(ranges)}`,\n    type: 'Range',\n    label: label || { en: ['Table of Contents'] },\n    items: ranges as any,\n  };\n\n  return rangeToTableOfContentsTree(vault, virtualRoot, [], options);\n}\n\nexport function rangeToTableOfContentsTree(\n  vault: CompatVault,\n  rangeRef: undefined | null | Range | RangeNormalized | Reference<'Range'>,\n  seenIds: string[] = [],\n  options: { showNoNav?: boolean } = {}\n): RangeTableOfContentsNode | null {\n  if (!rangeRef) return null;\n\n  const range = vault.get(rangeRef, { skipSelfReturn: false });\n  const toc: RangeTableOfContentsNode = {\n    id: range.id,\n    type: 'Range',\n    label: range.label,\n    untitled: !range.label,\n    isCanvasLeaf: false,\n    isRangeLeaf: false,\n    isVirtual: range.id.startsWith('vault://virtual-root/'),\n    items: [],\n  };\n\n  if (seenIds.indexOf(toc.id) !== -1) {\n    toc.id = `vault://${hash(range)}`;\n  }\n\n  if (range.behavior && range.behavior.includes('no-nav')) {\n    if (options.showNoNav) {\n      toc.isNoNav = true;\n    } else {\n      return null;\n    }\n  }\n\n  if (!range.items) {\n    return toc;\n  }\n\n  for (const inner of range.items) {\n    if (typeof inner === 'string') {\n      const maybeCanvas = vault.get({ id: inner, type: 'Canvas' }, { skipSelfReturn: false });\n      const foundCanvas: RangeTableOfContentsNode = {\n        id: inner,\n        type: 'Canvas',\n        isCanvasLeaf: true,\n        isRangeLeaf: false,\n        isNoNav: range.behavior && range.behavior.includes('no-nav'),\n        label: maybeCanvas.label || { none: ['Untitled'] },\n        untitled: !maybeCanvas.label,\n        resource: {\n          type: 'SpecificResource',\n          source: { id: inner, type: 'Canvas' },\n        },\n      };\n\n      if (seenIds.indexOf(foundCanvas.id) !== -1) {\n        foundCanvas.id = `vault://${hash(inner)}`;\n      }\n\n      seenIds.push(foundCanvas.id);\n\n      toc.items!.push(foundCanvas);\n      continue;\n    }\n    if (inner.type === 'SpecificResource' && inner.source?.type === 'Canvas') {\n      const maybeCanvas = vault.get(inner.source);\n      const compressed = compressSpecificResource(inner);\n\n      if (!maybeCanvas) {\n        continue;\n      }\n\n      const foundCanvas: RangeTableOfContentsNode = {\n        id: compressed.type === 'Canvas' ? compressed.id : inner.source.id,\n        type: 'Canvas',\n        isCanvasLeaf: true,\n        isRangeLeaf: false,\n        label: maybeCanvas.label || { none: ['Untitled'] },\n        untitled: !maybeCanvas.label,\n        resource: inner,\n      };\n      if (seenIds.indexOf(foundCanvas.id) !== -1) {\n        foundCanvas.id = `vault://${hash(inner)}`;\n      }\n\n      seenIds.push(foundCanvas.id);\n\n      toc.items!.push(foundCanvas);\n      continue;\n    }\n    if ((inner as any).type === 'Canvas') {\n      const foundCanvas: RangeTableOfContentsNode = {\n        id: (inner as any).id,\n        type: 'Canvas',\n        label: (inner as any).label,\n        isCanvasLeaf: true,\n        isRangeLeaf: false,\n        resource: {\n          type: 'SpecificResource',\n          source: inner as any,\n        },\n      };\n\n      if (seenIds.indexOf(foundCanvas.id) !== -1) {\n        foundCanvas.id = `vault://${hash(inner)}`;\n      }\n\n      seenIds.push(foundCanvas.id);\n\n      toc.items!.push(foundCanvas);\n      continue;\n    }\n    if ((inner as any).type === 'Range') {\n      const foundRange = rangeToTableOfContentsTree(vault, inner as any, seenIds, options);\n      if (foundRange) {\n        toc.items!.push(foundRange);\n      }\n    }\n  }\n\n  toc.firstCanvas = findFirstCanvasFromRangeWithSelector(vault, range);\n  toc.isRangeLeaf = toc.items ? toc.items.filter((i) => i.type === 'Range').length === 0 : true;\n\n  return toc;\n}\n\nfunction getCanvasesFromRange(\n  vault: CompatVault,\n  rangeRef: Range | RangeNormalized | Reference<'Range'>,\n  path: string[] = []\n): Array<{ canvas: Canvas; path: string[] }> {\n  const range = vault.get(rangeRef);\n  const canvases: Array<{ canvas: Canvas; path: string[] }> = [];\n  const currentPath = range.id ? [...path, range.id] : path;\n\n  if (!range.items) {\n    return canvases;\n  }\n\n  for (const item of range.items) {\n    if (typeof item === 'string') {\n      canvases.push({ canvas: { id: item, type: 'Canvas' }, path: currentPath });\n    } else if (item.type === 'SpecificResource') {\n      const canvas = item.source;\n      if (canvas?.type === 'Canvas') {\n        canvases.push({ canvas: canvas as Canvas, path: currentPath });\n      } else {\n        // Unknown resource type.\n      }\n    } else if (item.type === 'Range') {\n      canvases.push(...getCanvasesFromRange(vault, item as Range, currentPath));\n    }\n  }\n  return canvases;\n}\n\ntype IsRangeContiguousDetail = {\n  isContiguous: boolean;\n  startIndex: number;\n  endIndex: number;\n  gaps: Array<{\n    startIndex: number;\n    endIndex: number;\n    canvasIds: string[];\n  }>;\n  invalidRanges: Array<{ id: string; reasons: string[] }>;\n  invalidCanvases: string[];\n  reason: string | null;\n};\n\nexport function isRangeContiguous(\n  vault: CompatVault,\n  rangeRef: Range | RangeNormalized | Reference<'Range'>,\n  canvasesRef: Canvas[] | CanvasNormalized[] | Reference<'Canvas'>[],\n  options: Partial<{ allowGaps: boolean; allowSubset: boolean; detail?: boolean }> = {}\n): [boolean, IsRangeContiguousDetail | null] {\n  const canvases = canvasesRef.map((c) => vault.get(c, { skipSelfReturn: false }));\n  const range = vault.get(rangeRef);\n  const allCanvasIds = canvases.map((c) => c.id);\n  const rangeCanvases = getCanvasesFromRange(vault, range);\n  const details: IsRangeContiguousDetail = {\n    isContiguous: true,\n    startIndex: -1,\n    endIndex: -1,\n    gaps: [],\n    invalidRanges: [],\n    invalidCanvases: [],\n    reason: null,\n  };\n\n  if (rangeCanvases.length === 0) {\n    if (options.detail) {\n      return [true, details];\n    }\n    return [true, null];\n  }\n\n  const indices = rangeCanvases.map(({ canvas }) => allCanvasIds.indexOf(canvas.id));\n\n  let isContiguous = true;\n\n  let lastIndex = -1;\n  const rangeInvalidReasons = new Map<string, string[]>();\n\n  const markRangeInvalid = (id: string, reason: string) => {\n    if (!rangeInvalidReasons.has(id)) {\n      rangeInvalidReasons.set(id, []);\n    }\n    const currentInvalid = rangeInvalidReasons.get(id)!;\n    if (currentInvalid.includes(reason)) {\n      return;\n    }\n    currentInvalid.push(reason);\n  };\n\n  for (let i = 0; i < indices.length; i++) {\n    const currentIndex = indices[i];\n    const canvasInfo = rangeCanvases[i];\n    const parentRangeId = canvasInfo.path[canvasInfo.path.length - 1];\n\n    if (currentIndex === -1) {\n      isContiguous = false;\n      if (parentRangeId) {\n        markRangeInvalid(parentRangeId, 'Canvas not found');\n      }\n      details.invalidCanvases.push(canvasInfo.canvas.id);\n      continue;\n    }\n\n    if (i > 0 && lastIndex !== -1) {\n      if (currentIndex <= lastIndex) {\n        isContiguous = false;\n        if (parentRangeId) {\n          markRangeInvalid(parentRangeId, 'Canvas out of order');\n        }\n        // Don't update last index.\n      } else {\n        const diff = currentIndex - lastIndex;\n        if (diff > 1) {\n          if (!options.allowGaps) {\n            isContiguous = false;\n          }\n          if (options.detail) {\n            details.gaps.push({\n              startIndex: lastIndex,\n              endIndex: currentIndex,\n              canvasIds: allCanvasIds.slice(lastIndex + 1, currentIndex),\n            });\n          }\n        }\n        lastIndex = currentIndex;\n      }\n    } else {\n      lastIndex = currentIndex;\n    }\n  }\n\n  if (!options.allowSubset) {\n    if (rangeCanvases.length !== allCanvasIds.length) {\n      isContiguous = false;\n    } else {\n      const allFound = allCanvasIds.every((id) => rangeCanvases.some((rc) => rc.canvas.id === id));\n      if (!allFound) {\n        isContiguous = false;\n      }\n    }\n  }\n\n  if (!options.detail) {\n    return [isContiguous, null];\n  }\n\n  const invalidRangeIds = Array.from(rangeInvalidReasons.keys());\n  if (invalidRangeIds.length > 0) {\n    details.invalidRanges = invalidRangeIds.map((id) => ({\n      id,\n      reasons: rangeInvalidReasons.get(id) || [],\n    }));\n  }\n\n  const result: IsRangeContiguousDetail = { ...details, isContiguous };\n\n  const validIndices = indices.filter((i) => i !== -1);\n  if (validIndices.length > 0) {\n    result.startIndex = validIndices[0];\n    result.endIndex = validIndices[validIndices.length - 1];\n  }\n\n  return [isContiguous, result];\n}\n", "import { Reference } from '@iiif/presentation-3';\nimport { CanvasNormalized, ManifestNormalized, RangeNormalized } from '@iiif/presentation-3-normalized';\nimport { findAllCanvasesInRange } from './ranges';\nimport { compatVault, CompatVault } from './compat';\n\nexport function createSequenceHelper(vault: CompatVault = compatVault) {\n  return {\n    getVisibleCanvasesFromCanvasId: (\n      manifestOrRange: ManifestNormalized | RangeNormalized,\n      canvasId: string | null,\n      preventPaged = false\n    ) => getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged),\n    getManifestSequence: (\n      manifestOrRange: ManifestNormalized | RangeNormalized,\n      options: { disablePaging?: boolean; skipNonPaged?: boolean } = {}\n    ) => getManifestSequence(vault, manifestOrRange, options),\n  };\n}\n\n/**\n * Get visible canvases from canvas ID\n *\n * This function returns a list of canvas references that should all be displayed\n * when the passed canvasId is visible. This should work for individual items,\n * 2-up paged view and continuous (scrolls).\n *\n * The options are listed below (from IIIF docs)\n *\n * - `unordered` - Valid on Collections, Manifests and Ranges. The Canvases included in resources that have this behavior\n *    have no inherent order, and user interfaces should avoid implying an order to the user. Disjoint with individuals,\n *    continuous, and paged.\n *\n * - `individuals` - Valid on Collections, Manifests, and Ranges. For Collections that have this behavior, each of the\n *    included Manifests are distinct objects in the given order. For Manifests and Ranges, the included Canvases are\n *    distinct views, and should not be presented in a page-turning interface. This is the default layout behavior if\n *    not specified. Disjoint with unordered, continuous, and paged.\n *\n * - `continuous`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and\n *    width dimensions. Canvases included in resources that have this behavior are partial views and an appropriate\n *    rendering might display all of the Canvases virtually stitched together, such as a long scroll split into\n *    sections. This behavior has no implication for audio resources. The viewingDirection of the Manifest will\n *    determine the appropriate arrangement of the Canvases. Disjoint with unordered, individuals and paged.\n *\n * - `paged`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and width\n *    dimensions. Canvases included in resources that have this behavior represent views that should be presented in\n *    a page-turning interface if one is available. The first canvas is a single view (the first recto) and thus the\n *    second canvas likely represents the back of the object in the first canvas. If this is not the case, see the\n *    behavior value non-paged. Disjoint with unordered, individuals, continuous, facing-pages and non-paged.\n *\n */\nexport function getVisibleCanvasesFromCanvasId(\n  vault: CompatVault = compatVault,\n  manifestOrRange: ManifestNormalized | RangeNormalized,\n  canvasId: string | null,\n  preventPaged = false\n): Reference<'Canvas'>[] {\n  const behavior = manifestOrRange.behavior || [];\n  const fullCanvas = canvasId ? vault.get<CanvasNormalized>(canvasId) : null;\n  if (!fullCanvas) {\n    return [];\n  }\n\n  const canvasBehavior = fullCanvas.behavior || [];\n  const isPaged = preventPaged ? false : behavior.includes('paged');\n  const isContinuous = isPaged ? false : behavior.includes('continuous');\n  const isIndividuals = isPaged || isContinuous ? false : behavior.includes('individuals');\n  const isCanvasFacingPages = canvasBehavior.includes('facing-pages');\n  const isCanvasNonPaged = canvasBehavior.includes('non-paged');\n\n  // Individuals should just be the default.\n  if (isCanvasFacingPages || isCanvasNonPaged || isIndividuals || preventPaged) {\n    return [{ id: fullCanvas.id, type: 'Canvas' }];\n  }\n\n  const [manifestItems, ordering] = getManifestSequence(vault, manifestOrRange);\n\n  // Continuous should just return all items together.\n  if (isContinuous) {\n    return manifestItems;\n  }\n\n  const canvasIndex = manifestItems.findIndex((r) => r.id === canvasId);\n  if (canvasIndex === -1) {\n    return [];\n  }\n\n  for (const indexes of ordering) {\n    if (indexes.includes(canvasIndex)) {\n      return indexes.map((index) => manifestItems[index]);\n    }\n  }\n\n  return [{ id: fullCanvas.id, type: 'Canvas' }];\n}\n\nexport function getManifestSequence(\n  vault: CompatVault = compatVault,\n  manifestOrRange: ManifestNormalized | RangeNormalized,\n  { disablePaging, skipNonPaged }: { disablePaging?: boolean; skipNonPaged?: boolean } = {}\n): [Reference<'Canvas'>[], number[][]] {\n  const behavior = manifestOrRange.behavior || [];\n  const isPaged = behavior.includes('paged');\n  const isContinuous = isPaged ? false : behavior.includes('continuous');\n  const isIndividuals = isPaged || isContinuous ? false : behavior.includes('individuals');\n  const manifestItems =\n    manifestOrRange.type === 'Manifest' ? manifestOrRange.items : findAllCanvasesInRange(vault, manifestOrRange);\n\n  // Continuous should just return all items together.\n  if (isContinuous) {\n    return [manifestItems, [manifestItems.map((_, index) => index)]];\n  }\n\n  // Individuals should just be the default.\n  if (isIndividuals || !isPaged || disablePaging) {\n    return [manifestItems, manifestItems.map((_, index) => [index])];\n  }\n\n  // This is the tricky case.\n  const ordering: number[][] = [];\n  let currentOrdering: number[] = [];\n\n  const flush = () => {\n    if (currentOrdering.length) {\n      ordering.push([...currentOrdering]);\n      currentOrdering = [];\n    }\n  };\n\n  let offset = 0;\n  let flushNextPaged = false;\n  for (let i = 0; i < manifestItems.length; i++) {\n    const canvas = vault.get<CanvasNormalized>(manifestItems[i]);\n    const canvasBehavior = canvas.behavior || [];\n    if (canvasBehavior.includes('non-paged')) {\n      if (i === offset) {\n        offset++;\n      }\n      if (!skipNonPaged) {\n        flush();\n        ordering.push([i]);\n        flush();\n      }\n      continue;\n    }\n\n    if (i === offset || canvasBehavior.includes('facing-pages')) {\n      // Flush and push a single.\n      if (currentOrdering.length) {\n        flushNextPaged = true;\n      }\n      flush();\n      ordering.push([i]);\n      flush();\n      continue;\n    }\n\n    currentOrdering.push(i);\n\n    if (flushNextPaged) {\n      flush();\n      flushNextPaged = false;\n      continue;\n    }\n\n    if (currentOrdering.length > 1) {\n      flush();\n    }\n  }\n\n  if (currentOrdering.length) {\n    flush();\n  }\n\n  return [manifestItems, ordering];\n}\n", "export const createAction: typeof import('typesafe-actions').createAction = function createAction(type: string) {\n  return function () {\n    const base = { type, getType: () => type, toString: () => type };\n    return (payload: any, meta: any) => ({\n      ...base,\n      ...(payload !== undefined && { payload }),\n      ...(meta !== undefined && { meta }),\n    });\n  };\n} as any;\n", "import type { InternationalString, SpecificResource } from '@iiif/presentation-3';\nimport type { ActionType } from 'typesafe-actions';\n\nimport type { Entities } from '../types';\nimport { createAction } from '../utility/typesafe-actions-runtime';\n\nexport const IMPORT_ENTITIES = '@iiif/IMPORT_ENTITIES';\n\nexport const MODIFY_ENTITY_FIELD = '@iiif/MODIFY_ENTITY_FIELD';\n\nexport const REORDER_ENTITY_FIELD = '@iiif/REORDER_ENTITY_FIELD';\nexport const MOVE_ENTITY = '@iiif/MOVE_ENTITY';\nexport const MOVE_ENTITIES = '@iiif/MOVE_ENTITIES';\n\nexport const ADD_REFERENCE = '@iiif/ADD_REFERENCE';\nexport const UPDATE_REFERENCE = '@iiif/UPDATE_REFERENCE';\n\nexport const REMOVE_REFERENCE = '@iiif/REMOVE_REFERENCE';\n\nexport const ADD_METADATA = '@iiif/ADD_METADATA';\nexport const REMOVE_METADATA = '@iiif/REMOVE_METADATA';\nexport const UPDATE_METADATA = '@iiif/UPDATE_METADATA';\nexport const REORDER_METADATA = '@iiif/REORDER_METADATA';\n\nexport const importEntities = createAction(IMPORT_ENTITIES)<{\n  entities: Partial<Entities>;\n}>();\n\nexport const modifyEntityField = createAction(MODIFY_ENTITY_FIELD)<{\n  type: keyof Entities;\n  id: string;\n  key: string;\n  value: any;\n}>();\n\nexport const reorderEntityField = createAction(REORDER_ENTITY_FIELD)<{\n  type: keyof Entities;\n  id: string;\n  key: string;\n  startIndex: number;\n  endIndex: number;\n}>();\n\nexport const moveEntity = createAction(MOVE_ENTITY)<{\n  subject: {\n    id: string;\n    type: keyof Entities;\n    index?: number;\n  };\n  from: {\n    id: string;\n    type: keyof Entities;\n    key: string;\n  };\n  to: {\n    id: string;\n    type: keyof Entities;\n    key: string;\n    index?: number;\n  };\n}>();\n\nexport const moveEntities = createAction(MOVE_ENTITIES)<{\n  subjects:\n    | {\n        type: 'list';\n        items: Array<{\n          id: string;\n          type: keyof Entities;\n          index?: number;\n        }>;\n      }\n    | {\n        type: 'slice';\n        startIndex: number;\n        length: number;\n      };\n  from: {\n    id: string;\n    type: keyof Entities;\n    key: string;\n  };\n  to: {\n    id: string;\n    type: keyof Entities;\n    key: string;\n    index?: number;\n  };\n}>();\n\nexport const addReference = createAction(ADD_REFERENCE)<{\n  type: keyof Entities;\n  id: string;\n  key: string;\n  index?: number;\n  reference: SpecificResource | ({ id: string; type: string } & any);\n}>();\n\nexport const removeReference = createAction(REMOVE_REFERENCE)<{\n  type: keyof Entities;\n  id: string;\n  key: string;\n  index?: number;\n  reference: SpecificResource | ({ id: string; type: string } & any);\n}>();\n\nexport const updateReference = createAction(UPDATE_REFERENCE)<{\n  type: keyof Entities;\n  id: string;\n  key: string;\n  index: number;\n  reference: SpecificResource | ({ id: string; type: string } & any);\n}>();\n\nexport const addMetadata = createAction(ADD_METADATA)<{\n  id: string;\n  type: keyof Entities;\n  beforeIndex?: number;\n  label: InternationalString;\n  value: InternationalString;\n}>();\nexport const updateMetadata = createAction(UPDATE_METADATA)<{\n  id: string;\n  type: keyof Entities;\n  atIndex?: number;\n  label: InternationalString;\n  value: InternationalString;\n}>();\nexport const removeMetadata = createAction(REMOVE_METADATA)<{\n  id: string;\n  type: keyof Entities;\n  atIndex: number;\n}>();\nexport const reorderMetadata = createAction(REORDER_METADATA)<{\n  id: string;\n  type: keyof Entities;\n  startIndex: number;\n  endIndex: number;\n}>();\n\nexport const entityActions = {\n  importEntities,\n  modifyEntityField,\n  reorderEntityField,\n  addReference,\n  removeReference,\n  updateReference,\n  addMetadata,\n  removeMetadata,\n  updateMetadata,\n  reorderMetadata,\n  moveEntity,\n  moveEntities,\n};\n\nexport type EntityActions = ActionType<typeof entityActions>;\n", "import { ActionType } from 'typesafe-actions';\nimport { createAction } from '../utility/typesafe-actions-runtime';\n\nexport const ADD_MAPPING = '@iiif/ADD_MAPPING';\nexport const ADD_MAPPINGS = '@iiif/ADD_MAPPINGS';\n\nexport const addMapping = createAction(ADD_MAPPING)<{ id: string; type: string }>();\nexport const addMappings = createAction(ADD_MAPPINGS)<{ mapping: { [id: string]: string } }>();\n\nexport const mappingActions = { addMapping, addMappings };\n\nexport type MappingActions = ActionType<typeof mappingActions>;\n", "import { ActionType } from 'typesafe-actions';\nimport { createAction } from '../utility/typesafe-actions-runtime';\n\nexport const RESOURCE_ERROR = 'RESOURCE_ERROR';\nexport const RESOURCE_LOADING = 'RESOURCE_LOADING';\nexport const RESOURCE_READY = 'RESOURCE_READY';\n\nexport const REQUEST_RESOURCE = '@iiif/REQUEST_RESOURCE';\nexport const REQUEST_ERROR = '@iiif/REQUEST_ERROR';\nexport const REQUEST_MISMATCH = '@iiif/REQUEST_MISMATCH';\nexport const REQUEST_COMPLETE = '@iiif/REQUEST_COMPLETE';\nexport const REQUEST_OFFLINE_RESOURCE = '@iiif/REQUEST_OFFLINE_RESOURCE';\n\nexport const requestResource = createAction(REQUEST_RESOURCE)<{ id: string }>();\nexport const requestError = createAction(REQUEST_ERROR)<{ id: string; message: string }>();\nexport const requestMismatch = createAction(REQUEST_MISMATCH)<{ requestId: string; actualId: string }>();\nexport const requestComplete = createAction(REQUEST_COMPLETE)<{ id: string }>();\nexport const requestOfflineResource = createAction(REQUEST_OFFLINE_RESOURCE)<{ id: string; entity: unknown }>();\n\nexport const requestActions = {\n  requestResource,\n  requestError,\n  requestMismatch,\n  requestComplete,\n  requestOfflineResource,\n};\n\nexport type RequestActions = ActionType<typeof requestActions>;\n", "import { ActionType } from 'typesafe-actions';\nimport { createAction } from '../utility/typesafe-actions-runtime';\nimport { AllActions, EntityStore } from '../types';\n\nexport const BATCH_ACTIONS = '@iiif/BATCH';\n\nexport const BATCH_IMPORT = '@iiif/BATCH_IMPORT';\n\nexport const batchActions = createAction(BATCH_ACTIONS)<{ actions: AllActions[] }>();\n\nexport const batchImport = createAction(BATCH_IMPORT)<{ state: EntityStore }>();\n\nexport type BatchAction = ActionType<typeof batchActions | typeof batchImport>;\n", "import { ActionType } from 'typesafe-actions';\nimport { createAction } from '../utility/typesafe-actions-runtime';\n\nexport const SET_META_VALUE = '@iiif/SET_META_VALUE';\nexport const SET_META_VALUE_DYNAMIC = '@iiif/SET_META_VALUE_DYNAMIC';\nexport const UNSET_META_VALUE = '@iiif/UNSET_META_VALUE';\n\nconst setMetaValue = createAction(SET_META_VALUE)<{ id: string; meta: string; key: string; value: any }>();\nconst setMetaValueDynamic = createAction(SET_META_VALUE_DYNAMIC)<{\n  id: string;\n  meta: string;\n  key: string;\n  updateValue: (oldValue: any) => any;\n}>();\nconst unsetMetaValue = createAction(UNSET_META_VALUE)<{ id: string; meta: string; key: string }>();\n\nexport const metaActions = {\n  setMetaValue,\n  setMetaValueDynamic,\n  unsetMetaValue,\n};\n\nexport type MetaActions = ActionType<typeof metaActions>;\n", "import { normalize } from '@iiif/parser';\nimport { AllActions } from '../types';\nimport { addMapping, addMappings, importEntities, requestComplete, requestError, requestMismatch } from '../actions';\n\nexport const actionListFromResource = (id: string, response: unknown): AllActions[] => {\n  const { entities, resource, mapping } = normalize(response);\n  if (resource.id === undefined) {\n    return [requestError({ id, message: 'ID is not defined in resource.' })] as AllActions[];\n  }\n  // Always import and add mappings.\n  const actions: AllActions[] = [importEntities({ entities: entities as any }), addMappings({ mapping })];\n  // Check if we have a resource mismatch\n  if (resource.id !== id) {\n    actions.push(addMapping({ id, type: resource.type as string }));\n    actions.push(requestMismatch({ requestId: id, actualId: resource.id }));\n  }\n  // Finally mark as complete.\n  actions.push(requestComplete({ id }));\n  // and return.\n  return actions;\n};\n", "// Source: https://github.com/alexreardon/memoize-one/blob/master/src/are-inputs-equal.ts\n// Number.isNaN as it is not supported in IE11 so conditionally using ponyfill\n// Using Number.isNaN where possible as it is ~10% faster\n\nconst safeIsNaN =\n  Number.isNaN ||\n  function ponyfill(value: unknown): boolean {\n    // // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#polyfill\n    // NaN is the only value in JavaScript which is not equal to itself.\n    return typeof value === 'number' && value !== value;\n  };\n\nfunction isEqual(first: unknown, second: unknown): boolean {\n  if (first === second) {\n    return true;\n  }\n\n  // Special case for NaN (NaN !== NaN)\n  if (safeIsNaN(first) && safeIsNaN(second)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function areInputsEqual(\n  newInputs: readonly unknown[] | unknown,\n  lastInputs: readonly unknown[] | unknown\n): boolean {\n  if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {\n    return newInputs === lastInputs;\n  }\n\n  // no checks needed if the inputs length has changed\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n  // Using for loop for speed. It generally performs better than array.every\n  // https://github.com/alexreardon/memoize-one/pull/59\n  for (let i = 0; i < newInputs.length; i++) {\n    if (!isEqual(newInputs[i], lastInputs[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n", "import { IIIFStore, NormalizedEntity } from '../types';\nimport { frameResource, HAS_PART, PART_OF } from '@iiif/parser';\n\nexport function resolveIfExists<T extends NormalizedEntity>(state: IIIFStore, url: string, parent?: any): T | undefined {\n  const request = state.iiif.requests[url];\n  // Return the resource.\n  const resourceType = state.iiif.mapping[url];\n  if (!resourceType || !(state.iiif.entities as any)[resourceType][request.resourceUri]) {\n    // Continue refetching resource, this is an invalid state.\n    return undefined;\n  }\n\n  const fullEntity: any = (state.iiif.entities as any)[resourceType][request.resourceUri] as T;\n\n  if (fullEntity && fullEntity[HAS_PART]) {\n    const framing = fullEntity[HAS_PART].find((t: any) => {\n      return parent ? t[PART_OF] === parent.id : t[PART_OF] === fullEntity.id;\n    });\n\n    return frameResource(fullEntity, framing);\n  }\n\n  return fullEntity;\n}\n", "export function isPromise<T>(value: T | Promise<T>): value is Promise<T> {\n  return value && typeof (value as any).then === 'function';\n}\n", "import { actionListFromResource } from './action-list-from-resource';\nimport { resolveIfExists } from './resolve-if-exists';\nimport { NormalizedEntity } from '../types';\nimport {\n  batchActions,\n  requestError,\n  requestResource,\n  RESOURCE_ERROR,\n  RESOURCE_LOADING,\n  RESOURCE_READY,\n} from '../actions';\nimport type { Vault } from '../vault';\nimport { isPromise } from './is-promise';\n\nexport function createFetchHelper<T>(\n  vault: Vault,\n  fetcher: (url: string, options?: T) => any | Promise<any>,\n  { waitTimeout = 30 }: { waitTimeout?: number } = {}\n) {\n  return (url: string, options?: T, mapper?: (r: any) => any): NormalizedEntity | undefined | Promise<NormalizedEntity | undefined> => {\n    const store = vault.getStore();\n    const state = store.getState();\n\n    const request = state.iiif.requests[url];\n    if (request) {\n      if (request.loadingState === RESOURCE_READY) {\n        // Return the resource.\n        const resolvedEntity = resolveIfExists(state, url);\n        if (resolvedEntity) {\n          return resolvedEntity;\n        }\n      }\n\n      switch (request.loadingState) {\n        case RESOURCE_ERROR:\n          // If it has errored, we will try again.\n          break;\n        case RESOURCE_LOADING: {\n          return (async () => {\n            // Subscribe and wait for resource to be done for X seconds, otherwise continue.\n            let cleanupSubscription: (() => void) | undefined;\n            let didContinue = false;\n            try {\n              const resolvedEntity = await Promise.race<NormalizedEntity | undefined>([\n                new Promise<NormalizedEntity | undefined>((resolve, reject) => {\n                  if (didContinue) {\n                    return;\n                  }\n                  cleanupSubscription = store.subscribe(() => {\n                    const latestState = store.getState();\n\n                    if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {\n                      reject();\n                      return;\n                    }\n\n                    if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {\n                      const maybeResolvedEntity = resolveIfExists(latestState, url);\n                      if (maybeResolvedEntity) {\n                        resolve(maybeResolvedEntity);\n                      } else {\n                        reject();\n                      }\n                    }\n                  });\n                }),\n                new Promise<undefined>((resolve, reject) =>\n                  setTimeout(\n                    () => {\n                      didContinue = true;\n                      reject();\n                    },\n                    waitTimeout * 60 * 1000\n                  )\n                ),\n              ]);\n              if (cleanupSubscription) {\n                cleanupSubscription();\n              }\n              if (resolvedEntity) {\n                return resolvedEntity;\n              }\n            } catch (e) {\n              if (cleanupSubscription) {\n                cleanupSubscription();\n              }\n            }\n          })();\n        }\n      }\n\n      // do nothing, and return?\n    }\n\n    vault.dispatch(requestResource({ id: url }));\n\n    const importResource = (resource: any) => {\n      if (!resource) {\n        return undefined;\n      }\n      if (!resource.id && !resource['@id']) {\n        if (resource['@type']) {\n          // assume it might be presentation 2.\n          resource['@id'] = url;\n          resource.id = url;\n        } else {\n          // assume presentation 3.\n          resource.id = url;\n        }\n      }\n      const toDispatch = actionListFromResource(url, resource);\n      vault.dispatch(batchActions({ actions: toDispatch }));\n      return resolveIfExists(store.getState(), url);\n    };\n\n    try {\n      const resourceOrPromise = fetcher(url, options);\n\n      if (isPromise(resourceOrPromise)) {\n        return (async () => {\n          try {\n            let data = await resourceOrPromise;\n            if (mapper) {\n              data = mapper(data);\n            }\n            return importResource(data);\n          } catch (err) {\n            vault.dispatch(requestError({ id: url, message: (err as any).toString() }));\n            // Rethrow.\n            throw err;\n          }\n        })();\n      }\n\n      // Assume it is a resource.\n      return importResource(mapper ? mapper(resourceOrPromise) : resourceOrPromise);\n    } catch (err) {\n      vault.dispatch(requestError({ id: url, message: (err as any).toString() }));\n      // Rethrow.\n      throw err;\n    }\n  };\n}\n", "import { Entities } from '../types';\n\nexport function getDefaultEntities(): Entities {\n  return {\n    Collection: {},\n    Manifest: {},\n    Canvas: {},\n    AnnotationPage: {},\n    AnnotationCollection: {},\n    Annotation: {},\n    ContentResource: {},\n    Range: {},\n    Service: {},\n    Selector: {},\n    Agent: {},\n  };\n}\n", "const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api)\n    return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording)\n      return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState)\n              return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0)\n    f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n", "import { MappingActions, ADD_MAPPING, ADD_MAPPINGS } from '../../actions';\n\nexport const mappingReducer = (state: Record<string, string> = {}, action: MappingActions) => {\n  switch (action.type) {\n    case ADD_MAPPING:\n      return {\n        ...state,\n        [action.payload.id]: action.payload.type,\n      };\n\n    case ADD_MAPPINGS:\n      return {\n        ...state,\n        ...action.payload.mapping,\n      };\n    default:\n      return state;\n  }\n};\n", "import { CompatibleStore } from '@iiif/parser';\n\nexport function isReferenceList(state: CompatibleStore['entities'], id: string, type: string, key: string) {\n  return !(\n    !state[type] ||\n    !state[type][id] ||\n    !(state[type][id] as any)[key] ||\n    !Array.isArray((state[type][id] as any)[key])\n  );\n}\n", "export function quickMerge(a: any, b: any) {\n  const newResource: any = {};\n  const added: string[] = [];\n  for (const [key, value] of Object.entries(a || {})) {\n    added.push(key);\n    const bValue = (b || {})[key];\n    if (!bValue || bValue.length === 0) {\n      newResource[key] = value;\n      continue;\n    }\n    newResource[key] = bValue;\n  }\n  for (const [key, value] of Object.entries(b || {})) {\n    if (added.indexOf(key) !== -1) {\n      continue;\n    }\n    // merge.\n    newResource[key] = value;\n  }\n\n  return newResource;\n}\n", "import { toRef } from '@iiif/parser';\nimport type { ActionType } from 'typesafe-actions';\nimport {\n  ADD_METADATA,\n  ADD_REFERENCE,\n  type EntityActions,\n  IMPORT_ENTITIES,\n  MODIFY_ENTITY_FIELD,\n  MOVE_ENTITIES,\n  MOVE_ENTITY,\n  moveEntity,\n  REMOVE_METADATA,\n  REMOVE_REFERENCE,\n  REORDER_ENTITY_FIELD,\n  REORDER_METADATA,\n  UPDATE_METADATA,\n  UPDATE_REFERENCE,\n} from '../../actions';\nimport type { Entities } from '../../types';\nimport { getDefaultEntities } from '../../utility';\nimport { isReferenceList } from '../../utility/is-reference-list';\nimport { quickMerge } from '../../utility/quick-merge';\n\nfunction payload<T extends { payload: any }>(action: T): T['payload'] {\n  return action.payload || {};\n}\n\nfunction findEntity(entity: any, property: string, resource: { id: string; type: keyof Entities; index?: number }) {\n  if (!entity[property] || !Array.isArray(entity[property])) {\n    return null;\n  }\n\n  const index =\n    typeof resource.index === 'undefined'\n      ? entity[property].findIndex((item: any) => {\n          if (!item) return false;\n          return toRef(item)?.id === resource.id;\n        })\n      : resource.index;\n\n  if (index === -1) {\n    return null;\n  }\n\n  return {\n    entity: entity[property][index],\n    index,\n  };\n}\n\nfunction getEntity(state: Entities, entity: { id: string; type: keyof Entities } | undefined | null) {\n  if (!entity?.id || !entity?.type) {\n    return;\n  }\n  return state[entity.type]?.[entity.id];\n}\n\nfunction numberOr(a: number | undefined, b: number): number {\n  return typeof a === 'undefined' ? b : a;\n}\n\nexport const entitiesReducer = (state: Entities = getDefaultEntities(), action: EntityActions): Entities => {\n  const updateField = (entity: any, values: any) => {\n    return {\n      ...state,\n      [(payload(action) as any).type]: {\n        ...((state as any)[(payload(action) as any).type] as any),\n        [(payload(action) as any).id]: {\n          ...entity,\n          ...values,\n        },\n      },\n    };\n  };\n\n  switch (action.type) {\n    case MODIFY_ENTITY_FIELD: {\n      // Invalid.\n      if (!state[payload(action).type] || !state[payload(action).type][payload(action).id]) {\n        return state;\n      }\n\n      const entity = state[payload(action).type][payload(action).id];\n      if (typeof entity === 'string') {\n        return state;\n      }\n\n      return updateField(entity, {\n        [payload(action).key]: payload(action).value,\n      });\n    }\n    case REORDER_ENTITY_FIELD: {\n      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {\n        return state;\n      }\n\n      const entity = state[payload(action).type][payload(action).id];\n      if (typeof entity === 'string') {\n        return state;\n      }\n\n      const result = Array.from(entity[payload(action).key]);\n      const [removed] = result.splice(payload(action).startIndex, 1);\n      result.splice(payload(action).endIndex, 0, removed);\n\n      return updateField(entity, { [payload(action).key]: result });\n    }\n    case MOVE_ENTITIES: {\n      const subjects = payload(action).subjects;\n      const from = payload(action).from;\n      const to = payload(action).to || from;\n      const fromEntity = getEntity(state, from);\n      const toKey = to?.key || from.key;\n\n      if (!isReferenceList(state, from.id, from.type, from.key) || !isReferenceList(state, to.id, to.type, to.key)) {\n        return state;\n      }\n\n      let newFromItems: any[] = [];\n      let itemsToMove: any[] = [];\n\n      if (subjects.type === 'slice') {\n        // Is there a fast path here.\n        const startIndex = subjects.startIndex;\n        const length = subjects.length;\n\n        newFromItems = Array.from(fromEntity[from.key]);\n        itemsToMove = newFromItems.splice(startIndex, length);\n      } else {\n        const newFromItemsWithNulls = Array.from(fromEntity[from.key]);\n        for (const subject of subjects.items) {\n          const foundFrom = findEntity(fromEntity, from.key, subject);\n          if (foundFrom) {\n            itemsToMove.push(foundFrom.entity);\n            newFromItemsWithNulls[foundFrom.index] = null;\n          }\n          newFromItems = newFromItemsWithNulls.filter((item) => item !== null);\n        }\n      }\n\n      const fromEntityWithoutFoundItems = {\n        ...fromEntity,\n        [from.key]: newFromItems,\n      };\n\n      const stateWithUpdatedFrom = {\n        ...state,\n        [from.type]: {\n          ...state[from.type],\n          [from.id]: fromEntityWithoutFoundItems,\n        },\n      };\n\n      const toEntity = getEntity(stateWithUpdatedFrom, to);\n\n      if (!toEntity) {\n        return state; // Hoepfully not!\n      }\n\n      const toIndex = typeof to?.index === 'undefined' ? toEntity[toKey].length : to.index;\n\n      const newToItems = Array.from(toEntity[to.key]);\n      newToItems.splice(toIndex, 0, ...itemsToMove);\n      const toEntityWithItem = {\n        ...toEntity,\n        [toKey]: newToItems,\n      };\n\n      const withUpdatedTo = {\n        ...stateWithUpdatedFrom,\n        [to.type]: {\n          ...stateWithUpdatedFrom[to.type],\n          [to.id]: toEntityWithItem,\n        },\n      };\n\n      return withUpdatedTo;\n    }\n\n    case MOVE_ENTITY: {\n      return entitiesReducer(state, {\n        type: MOVE_ENTITIES,\n        payload: {\n          subjects: { type: 'list', items: [payload(action).subject] },\n          from: payload(action).from,\n          to: payload(action).to,\n        },\n      });\n    }\n    case IMPORT_ENTITIES: {\n      const keys = Object.keys(payload(action).entities) as Array<keyof Entities>;\n      const toReturn: Entities = { ...state };\n\n      for (const key of keys) {\n        const entities = payload(action).entities[key];\n        const newEntities: any = { ...(state[key] || {}) };\n        let changed = false;\n        const ids = (Object.keys(entities || {}) as string[]) || [];\n        if (entities && ids) {\n          for (const id of ids) {\n            changed = true;\n            newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];\n          }\n          if (changed) {\n            toReturn[key] = newEntities as any;\n          }\n        }\n      }\n\n      return toReturn;\n    }\n\n    case ADD_REFERENCE: {\n      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {\n        return state;\n      }\n\n      const entity: any = state[payload(action).type][payload(action).id];\n      const result = Array.from(entity[payload(action).key]);\n      result.splice(numberOr(payload(action).index, result.length + 1), 0, payload(action).reference);\n\n      return updateField(entity, { [payload(action).key]: result });\n    }\n\n    case UPDATE_REFERENCE:\n    case REMOVE_REFERENCE: {\n      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {\n        return state;\n      }\n\n      const entity: any = state[payload(action).type][payload(action).id];\n      const result = Array.from(entity[payload(action).key]);\n      const indexToRemove = numberOr(\n        payload(action).index,\n        result.findIndex((e: any) => e && e.id === payload(action).reference.id)\n      );\n\n      if (indexToRemove === -1 || (result as any[])[indexToRemove]?.id !== payload(action).reference.id) {\n        // Nothing to remove.\n        return state;\n      }\n\n      if (action.type === UPDATE_REFERENCE) {\n        result.splice(indexToRemove, 1, payload(action).reference);\n      } else {\n        result.splice(indexToRemove, 1);\n      }\n\n      return updateField(entity, { [payload(action).key]: result });\n    }\n\n    case ADD_METADATA: {\n      const entity: any = state[payload(action).type][payload(action).id];\n      if (!entity) {\n        return state;\n      }\n      const metadata = Array.from(entity.metadata || []);\n      const actionPayload = payload(action);\n      metadata.splice(numberOr(action.payload.beforeIndex, metadata.length + 1), 0, {\n        label: actionPayload.label,\n        value: actionPayload.label,\n      });\n\n      return updateField(entity, { metadata });\n    }\n    case REORDER_METADATA: {\n      const entity: any = state[payload(action).type][payload(action).id];\n      if (typeof entity === 'string' || !entity) {\n        return state;\n      }\n\n      const metadata = Array.from(entity.metadata || []);\n      const [removed] = metadata.splice(payload(action).startIndex, 1);\n      metadata.splice(payload(action).endIndex, 0, removed);\n\n      return updateField(entity, { metadata });\n    }\n    case UPDATE_METADATA:\n    case REMOVE_METADATA: {\n      const entity = state[payload(action).type][payload(action).id];\n      const metadata = Array.from(entity.metadata || []);\n      const indexToRemove = payload(action).atIndex;\n\n      if (typeof indexToRemove === 'undefined' || indexToRemove === -1 || !(metadata as any[])[indexToRemove]) {\n        // Nothing to remove.\n        return state;\n      }\n\n      if (action.type === UPDATE_METADATA) {\n        metadata.splice(indexToRemove, 1, {\n          label: payload(action).label,\n          value: payload(action).value,\n        });\n      } else {\n        metadata.splice(indexToRemove, 1);\n      }\n\n      return updateField(entity, { metadata });\n    }\n\n    default:\n      return state;\n  }\n};\n", "import {\n  RequestActions,\n  REQUEST_COMPLETE,\n  REQUEST_ERROR,\n  REQUEST_MISMATCH,\n  REQUEST_OFFLINE_RESOURCE,\n  REQUEST_RESOURCE,\n  RESOURCE_ERROR,\n  RESOURCE_LOADING,\n  RESOURCE_READY,\n} from '../../actions';\nimport { RequestState } from '../../types';\n\nexport const requestReducer = (state: RequestState = {}, action: RequestActions) => {\n  switch (action.type) {\n    case REQUEST_RESOURCE:\n    case REQUEST_OFFLINE_RESOURCE:\n      return {\n        ...state,\n        [action.payload.id]: {\n          requestUri: action.payload.id,\n          loadingState: RESOURCE_LOADING,\n          uriMismatch: false,\n          resourceUri: action.payload.id,\n        },\n      };\n\n    case REQUEST_MISMATCH:\n      return {\n        ...state,\n        [action.payload.requestId]: {\n          ...(state[action.payload.requestId] || {}),\n          uriMismatch: true,\n          resourceUri: action.payload.actualId,\n        },\n        [action.payload.actualId]: {\n          requestUri: action.payload.requestId,\n          loadingState: state[action.payload.requestId].loadingState,\n          uriMismatch: true,\n          resourceUri: action.payload.actualId,\n        },\n      };\n\n    case REQUEST_ERROR:\n      return {\n        ...state,\n        [action.payload.id]: {\n          ...(state[action.payload.id] || {}),\n          loadingState: RESOURCE_ERROR,\n          error: action.payload.message,\n        },\n      };\n\n    case REQUEST_COMPLETE:\n      return {\n        ...state,\n        [action.payload.id]: {\n          ...(state[action.payload.id] || {}),\n          loadingState: RESOURCE_READY,\n          error: undefined,\n        },\n      };\n  }\n  return state;\n};\n", "import { MetaActions, SET_META_VALUE, SET_META_VALUE_DYNAMIC, UNSET_META_VALUE } from '../../actions';\n\ntype MetaState = Record<string, Record<string, Record<string, any>>>;\n\nexport const metaReducer = (state: MetaState = {}, action: MetaActions) => {\n  const { id, updateValue, value, meta, key } = ((action && action.payload) || {}) as any;\n  switch (action.type) {\n    case SET_META_VALUE: {\n      return {\n        ...state,\n        [id]: {\n          ...(state[id] || {}),\n          [meta]: {\n            ...(state[id] ? state[id][meta] || {} : {}),\n            [key]: value,\n          },\n        },\n      };\n    }\n    case SET_META_VALUE_DYNAMIC: {\n      return {\n        ...state,\n        [id]: {\n          ...(state[id] || {}),\n          [meta]: {\n            ...(state[id] ? state[id][meta] || {} : {}),\n            [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(undefined),\n          },\n        },\n      };\n    }\n\n    case UNSET_META_VALUE: {\n      if (state[id] && state[id][meta] && state[id][meta][key]) {\n        return {\n          ...state,\n          [id]: {\n            ...(state[id] || {}),\n            [meta]: {\n              ...(state[id] ? state[id][meta] || {} : {}),\n              [key]: undefined,\n            },\n          },\n        };\n      }\n      return state;\n    }\n\n    default:\n      return state;\n  }\n};\n", "export function combineReducers(\n  reducers: Record<any, (state: any, action: any) => any> = {}\n): (state: any, action: any) => any {\n  const reducerKeys = Object.keys(reducers);\n  return function combination(state = {}, action) {\n    let hasChanged = false;\n    const nextState: any = {};\n    for (let i = 0; i < reducerKeys.length; i++) {\n      const key = reducerKeys[i];\n      nextState[key] = reducers[key](state[key], action);\n      hasChanged = hasChanged || nextState[key] !== state[key];\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n", "import { BatchAction, BATCH_ACTIONS, BATCH_IMPORT } from '../../actions/batch-actions';\nimport { AllActions, IIIFStore, Reducer } from '../../types';\n\nexport function createBatchReducer(rootReducer: Reducer<IIIFStore, AllActions>) {\n  return (state: IIIFStore, action: BatchAction | AllActions) => {\n    if (action && action.type === BATCH_ACTIONS) {\n      return action.payload.actions.reduce(rootReducer, state);\n    }\n\n    if (action && action.type === BATCH_IMPORT) {\n      return {\n        ...state,\n        iiif: {\n          ...state.iiif,\n          ...action.payload.state,\n        },\n      } as IIIFStore;\n    }\n\n    return rootReducer(state, action);\n  };\n}\n", "import { createStore as create } from 'zustand/vanilla';\nimport type { StoreApi } from 'zustand/vanilla';\nimport { redux, devtools, subscribeWithSelector } from 'zustand/middleware';\nimport { mappingReducer } from './reducers/mapping-reducer';\nimport { entitiesReducer } from './reducers/entities-reducer';\nimport { requestReducer } from './reducers/request-reducer';\nimport { metaReducer } from './reducers/meta-reducer';\nimport { combineReducers } from '../utility/combine-reducers';\nimport { AllActions, IIIFStore } from '../types';\nimport { BatchAction } from '../actions';\nimport { createBatchReducer } from './reducers/batch-reducer';\nimport { getDefaultEntities } from '../utility';\n\nexport const reducers = combineReducers({\n  mapping: mappingReducer,\n  entities: entitiesReducer,\n  requests: requestReducer,\n  meta: metaReducer,\n});\n\ntype CreateStoreOptions = {\n  enableDevtools?: boolean;\n  iiifStoreName?: string;\n  customReducers?: any;\n  defaultState?: any;\n};\n\nfunction getDefaultState(): IIIFStore {\n  return {\n    iiif: {\n      entities: getDefaultEntities(),\n      meta: {},\n      mapping: {},\n      requests: {},\n    },\n  };\n}\nexport type VaultStoreState = StoreApi<IIIFStore & { dispatch: (action: AllActions | BatchAction) => void }> & {\n  dispatch: (action: AllActions | BatchAction) => void;\n};\n\nexport function createStore(options: CreateStoreOptions = {}) {\n  const {\n    enableDevtools = false,\n    iiifStoreName = 'iiif',\n    defaultState = getDefaultState(),\n    customReducers = {},\n  } = options;\n\n  const rootReducer = createBatchReducer(combineReducers({ [iiifStoreName]: reducers, ...customReducers }));\n  const enabled = Boolean(typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__);\n  const dv: typeof devtools = !enabled || process.env.NODE_ENV === 'test' ? (a: any, r: any) => a : devtools;\n\n  return create(\n    //\n    subscribeWithSelector(\n      //\n      dv(\n        //\n        redux(rootReducer, defaultState),\n        { enabled: enableDevtools }\n      )\n    )\n  );\n}\n\nexport type VaultZustandStore = ReturnType<typeof createStore>;\n", "import { Vault } from '../vault';\n\nfunction defineProperty(name: string, prototype: any, vault: Vault, enumerable = true) {\n  prototype[DEFINED] = prototype[DEFINED] || [];\n  prototype[DEFINED].push(name);\n\n  const cache = new Map();\n\n  Object.defineProperty(prototype, name, {\n    enumerable,\n    get(): any {\n      if (typeof prototype[REFS][name] === 'undefined') {\n        return undefined;\n      }\n\n      const ref = prototype[REFS][name];\n      if (!ref) {\n        return ref;\n      }\n      const object = vault.get(prototype[REFS][name], {\n        parent: this.id ? { id: this.id, type: this.type } : undefined,\n      });\n      if (!cache.has(object)) {\n        cache.clear();\n        cache.set(object, wrapObject(object, vault));\n      }\n      return cache.get(object);\n    },\n    set(items: any) {\n      const existing = prototype[REFS][name];\n      if (existing !== items) {\n        // This was a hack, but a much more clever implementation here could make very flexible editing.\n        // For example - manifest.label = \"Something\" -> manifest.label = {none: \"something\"}; etc.\n        // Although this might be better in a different library completely.\n        if (this[REACTIVE]) {\n          // Note: this should NOT be used for setting nested items. Only values.\n          vault.modifyEntityField({ id: this.id, type: this.type }, name, unwrapObject(items));\n        } else {\n          this[REFS][name] = items;\n        }\n      }\n    },\n  });\n}\n\nexport const REFS = Symbol.for('_refs_');\nexport const REACTIVE = Symbol.for('_reactive_');\nexport const DEFINED = Symbol.for('_defined_');\nexport const PARENT = Symbol.for('_parent_');\n\nexport type WrappedObject<OG = any> = {\n  subscribe(subscription: (object: any, vault: Vault) => void, skipInitial?: boolean): () => void;\n  reactive(): void;\n  unreactive(): void;\n  refresh(): void;\n  unwrap(): OG;\n  valueOf(): OG;\n  toPresentation3(): any;\n  toPresentation2(): any;\n  is(refOrObject: any): boolean;\n  toJSON(): any;\n};\n\nexport type ReactiveWrapped<Full = any, T = any> = {} & WrappedObject<Full> &\n  Omit<\n    Full,\n    | 'items'\n    | 'annotations'\n    | 'structures'\n    | 'seeAlso'\n    | 'rendering'\n    | 'partOf'\n    | 'start'\n    | 'supplementary'\n    | 'homepage'\n    | 'thumbnail'\n    | 'placeholderCanvas'\n    | 'accompanyingCanvas'\n    | 'provider'\n    | 'body'\n    | 'logo'\n  > & {\n    items: Full extends { items: (infer A)[] }\n      ? (Full['items'][number] & ReactiveWrapped<any, Full['items'][number]>)[]\n      : never;\n    annotations: Full extends { annotations: (infer A)[] }\n      ? ReactiveWrapped<any, Full['annotations'][number]>[]\n      : never;\n    structures: Full extends { structures: (infer A)[] } ? ReactiveWrapped<any, Full['structures'][number]>[] : never;\n    seeAlso: Full extends { seeAlso: (infer A)[] } ? ReactiveWrapped<any, Full['seeAlso'][number]>[] : never;\n    rendering: Full extends { rendering: (infer A)[] } ? ReactiveWrapped<any, Full['rendering'][number]>[] : never;\n    partOf: Full extends { partOf: (infer A)[] } ? ReactiveWrapped<any, Full['partOf'][number]>[] : never;\n    start: Full extends { start: (infer A)[] } ? ReactiveWrapped<any, Full['start'][number]>[] : never;\n    supplementary: Full extends { supplementary: (infer A)[] }\n      ? ReactiveWrapped<any, Full['supplementary'][number]>[]\n      : never;\n    homepage: Full extends { homepage: (infer A)[] } ? ReactiveWrapped<any, Full['homepage'][number]>[] : never;\n    thumbnail: Full extends { thumbnail: (infer A)[] } ? ReactiveWrapped<any, Full['thumbnail'][number]>[] : never;\n    placeholderCanvas: Full extends { placeholderCanvas: (infer A)[] }\n      ? ReactiveWrapped<any, Full['placeholderCanvas'][number]>[]\n      : never;\n    accompanyingCanvas: Full extends { accompanyingCanvas: (infer A)[] }\n      ? ReactiveWrapped<any, Full['accompanyingCanvas'][number]>[]\n      : never;\n    provider: Full extends { provider: (infer A)[] } ? ReactiveWrapped<any, Full['provider'][number]>[] : never;\n    body: Full extends { body: (infer A)[] } ? ReactiveWrapped<any, Full['body'][number]>[] : never;\n    logo: Full extends { logo: (infer A)[] } ? ReactiveWrapped<any, Full['logo'][number]>[] : never;\n  };\n\nfunction createPrototype<T, OG>(vault: Vault, reactive = false, parent?: string): ReactiveWrapped<T, OG> {\n  const prototype: WrappedObject<OG> & {\n    id: string;\n    type: string;\n    [REFS]: Record<string, any>;\n    [DEFINED]: any[];\n    [PARENT]: null | string;\n    [REACTIVE]: null | (() => void);\n  } = {\n    id: '',\n    type: 'unknown',\n    [DEFINED]: [],\n    [REFS]: {},\n    [PARENT]: parent || null,\n    [REACTIVE]: null,\n\n    is(refOrObject: any) {\n      if (typeof refOrObject === 'string') {\n        return this.id === refOrObject;\n      }\n\n      if (refOrObject.id) {\n        return refOrObject.id === this.id;\n      }\n\n      return false;\n    },\n\n    reactive() {\n      if (this[REACTIVE]) {\n        return;\n      }\n\n      this[REACTIVE] = this.subscribe(() => this.refresh(), true);\n\n      return () => {\n        this.unreactive();\n      };\n    },\n\n    refresh() {\n      if (this.id) {\n        const fresh = this.unwrap();\n        for (const key of Object.keys(fresh || {})) {\n          if (this[DEFINED].includes(key)) {\n            (this as any)[REFS][key] = (fresh as any)[key as any];\n          } else {\n            (this as any)[key] = (fresh as any)[key as any];\n          }\n        }\n      }\n    },\n\n    unreactive() {\n      if (this[REACTIVE]) {\n        this[REACTIVE]();\n        this[REACTIVE] = null;\n      }\n    },\n\n    unwrap() {\n      if (!this.id) {\n        throw new Error('Invalid object');\n      }\n      const parent = this[PARENT];\n      return vault.get(this.id, { parent: parent ? { id: parent, type: 'unknown' } : undefined });\n    },\n\n    toPresentation3() {\n      return vault.toPresentation3(this.unwrap() as any);\n    },\n\n    toPresentation2() {\n      return vault.toPresentation2(this.unwrap() as any);\n    },\n\n    valueOf() {\n      return this.unwrap() as any;\n    },\n\n    toJSON() {\n      const that = this as any;\n      return {\n        ...that,\n        items: that.items,\n        annotations: that.annotations,\n        structures: that.structures,\n        seeAlso: that.seeAlso,\n        service: that.service,\n        services: that.services,\n        rendering: that.rendering,\n        partOf: that.partOf,\n        start: that.start,\n        supplementary: that.supplementary,\n        homepage: that.homepage,\n        thumbnail: that.thumbnail,\n        placeholderCanvas: that.placeholderCanvas,\n        accompanyingCanvas: that.accompanyingCanvas,\n        provider: that.provider,\n      };\n    },\n    subscribe(subscription: (object: any, vault: Vault) => void, skipInitial = true) {\n      return vault.subscribe(\n        () => {\n          return this.id ? vault.get(this.id) : null;\n        },\n        subscription,\n        skipInitial\n      );\n    },\n  };\n\n  // Structural\n  defineProperty('items', prototype, vault);\n  defineProperty('annotations', prototype, vault);\n  defineProperty('structures', prototype, vault);\n\n  // Linking\n  defineProperty('seeAlso', prototype, vault);\n  // defineProperty('service', prototype, vault);\n  // defineProperty('services', prototype, vault);\n  defineProperty('rendering', prototype, vault);\n  defineProperty('partOf', prototype, vault);\n  defineProperty('start', prototype, vault, false);\n  defineProperty('supplementary', prototype, vault);\n  defineProperty('homepage', prototype, vault);\n\n  // Descriptive\n  defineProperty('thumbnail', prototype, vault);\n  defineProperty('placeholderCanvas', prototype, vault, false);\n  defineProperty('accompanyingCanvas', prototype, vault, false);\n  defineProperty('provider', prototype, vault);\n\n  // Annotation\n  defineProperty('body', prototype, vault);\n  defineProperty('logo', prototype, vault);\n\n  return prototype as any;\n}\n\nexport function isWrapped(object: any): object is WrappedObject {\n  return !!object[DEFINED];\n}\n\nexport function unwrapObject(object: any): any {\n  if (Array.isArray(object)) {\n    return object.map((o) => unwrapObject(o)) as any;\n  }\n\n  if (!object || !object.type) {\n    return object;\n  }\n\n  return { id: object.id, type: object.type };\n}\n\nexport function wrapObject<Type, NormalizedType = any>(\n  object: any,\n  vault: Vault,\n  reactive = false,\n  parent?: string\n): ReactiveWrapped<Type, NormalizedType> {\n  if (Array.isArray(object)) {\n    return object.map((o) => wrapObject(o, vault, reactive)) as any;\n  }\n  if (!object || !object.type || !object.id) {\n    return object;\n  }\n\n  const prototype = createPrototype(vault, reactive);\n  const newObject = Object.create(prototype);\n\n  const wrapped = Object.assign(newObject, object) as any;\n\n  if (reactive) {\n    wrapped.reactive();\n  }\n\n  return wrapped;\n}\n", "import { Entities } from '../types';\n\nexport function resolveType(type: string): keyof Entities {\n  switch (type) {\n    case 'Image':\n    case 'Video':\n    case 'Sound':\n    case 'Dataset':\n    case 'Text':\n    case 'Composite':\n    case 'List':\n    case 'Independents':\n    case 'Audience':\n      return 'ContentResource';\n    case 'ImageService1':\n    case 'ImageService2':\n    case 'ImageService3':\n      return 'Service';\n  }\n\n  return type as any;\n}\n", "/// <reference types=\"geojson\" />\n\nimport {\n  ActionFromType,\n  AllActions,\n  Entities,\n  IIIFStore,\n  NormalizedEntity,\n  PaginationState,\n  RefToNormalized,\n  RequestState,\n} from './types';\nimport { Collection, Manifest, Reference, SpecificResource } from '@iiif/presentation-3';\nimport {\n  frameResource,\n  HAS_PART,\n  isSpecificResource,\n  PART_OF,\n  serialize,\n  SerializeConfig,\n  serializeConfigPresentation2,\n  serializeConfigPresentation3,\n} from '@iiif/parser';\nimport { BATCH_ACTIONS, BatchAction, batchActions, entityActions, metaActions } from './actions';\nimport { createFetchHelper, areInputsEqual } from './utility';\nimport { createStore, VaultZustandStore } from './store';\nimport mitt, { Emitter } from 'mitt';\nimport { CollectionNormalized, ManifestNormalized } from '@iiif/presentation-3-normalized';\nimport { isWrapped, ReactiveWrapped, wrapObject } from './utility/objects';\nimport { resolveType } from './utility/resolve-type';\n\nexport type VaultOptions = {\n  reducers: Record<string, any>;\n  defaultState?: IIIFStore;\n  customFetcher: <T>(url: string, options: T) => unknown | Promise<unknown>;\n  enableDevtools: boolean;\n};\n\nexport type GetOptions = {\n  skipSelfReturn?: boolean;\n  parent?: Reference<any> | string;\n  preserveSpecificResources?: boolean;\n  skipPartOfCheck?: boolean;\n};\nexport type GetObjectOptions = GetOptions & { reactive?: boolean };\n\ntype AllActionsType = AllActions['type'];\n\nexport type EntityRef<Ref extends keyof Entities> = IIIFStore['iiif']['entities'][Ref][string];\n\nexport class Vault {\n  private readonly options: VaultOptions;\n  private readonly store: VaultZustandStore;\n  private readonly emitter: Emitter<any>;\n  private isBatching = false;\n  private batchQueue: AllActions[] = [];\n  remoteFetcher: (str: string, options?: any, mapper?: (resource: any) => any) => Promise<NormalizedEntity | undefined>;\n  staticFetcher: (str: string, json: any, mapper?: (resource: any) => any) => Promise<NormalizedEntity | undefined> | NormalizedEntity | undefined;\n\n  constructor(options?: Partial<VaultOptions>, store?: VaultZustandStore) {\n    this.options = Object.assign(\n      {\n        reducers: {},\n        customFetcher: this.defaultFetcher,\n        enableDevtools: true,\n      },\n      options || {}\n    );\n    this.store =\n      store ||\n      createStore({\n        customReducers: this.options.reducers,\n        defaultState: this.options.defaultState,\n        enableDevtools: this.options.enableDevtools,\n      });\n    this.emitter = mitt();\n    this.remoteFetcher = createFetchHelper(this, this.options.customFetcher) as any;\n    this.staticFetcher = createFetchHelper(this, (id: string, json: any) => json);\n  }\n\n  defaultFetcher = (url: string) => {\n    return fetch(url).then((r) => {\n      if (r.status === 200) {\n        return r.json();\n      } else {\n        const err = new Error(`${r.status} ${r.statusText}`);\n        err.name = `HTTPError`;\n        throw err;\n      }\n    });\n  };\n\n  batch(cb: (vault: this) => void) {\n    this.isBatching = true;\n    try {\n      cb(this);\n      this.isBatching = false;\n      this.dispatch(batchActions({ actions: this.batchQueue }));\n    } catch (e) {\n      // Even if we error, we still need to reset the queue.\n      this.batchQueue = [];\n      this.isBatching = false;\n      // And then rethrow.\n      throw e;\n    }\n    this.batchQueue = [];\n  }\n\n  async asyncBatch(cb: (vault: this) => Promise<void> | void) {\n    this.isBatching = true;\n    try {\n      await cb(this);\n      this.isBatching = false;\n      this.dispatch(batchActions({ actions: this.batchQueue }));\n    } catch (e) {\n      // Even if we error, we still need to reset the queue.\n      this.batchQueue = [];\n      this.isBatching = false;\n      // And then rethrow.\n      throw e;\n    }\n    this.batchQueue = [];\n  }\n\n  modifyEntityField(entity: Reference<keyof Entities>, key: string, value: any) {\n    this.dispatch(\n      entityActions.modifyEntityField({\n        id: entity.id,\n        type: entity.type,\n        key,\n        value,\n      })\n    );\n  }\n\n  dispatch(action: AllActions | BatchAction) {\n    if (!this.isBatching) {\n      if (action.type === BATCH_ACTIONS) {\n        for (const realAction of action.payload.actions) {\n          this.emitter.emit(realAction.type, { action: realAction, state: this.store.getState() });\n        }\n        this.store.dispatch(action);\n        const state = this.getState();\n        for (const realAction of action.payload.actions) {\n          this.emitter.emit(`after:${realAction.type}`, { action: realAction, state });\n        }\n        return;\n      }\n\n      this.emitter.emit(action.type, { action, state: this.store.getState() });\n      this.store.dispatch(action);\n      const state = this.store.getState();\n      this.emitter.emit(`after:${action.type}`, { action, state });\n      return;\n    } else {\n      this.batchQueue.push(action as AllActions);\n    }\n  }\n\n  on<Type extends AllActions['type']>(\n    event: Type | `after:${Type}`,\n    handler: (ctx: { action: ActionFromType<Type>; state: IIIFStore }) => void\n  ) {\n    this.emitter.on(event, handler);\n    return () => {\n      this.emitter.off(event, handler);\n    };\n  }\n\n  serialize<Return>(entity: Reference<keyof Entities>, config: SerializeConfig) {\n    return serialize<Return>(this.getState().iiif, entity, config);\n  }\n\n  toPresentation2<Return>(entity: Reference<keyof Entities>) {\n    return this.serialize<Return>(entity, serializeConfigPresentation2);\n  }\n\n  toPresentation3<Return>(entity: Reference<keyof Entities>) {\n    return this.serialize<Return>(entity, serializeConfigPresentation3);\n  }\n\n  hydrate<R extends { type?: string }>(\n    reference: string | Partial<R>,\n    type?: string | GetOptions,\n    options?: GetOptions\n  ): RefToNormalized<R>;\n  hydrate<R extends { type?: string }>(\n    reference: string[] | Partial<R>[],\n    type?: string | GetOptions,\n    options?: GetOptions\n  ): RefToNormalized<R>[];\n  hydrate<R extends { type?: string }>(\n    reference: string | R | NormalizedEntity | string[] | R[] | NormalizedEntity[],\n    type?: string | GetOptions,\n    options: GetOptions = {}\n  ): RefToNormalized<R> | RefToNormalized<R>[] {\n    return this.get<R>(reference as any, type as any, { ...options, skipSelfReturn: false });\n  }\n\n  get<R extends { type?: string }>(\n    reference: string | Partial<R> | Reference<R['type']> | SpecificResource<R>,\n    type?: string | GetOptions,\n    options?: GetOptions\n  ): RefToNormalized<R>;\n  get<R extends { type?: string }>(\n    reference: string[] | Partial<R>[] | Reference<R['type']>[] | SpecificResource<R>[],\n    type?: string | GetOptions,\n    options?: GetOptions\n  ): RefToNormalized<R>[];\n  get<R extends { type?: string }>(\n    reference:\n      | string\n      | R\n      | NormalizedEntity\n      | string[]\n      | R[]\n      | NormalizedEntity[]\n      | SpecificResource<R>\n      | SpecificResource<R>[],\n    type?: string | GetOptions,\n    options: GetOptions = {}\n  ): RefToNormalized<R> | RefToNormalized<R>[] {\n    if (typeof type !== 'string') {\n      options = type || {};\n      type = undefined;\n    }\n\n    const { skipSelfReturn = true } = options || {};\n    let parent = options.parent ? (typeof options.parent === 'string' ? options.parent : options.parent.id) : undefined;\n\n    // Multiples.\n    if (Array.isArray(reference)) {\n      return (reference as any[]).map((i) => this.get(i, options)) as EntityRef<any>[];\n    }\n\n    const state = this.getState();\n\n    if (isSpecificResource(reference) && !options.preserveSpecificResources) {\n      reference = reference.source;\n    }\n\n    // String IDs.\n    if (typeof reference === 'string') {\n      const _type: any = resolveType(type ? type : state.iiif.mapping[reference]);\n      if (!_type) {\n        if (skipSelfReturn) {\n          return null as any;\n        }\n        return { id: reference, type: 'unknown' } as any;\n      }\n      reference = { id: reference, type: _type };\n    }\n\n    if (reference && (reference as any).partOf && !parent && !options.skipPartOfCheck) {\n      const first = Array.isArray((reference as any).partOf) ? (reference as any).partOf[0] : (reference as any).partOf;\n      if (first) {\n        if (typeof first === 'string') {\n          parent = first;\n        }\n        if (typeof first.id === 'string') {\n          parent = first.id;\n        }\n      }\n    }\n\n    const _type = resolveType(type ? type : (reference as any)?.type);\n    const _id = (reference as any)?.id;\n    const entities = (state.iiif.entities as any)[_type];\n    if (!entities) {\n      const request = state.iiif.requests[_id];\n      if (request && request.resourceUri !== _id) {\n        return this.get(request.resourceUri, options);\n      }\n\n      if (skipSelfReturn) {\n        return null as any;\n      }\n      return reference as any;\n    }\n\n    const found = entities[(reference as any).id];\n    if (found && found[HAS_PART]) {\n      const framing = found[HAS_PART].find((t: any) => {\n        return parent ? t[PART_OF] === parent : t[PART_OF] === found.id;\n      });\n      return frameResource(found, framing);\n    }\n\n    return entities[(reference as any).id] || (skipSelfReturn ? null : reference);\n  }\n\n  select<R>(selector: (state: IIIFStore) => R): R {\n    return selector(this.getState());\n  }\n\n  getStore(): VaultZustandStore {\n    return this.store;\n  }\n\n  getState(): IIIFStore {\n    return this.store.getState();\n  }\n\n  deep(input?: any, prev?: any) {\n    if (typeof input === 'undefined') {\n      return this.get(prev, { skipSelfReturn: false });\n    }\n    if (typeof input === 'function') {\n      try {\n        const next = input(this.get(prev, { skipSelfReturn: false }));\n        const fn: any = (newInput: any) => this.deep(newInput, next);\n        fn.size = Array.isArray(next) ? next.length : 1;\n        return fn;\n      } catch (e) {\n        const fn: any = (newInput: any) => this.deep(newInput, undefined);\n        fn.size = 0;\n        return fn;\n      }\n    }\n    const fn: any = (newInput: any) => this.deep(newInput, input);\n    fn.size = Array.isArray(input) ? input.length : 1;\n    return fn;\n  }\n\n  loadManifest(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<ManifestNormalized | undefined> {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.load<ManifestNormalized>(_id, json, mapper);\n  }\n\n  loadCollection(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<CollectionNormalized | undefined> {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.load<CollectionNormalized>(_id, json, mapper);\n  }\n\n  load<T>(id: string | Reference<any>, json?: unknown, mapper?: (resource: any) => any): Promise<T | undefined> {\n    const _id = typeof id === 'string' ? id : id.id;\n    if (json) {\n      return Promise.resolve(this.staticFetcher(_id, json, mapper)) as Promise<T | undefined>;\n    }\n    return Promise.resolve(this.remoteFetcher(_id, {}, mapper)) as Promise<T | undefined>;\n  }\n\n  loadSync<T>(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): T | undefined {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.staticFetcher(_id, json, mapper) as T | undefined;\n  }\n\n  loadManifestSync(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): ManifestNormalized | undefined {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.loadSync<ManifestNormalized>(_id, json, mapper);\n  }\n\n  loadCollectionSync(id: string | Reference<any>, json: unknown, mapper?: (resource: any) => any): CollectionNormalized | undefined {\n    const _id = typeof id === 'string' ? id : id.id;\n    return this.loadSync<CollectionNormalized>(_id, json, mapper);\n  }\n\n  areInputsEqual(newInputs: readonly unknown[] | unknown, lastInputs: readonly unknown[] | unknown) {\n    return areInputsEqual(newInputs, lastInputs);\n  }\n\n  subscribe<T>(\n    selector: (state: IIIFStore) => T,\n    subscription: (state: T, vault: Vault) => void,\n    skipInitial: boolean\n  ): () => void;\n  subscribe<T>(subscription: (state: T, vault: Vault) => void, skipInitial?: boolean): () => void;\n  subscribe<T>(\n    selector: ((state: IIIFStore) => T) | ((state: T, vault: Vault) => void),\n    subscription?: ((state: T, vault: Vault) => void) | boolean,\n    skipInitial?: boolean\n  ): () => void {\n    if (\n      typeof skipInitial === 'undefined' &&\n      (typeof subscription === 'undefined' || subscription === false || subscription === true)\n    ) {\n      skipInitial = subscription;\n      subscription = selector as any;\n      selector = (a: any) => a;\n    }\n\n    return this.store.subscribe(selector as any, (s: any) => (subscription as any)(s, this), {\n      equalityFn: areInputsEqual,\n      fireImmediately: !skipInitial,\n    });\n  }\n\n  async ensureLoaded(_id: string | Reference<any>): Promise<void> {\n    const id = typeof _id === 'string' ? _id : _id.id;\n    if (!this.requestStatus(id)) {\n      await this.load(id);\n    }\n  }\n\n  requestStatus(id: string): RequestState[any] | undefined {\n    return this.select<RequestState[any]>((state) => {\n      return state.iiif.requests[id];\n    });\n  }\n\n\n  // Pagination built on \"meta\".\n  getPaginationState<T = any>(resource: string | Reference): PaginationState | null {\n    // This will return the pagination state of a resource from it's meta.\n    // If there is no pagination state, it will create it if needed.\n    const id = typeof resource === 'string' ? resource : resource.id;\n    if (!id) return null;\n\n    const existing = this.getResourceMeta(id, '@vault/pagination');\n    if (existing?.state) {\n      return existing.state;\n    }\n\n    const fullResource = this.get(resource);\n    if (fullResource.first) {\n      const initialState: PaginationState = {\n        currentPage: null,\n        currentPageIndex: null,\n        isFetching: false,\n        isFullyLoaded: false,\n        next: fullResource.first,\n        page: 1,\n        pages: [],\n        previous: null,\n        totalItems: fullResource.total,\n        currentLength: 0,\n      };\n\n      this.setMetaValue([id, '@vault/pagination', 'state'], initialState)\n\n      return initialState;\n    }\n\n    // @todo generate from resource.\n\n    return null;\n  }\n\n  async loadNextPage(resource: string | Reference, json?: any): Promise<[PaginationState | null, CollectionNormalized | null]> {\n    const id = typeof resource === 'string' ? resource : resource.id;\n    if (!id) return [null, null];\n\n    // This will get the pagination state and fetch the next page and load it into the vault.\n    const state = this.getPaginationState(resource);\n    if (!state || state.isFullyLoaded || !state.next) {\n      return [null, null];\n    }\n\n    if (state.isFetching) {\n      return [state, null];\n    }\n\n    const nextPage = typeof state.next === 'string' ? state.next : (state.next as any).id;\n    const previousPage = state.currentPage;\n\n    // 1. Update the meta state.\n    const newState: PaginationState = {\n      ...state,\n      isFetching: true,\n    };\n    this.setMetaValue([id, '@vault/pagination', 'state'], newState);\n\n    // 2. Make the fetch request.\n    let collectionPage;\n    try {\n      collectionPage = await this.loadCollection(nextPage, json, mapped => {\n        // This is required because the page MIGHT have the same id.\n        const { id, ['@id']: _id, ...properties } = mapped || {};\n\n        if (_id) {\n          return { ['@id']: nextPage, ...properties };\n        }\n\n        return { id: nextPage, ...properties };\n      })\n    } catch (err) {\n      const errState: PaginationState = {\n        ...state,\n        isFetching: false,\n        error: err,\n      };\n      this.setMetaValue([id, '@vault/pagination', 'state'], errState);\n      return [errState, null];\n    }\n\n    if (!collectionPage) {\n      const errState: PaginationState = {\n        ...state,\n        isFetching: false,\n        error: new Error(\"Collection not found\"),\n      };\n      this.setMetaValue([id, '@vault/pagination', 'state'], errState);\n      return [errState, null];\n    }\n\n    const fullCollection = this.get(id);\n    const combinedItems = [\n        ...(fullCollection.items || []),\n        ...(collectionPage.items || []),\n      ].map(resource => ({\n        id: resource.id, type: resource.type\n      }));\n\n    this.modifyEntityField({ id, type: \"Collection\" }, \"items\", combinedItems);\n    const latestState = this.getPaginationState(resource);\n    if (!latestState) throw new Error(\"Pagination state not found\");\n    const successState: PaginationState = {\n      ...latestState,\n      isFetching: false,\n      error: null,\n      currentPage: collectionPage.id,\n      next: (collectionPage as any).next?.id || null,\n      currentPageIndex: latestState.pages.length,\n      currentLength: combinedItems.length,\n      pages: [\n        ...latestState.pages,\n        {\n          id: collectionPage.id,\n          type: \"Collection\",\n          startIndex: fullCollection.items.length,\n          pageLength: collectionPage.items.length,\n          order: typeof latestState.currentPageIndex === 'number' ? latestState.currentPageIndex + 1 : 0,\n        }\n      ],\n      isFullyLoaded: !(collectionPage as any).next,\n      previous: previousPage,\n      page: latestState.pages.length + 1,\n    };\n\n    this.setMetaValue([id, '@vault/pagination', 'state'], successState);\n\n    return [successState, collectionPage];\n  }\n\n\n  getResourceMeta<T = any>(resource: string): Partial<T> | undefined;\n  getResourceMeta<T = any, Key extends keyof T = keyof T>(resource: string, metaKey: Key): T[Key] | undefined;\n  getResourceMeta<T = any, Key extends keyof T = keyof T>(\n    resource: string,\n    metaKey?: Key\n  ): Partial<T> | T[Key] | undefined {\n    const resourceMeta = this.getState().iiif.meta[resource as any] as any;\n\n    if (!resourceMeta) {\n      return undefined;\n    }\n    if (!metaKey) {\n      return resourceMeta as Partial<T>;\n    }\n\n    return resourceMeta[metaKey] as T[Key];\n  }\n\n  getObject<R extends { type?: string }>(\n    reference: string | Partial<R>,\n    type?: string | GetObjectOptions,\n    options?: GetObjectOptions\n  ): RefToNormalized<R>;\n  getObject<R extends { type?: string }>(\n    reference: string | R | NormalizedEntity,\n    type?: string | GetObjectOptions,\n    options: GetObjectOptions = {}\n  ): RefToNormalized<R> {\n    const { reactive, ...otherOptions } = options;\n    return wrapObject(this.get(reference as any, type, otherOptions), this, reactive) as any;\n  }\n\n  async loadObject<Type, NormalizedType = any>(\n    id: string | Reference<any>,\n    json?: any\n  ): Promise<ReactiveWrapped<Type, NormalizedType>> {\n    return wrapObject<Type, NormalizedType>(await this.load(id, json), this);\n  }\n  async loadManifestObject(\n    id: string | Reference<any>,\n    json?: any\n  ): Promise<ReactiveWrapped<Manifest, ManifestNormalized>> {\n    return wrapObject<Manifest, ManifestNormalized>(await this.loadManifest(id, json), this);\n  }\n  async loadCollectionObject(\n    id: string | Reference<any>,\n    json?: any\n  ): Promise<ReactiveWrapped<Collection, CollectionNormalized>> {\n    return wrapObject<Collection, CollectionNormalized>(await this.loadCollection(id, json), this);\n  }\n  wrapObject<T extends string>(objectType: Reference<T>) {\n    return wrapObject(this.get(objectType, { skipSelfReturn: false }), this);\n  }\n  isWrapped(object: any) {\n    return isWrapped(object);\n  }\n  setMetaValue<Value = any>(\n    [id, meta, key]: [string, string, string],\n    newValueOrUpdate: Value | ((oldValue: Value | undefined) => Value)\n  ) {\n    this.dispatch(\n      typeof newValueOrUpdate === 'function'\n        ? metaActions.setMetaValueDynamic({\n            id,\n            meta: meta as any,\n            key,\n            updateValue: newValueOrUpdate as any,\n          })\n        : metaActions.setMetaValue({\n            id,\n            meta: meta as any,\n            key,\n            value: newValueOrUpdate,\n          })\n    );\n  }\n}\n", "export function getGlobal(): any {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n", "import * as vaultModule from './vault';\nimport { getGlobal } from './utility/get-global';\n\ndeclare global {\n  const IIIF_VAULT: import('./vault').Vault;\n  const IIIFVault: typeof import('./vault');\n}\n\nexport function globalVault(options?: import('./vault').VaultOptions) {\n  const g = getGlobal();\n  try {\n    const gv = g['IIIF_VAULT'];\n\n    if (gv) {\n      return gv;\n    }\n  } catch (e) {\n    // no-op\n  }\n\n  const newVault = new vaultModule.Vault(options);\n\n  try {\n    g['IIIF_VAULT'] = newVault;\n  } catch (e) {\n    // no-op\n  }\n\n  return newVault;\n}\n", "import { convertPresentation2 } from './presentation-2/upgrader';\n\nexport const upgrade = convertPresentation2;\n", "import { Collection, Manifest } from '@iiif/presentation-3';\nimport { upgrade } from '@iiif/parser/upgrader';\n\nfunction fetchAndUpgrade(input: RequestInfo | URL, init?: RequestInit): Promise<Manifest | Collection> {\n  return fetch(input, init)\n    .then((resp) => resp.json())\n    .then(upgrade);\n}\n\nexport { fetchAndUpgrade as fetch };\n", "import {\n  SearchService as _SearchService,\n  SearchServiceAutocomplete,\n  IdOrAtId,\n  SearchServiceAutocompleteQueryParams,\n  SearchServiceAutocompleteResponse,\n  SearchServiceSearchResponse,\n  SearchServiceQueryParams,\n  Manifest,\n  SearchServiceCommonHitSelectors,\n} from '@iiif/presentation-3';\nimport { ManifestNormalized } from '@iiif/presentation-3-normalized';\nimport { g } from 'vitest/dist/suite-a18diDsI.js';\nimport { createStore } from 'zustand/vanilla';\n\nexport type Search1Service = _SearchService & {\n  service?: SearchServiceAutocomplete | SearchServiceAutocomplete[] | undefined;\n};\n\nconst getId = (idOrAtId: IdOrAtId<any>): string => (idOrAtId as any).id || (idOrAtId as any)['@id'];\n\nexport interface Search1AutocompleteStore {\n  hasAutocomplete: boolean;\n  endpoint: string | undefined;\n  results: SearchServiceAutocompleteResponse['terms'];\n  lastQuery: SearchServiceAutocompleteQueryParams | null;\n  loading: boolean;\n  error: boolean;\n  errorMessage: string;\n  ignored: string[];\n  setSearchService: (service: Search1Service) => void;\n  clearSearch: () => void;\n  search: (\n    query: string,\n    options?: { motivation?: string; date?: string; user?: string; headers?: HeadersInit }\n  ) => void | Promise<void>;\n}\n\nexport function findSearch1Service(manifest: ManifestNormalized | Manifest): Search1Service | null {\n  if (!manifest || !manifest.service) {\n    return null;\n  }\n  return manifest\n    ? (manifest.service.find(\n        (service: any) =>\n          (service as any).profile === 'SearchService1' ||\n          (service as any).profile === 'http://iiif.io/api/search/1/search'\n      ) as any)\n    : null;\n}\n\nexport function findAutocompleteService(service: Search1Service): SearchServiceAutocomplete | undefined {\n  if (!service || !service.service) return;\n  const services = Array.isArray(service.service) ? service.service : [service.service];\n  return services.find(\n    (s: any) =>\n      s.profile === 'http://iiif.io/api/search/0/autocomplete' ||\n      s.profile === 'http://iiif.io/api/search/1/autocomplete' ||\n      s.profile === 'AutoCompleteService1'\n  );\n}\n\nexport const createSearch1AutocompleteStore = (\n  service?: Search1Service | undefined,\n  options?: { fetcher?: Fetcher<SearchServiceAutocompleteResponse> }\n) => {\n  const fetcher: Fetcher<SearchServiceAutocompleteResponse> = options?.fetcher || defaultFetcher;\n  const autocomplete = service ? findAutocompleteService(service) : undefined;\n  const autocompleteEndpoint = autocomplete ? getId(autocomplete) : undefined;\n\n  let abort: AbortController | null = null;\n\n  return createStore<Search1AutocompleteStore>((set, get) => ({\n    results: [],\n    lastQuery: {} as SearchServiceAutocompleteQueryParams,\n    hasAutocomplete: !!autocomplete,\n    endpoint: autocompleteEndpoint,\n    loading: false,\n    error: false,\n    errorMessage: '',\n    ignored: [],\n\n    setSearchService(newService: Search1Service) {\n      const autocomplete = findAutocompleteService(newService);\n      if (autocomplete) {\n        set({\n          endpoint: getId(autocomplete),\n          hasAutocomplete: true,\n          results: [],\n          loading: false,\n          lastQuery: null,\n          error: false,\n          errorMessage: '',\n        });\n      }\n    },\n\n    clearSearch() {\n      set({ results: [], loading: false, lastQuery: null });\n    },\n\n    async search(\n      query: string,\n      options: { motivation?: string; date?: string; user?: string; headers?: HeadersInit } = {}\n    ) {\n      const endpoint = get().endpoint;\n      if (get().hasAutocomplete === false) {\n        return;\n      }\n      if (abort && !abort.signal.aborted) {\n        abort.abort();\n      }\n\n      abort = new AbortController();\n\n      const params = new URLSearchParams();\n      params.set('q', query);\n      if (options.motivation) {\n        params.set('motivation', options.motivation);\n      }\n      if (options.date) {\n        params.set('date', options.date);\n      }\n      if (options.user) {\n        params.set('user', options.user);\n      }\n\n      let shouldLoad = true;\n\n      if ((!query || query.length < 3) && !options.motivation && !options.date && !options.user) {\n        shouldLoad = false;\n      }\n\n      set({\n        loading: shouldLoad,\n        lastQuery: {\n          q: query,\n          motivation: options.motivation,\n          date: options.date,\n          user: options.user,\n        },\n      });\n\n      if (!shouldLoad) {\n        return;\n      }\n\n      return fetcher(`${endpoint}?${params.toString()}`, {\n        signal: abort.signal,\n        headers: {\n          'Content-Type': 'application/json',\n          Accept: 'application/json',\n          ...(options.headers || {}),\n        },\n      }).then(async ([json, error]) => {\n        if (abort?.signal.aborted) {\n          return;\n        }\n        if (json) {\n          set({\n            loading: false,\n            ignored: json.ignored || [],\n            results: json.terms,\n            error: false,\n            errorMessage: '',\n          });\n        } else {\n          set({ results: [], error: true, errorMessage: error || undefined });\n        }\n      });\n    },\n  }));\n};\n\nexport type SingleSearchHit = {\n  '@type': 'search:Hit';\n  annotations: string[];\n  selectors: Array<SearchServiceCommonHitSelectors>;\n  match?: string;\n  before?: string;\n  after?: string;\n};\n\nexport interface Search1Store {\n  endpoint: string | undefined;\n  service: Search1Service | undefined;\n  lastQuery: SearchServiceQueryParams;\n  resources: SearchServiceSearchResponse['resources'];\n  hits: SingleSearchHit[];\n  loading: boolean;\n  error: boolean;\n  hasAutocomplete: boolean;\n  hasSearch: boolean;\n  errorMessage: string;\n  hitIndex: number;\n  highlight: {\n    results: SearchServiceSearchResponse['resources'] | null;\n    hit: SingleSearchHit | null;\n  };\n  search: (query: SearchServiceQueryParams, options?: { headers?: HeadersInit }) => void | Promise<void>;\n  setSearchService: (service: Search1Service) => void;\n  clearSearch: () => void;\n  highlightHit: (index: number) => void;\n  nextHit: () => void;\n  previousHit: () => void;\n}\n\ntype FetcherReturn<T> = Promise<[T | null, error: string | null]>;\ntype Fetcher<T> = (query: string, options: { signal: AbortSignal; headers?: HeadersInit }) => FetcherReturn<T>;\n\nfunction defaultFetcher(\n  query: string,\n  { signal, headers }: { signal: AbortSignal; headers?: HeadersInit }\n): FetcherReturn<any> {\n  return fetch(query, {\n    signal: signal,\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n      ...(headers || {}),\n    },\n  }).then(async (response) => {\n    if (response.ok) {\n      return [await response.json(), null] as const;\n    }\n    return [null, response.statusText] as const;\n  });\n}\n\nexport const createSearch1Store = (\n  service?: Search1Service | string,\n  options?: {\n    fetcher?: Fetcher<SearchServiceSearchResponse>;\n  }\n) => {\n  const fetcher = options?.fetcher || defaultFetcher;\n\n  let searchService: Search1Service | undefined;\n  if (typeof service === 'string') {\n    searchService = {\n      '@context': 'http://iiif.io/api/search/1/context.json',\n      profile: 'http://iiif.io/api/search/1/search',\n      '@id': service,\n      id: service,\n      service: [],\n    };\n  } else {\n    searchService = service;\n  }\n\n  let abort: AbortController | null = null;\n\n  return createStore<Search1Store>((set, get) => ({\n    endpoint: searchService ? getId(searchService) : undefined,\n    service: searchService,\n    resources: [],\n    hits: [],\n    lastQuery: {} as SearchServiceQueryParams,\n    loading: false,\n    error: false,\n    highlight: {\n      results: null,\n      hit: null,\n    },\n    hitIndex: -1,\n    hasSearch: !!searchService,\n    hasAutocomplete: searchService ? !!findAutocompleteService(searchService) : false,\n    errorMessage: '',\n    async search(query: SearchServiceQueryParams, options: { headers?: HeadersInit } = {}) {\n      const endpoint = get().endpoint;\n      if (!endpoint) {\n        throw new Error('No search service found.');\n      }\n      if (abort && !abort.signal.aborted) {\n        abort.abort();\n      }\n\n      abort = new AbortController();\n\n      const params = new URLSearchParams();\n      if (query.q) {\n        params.set('q', query.q);\n      }\n      if (query.motivation) {\n        params.set('motivation', query.motivation);\n      }\n      if (query.date) {\n        params.set('date', query.date);\n      }\n      if (query.user) {\n        params.set('user', query.user);\n      }\n\n      set({\n        lastQuery: query,\n        loading: true,\n      });\n\n      const response = await fetcher(`${endpoint}?${params.toString()}`, {\n        signal: abort.signal,\n        headers: options.headers,\n      }).then(([json, errorMessage]) => {\n        if (abort?.signal.aborted) {\n          return;\n        }\n        if (json) {\n          set({\n            resources: (json.resources || []).map((result: any) => {\n              if (result.search && !result.url) {\n                result.url = result.search;\n              }\n              return result;\n            }),\n            hits:\n              json.hits ||\n              (json.resources || []).map((result: any) => {\n                return {\n                  '@type': 'search:Hit',\n                  after: '',\n                  annotations: [result['@id']],\n                  before: '',\n                  match: result.resource.chars,\n                };\n              }),\n            error: false,\n            errorMessage: '',\n            loading: false,\n          });\n        } else {\n          set({\n            loading: false,\n            resources: [],\n            error: true,\n            errorMessage: errorMessage || undefined,\n          });\n        }\n      });\n\n      return response;\n    },\n\n    setSearchService(newService: Search1Service) {\n      set({\n        service: newService,\n        endpoint: newService ? getId(newService) : undefined,\n        hasSearch: !!newService,\n        hasAutocomplete: newService ? !!findAutocompleteService(newService) : false,\n        loading: false,\n        resources: [],\n        error: false,\n        errorMessage: '',\n        highlight: { results: null, hit: null },\n      });\n    },\n\n    // Other actions?\n    clearSearch() {\n      set({ resources: [], error: false, errorMessage: '' });\n    },\n\n    highlightHit(index: number) {\n      const state = get();\n      const hit = state.hits[index];\n      if (!hit) {\n        return;\n      }\n      const results = state.resources.filter((r) => hit.annotations.includes(r['@id']));\n      set({ hitIndex: index, highlight: { results, hit } });\n    },\n    nextHit() {\n      const state = get();\n      const nextIndex = state.hitIndex + 1;\n      if (nextIndex >= state.hits.length) {\n        return;\n      }\n      state.highlightHit(nextIndex);\n    },\n    previousHit() {\n      const state = get();\n      const nextIndex = state.hitIndex - 1;\n      if (nextIndex < 0) {\n        return;\n      }\n      state.highlightHit(nextIndex);\n    },\n  }));\n};\n", "// Parse nav date fields and create a navigation tree.\n// Decades, years, months, and days are supported.\n// Manifests or Canvases can have a property like:\n// \"navDate\": \"1986-01-01T00:00:00+00:00\"\n// \"navDate\": \"1987-01-01T00:00:00+00:00\"\n\nimport { Collection, InternationalString, Manifest } from '@iiif/presentation-3';\nimport { CompatVault } from './compat';\nimport { CollectionNormalized, ManifestNormalized } from '@iiif/presentation-3-normalized';\n\nexport interface DateNavigationResource {\n  id: string;\n  type: 'Manifest' | 'Canvas';\n  label: InternationalString;\n  navDate: string;\n}\n\nexport interface DateNavigationDay {\n  id: string;\n  type: 'day';\n  count: number;\n  label: InternationalString;\n  day: number;\n  items: Array<DateNavigationResource>;\n}\n\nexport interface DateNavigationMonth {\n  id: string;\n  type: 'month';\n  month: number;\n  count: number;\n  label: InternationalString;\n  items: Array<DateNavigationDay>;\n}\n\nexport interface DateNavigationYear {\n  id: string;\n  type: 'year';\n  year: number;\n  count: number;\n  label: InternationalString;\n  items: Array<DateNavigationMonth>;\n}\n\nexport interface DateNavigationDecade {\n  id: string;\n  type: 'decade';\n  yearStart: number;\n  yearEnd: number;\n  label: InternationalString;\n  count: number;\n  items: Array<DateNavigationYear>;\n}\n\nexport interface DateNavigationCentury {\n  id: string;\n  type: 'century';\n  yearStart: number;\n  yearEnd: number;\n  label: InternationalString;\n  count: number;\n  items: Array<DateNavigationDecade>;\n}\n\nexport type DateNavigationTypes =\n  | DateNavigationCentury\n  | DateNavigationDecade\n  | DateNavigationYear\n  | DateNavigationMonth\n  | DateNavigationDay;\n\nexport function createDateNavigation<T extends DateNavigationTypes, Type = T['type']>(\n  vault: CompatVault,\n  manifestOrCollection: Manifest | Collection | ManifestNormalized | CollectionNormalized | string,\n  inputType?: Type\n) {\n  const type = inputType || 'century';\n  const items: T[] = [];\n\n  const centuries: DateNavigationCentury[] = [];\n\n  const resource = vault.get<any>(manifestOrCollection) as {\n    label?: InternationalString;\n    id: string;\n    items: Array<{\n      id: string;\n      type: string;\n      label?: InternationalString;\n      navDate?: string;\n    }>;\n  };\n\n  if (!resource.items) {\n    return items;\n  }\n\n  for (const item of resource.items) {\n    if (item.navDate) {\n      const d = new Date(item.navDate);\n      const year = d.getFullYear();\n      const month = d.getMonth();\n      const day = d.getDate();\n      const decade = Math.floor(year / 10) * 10;\n      const century = Math.floor(year / 100) * 100;\n      let centuryItem = centuries.find((i) => i.yearStart === century);\n      if (!centuryItem) {\n        centuryItem = {\n          id: `${resource.id}/century/${century}`,\n          label: { en: [`${century} - ${century + 99}`] },\n          type: 'century',\n          yearStart: century,\n          yearEnd: century + 99,\n          count: 1,\n          items: [],\n        };\n        if (type === 'century') {\n          items.push(centuryItem as T);\n        }\n        centuries.push(centuryItem);\n      } else {\n        centuryItem.count++;\n      }\n\n      let decadeItem = centuryItem.items.find((i) => i.yearStart === decade);\n      if (!decadeItem) {\n        decadeItem = {\n          id: `${resource.id}/decade/${decade}`,\n          label: { en: [`${decade} - ${decade + 9}`] },\n          type: 'decade',\n          yearStart: decade,\n          yearEnd: decade + 9,\n          count: 1,\n          items: [],\n        };\n        centuryItem.items.push(decadeItem);\n        if (type === 'decade') {\n          items.push(decadeItem as T);\n        }\n      } else {\n        decadeItem.count++;\n      }\n      let yearItem = decadeItem.items.find((i) => i.year === year);\n      if (!yearItem) {\n        yearItem = {\n          id: `${resource.id}/year/${year}`,\n          label: { en: [`${year}`] },\n          type: 'year',\n          year: year,\n          count: 1,\n          items: [],\n        };\n        decadeItem.items.push(yearItem);\n        if (type === 'year') {\n          items.push(yearItem as T);\n        }\n      } else {\n        yearItem.count++;\n      }\n      let monthItem = yearItem.items.find((i) => i.month === month);\n      if (!monthItem) {\n        monthItem = {\n          id: `${resource.id}/month/${year}/${month + 1}`,\n          // Month as string\n          label: {\n            en: [\n              type === 'month'\n                ? `${d.toLocaleString('default', { month: 'long' })} ${year}`\n                : `${d.toLocaleString('default', { month: 'long' })}`,\n            ],\n          },\n          type: 'month',\n          month: month,\n          count: 1,\n          items: [],\n        };\n        yearItem.items.push(monthItem);\n        if (type === 'month') {\n          items.push(monthItem as T);\n        }\n      } else {\n        monthItem.count++;\n      }\n      let dayItem = monthItem.items.find((i) => i.day === day);\n      if (!dayItem) {\n        dayItem = {\n          id: `${resource.id}/day/${year}/${month + 1}/${day}`,\n          label: { en: [`${d.toDateString()}`] },\n          type: 'day',\n          day: day,\n          count: 1,\n          items: [],\n        };\n        monthItem.items.push(dayItem);\n        if (type === 'day') {\n          items.push(dayItem as T);\n        }\n      } else {\n        dayItem.count++;\n      }\n      dayItem.items.push({\n        id: item.id,\n        type: item.type as any,\n        label: item.label || { en: [`${year}-${month + 1}-${day}`] },\n        navDate: item.navDate,\n      });\n    }\n  }\n\n  if (!inputType) {\n    // Filter until there's more than one per level.\n    let autoItem = items;\n    while (autoItem.length === 1) {\n      autoItem = autoItem[0].items as T[];\n    }\n    return autoItem;\n  }\n\n  return items;\n}\n"],
  "mappings": "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",
  "names": ["t", "e", "n", "r", "i", "props: any", "a", "o", "t", "e", "n", "r", "i", "t", "e", "o", "n", "r", "i", "e", "t", "n", "r", "i", "a", "l", "o", "s", "c", "e", "t", "n", "r", "e", "t", "n", "r", "level0: Profile", "level1: Profile", "level2: Profile", "P", "pathPart: string", "e", "t", "n", "r", "F", "size: SizeParameter", "I", "rotation: RotationParameter", "L", "canonicalId: string", "i", "a", "R", "input: string", "o", "s", "c", "l", "u", "d", "f", "p", "m", "levelProfile: string", "service: ImageService", "profiles: any[]", "final: Profile", "resource: any", "service: any", "service: ImageService", "e", "t", "supports", "e", "t", "n", "r", "i", "a", "o", "s", "sb: string[]", "c", "rotationParameter: RotationParameter", "req: ImageServiceImageRequest", "service?: ImageService", "serviceId: string", "e", "imageService: ImageService", "t", "R", "n", "width: number", "height: number", "sizes: ImageSize[]", "r", "i", "a", "scales: number[]", "level: 0 | 1 | 2", "imageService?: ImageService", "service: ImageService", "resource: { service?: Array<Service> }", "resource: any", "h", "e", "t", "g", "n", "r", "i", "newTiles: ImageTile[]", "o", "s", "a", "_", "v", "y", "log: string[]", "request: Required<ImageCandidateRequest>", "lastResorts: UnknownSizeImage[]", "fallback: Array<FixedSizeImage | VariableSizeImage>", "currentChoice: ImageCandidate | null", "c", "l", "b", "x", "S", "imagesSizes: ImageCandidate[]", "C", "candidates: ImageCandidate[]", "w", "T", "E", "imageServices", "request: ImageServiceRequest", "D", "O", "service", "k", "mitt", "u", "d", "handler: Handler<ImageServiceStoreEvents['image-service.loaded']>", "error: any", "A", "j", "r", "O", "helpers: Map<CompatVault, ReturnType<typeof createThumbnailHelper>>", "a", "t", "n", "s", "i", "o", "e", "c", "l", "T", "fullInput:\n      | string\n      | ManifestNormalized\n      | CollectionNormalized\n      | CanvasNormalized\n      | AnnotationNormalized\n      | AnnotationPageNormalized\n      | ContentResource\n      | ChoiceBody\n      | undefined", "u", "d", "e", "t", "o", "n", "r", "i", "maybeArray: T | T[]", "a", "obj: any", "n", "resource: unknown", "e", "r", "arg: any", "t", "i", "a", "resource: any", "typeHint?: string", "o", "traversals: TraversalMap", "options: Partial<TraverseOptions>", "traversal: (resource: any) => any", "resource: T", "collection: T", "collectionOrManifest: Manifest | Collection", "collection: Collection", "parent?: any", "geoJson: import('geojson').GeoJSON", "manifest: Manifest", "canvas: Canvas", "annotationPage: AnnotationPage", "annotation: Annotation", "annotationPageJson: AnnotationPage", "annotationBody: any", "json: T", "annotationJson: Annotation", "contentResourceJson: ContentResource", "choiceItem: ContentResource", "specificResource: SpecificResource", "range: Range", "rangeOrManifest: RangeItems", "agent: ResourceProvider", "object: T", "context: TraversalContext", "traversals: Array<Traversal<T>>", "acc: T", "traversal: Traversal<T>", "service: Service", "_service: any", "innerService: any", "types: TraversableEntityTypes[]", "o", "resource: any", "e", "t", "a", "s", "traversals: Partial<TraversalMap>", "options: Partial<TraverseOptions>", "r", "n", "traversal: (resource: any) => any", "collection: Collection", "seenIds: string[]", "manifest: Manifest", "sequence: Sequence", "canvas: Canvas", "range: Range", "innerRange: any", "canvas: any", "annotationList: AnnotationList", "annotation: Annotation", "layer: Layer", "choice: ChoiceEmbeddedContent", "service: Service", "contentResource: CommonContentResource", "item: any", "contentResource: OneOrMany<string | ContentResource>", "newResourceList: any[]", "resource: T", "allServices: OneOrMany<any>", "object: T | T[]", "traversals: Array<Traversal<T>>", "object: T", "acc: T", "traversal: Traversal<T>", "c", "l", "u", "inputLangProperty?: unknown", "languageArray: Presentation2.LanguageProperty[]", "d", "inputLangProperty?: Presentation2.OneOrMany<Presentation2.LanguageProperty>", "languageMap: Presentation3.InternationalString", "f", "profile: any | any[]", "p", "inputContexts: string | string[]", "contexts: string[]", "m", "inputProfile: string", "h", "str: string", "g", "_", "oldType: string | string[]", "profile: any", "context: any", "i", "v", "y", "license: string", "b", "license: Presentation2.RightsProperties['license']", "rights: Presentation3.DescriptiveProperties['rights']", "metadata: Presentation3.DescriptiveProperties['metadata']", "x", "S", "inputContext: string | string[] | undefined", "C", "metadata: Presentation2.DescriptiveProperties['metadata']", "w", "T", "resource: Presentation3.SomeRequired<Presentation2.TechnicalProperties, '@type'>", "subResource?: string", "E", "resource: Presentation3.SomeRequired<Presentation2.TechnicalProperties, '@type'> & {\n    motivation?: string | string[] | null;\n    format?: string;\n    profile?: any;\n    '@context'?: string | string[] | undefined;\n  }", "motivation: string | string[] | undefined", "D", "resource: Presentation2.DescriptiveProperties &\n    Presentation2.RightsProperties &\n    Partial<Presentation2.TechnicalProperties>", "O", "thumb: any", "k", "resource: Presentation2.AbstractResource", "returnPartOf: Presentation3.LinkingProperties['partOf']", "A", "resource: Presentation2.LinkingProperties & Presentation2.RightsProperties", "j", "resource: Presentation2.CharsEmbeddedContent", "M", "object: any", "type: string", "N", "collection: Presentation2.Collection", "additionalProperties: any", "P", "resources: any[]", "F", "I", "manifest: Presentation2.Manifest", "L", "structures: Presentation3.Range[]", "found: string[]", "R", "canvas: Presentation2.Canvas", "z", "annotationPage: Presentation2.AnnotationList", "B", "sequence: Presentation2.Sequence", "V", "annotation: Presentation2.Annotation", "target: typeof annotation.on", "source: string | Presentation3.Reference<'Canvas'> | Presentation3.Reference<'Image'>", "X", "H", "resource: Presentation2.ContentResource | Presentation2.ChoiceEmbeddedContent", "U", "inputContentResource: Presentation2.ContentResource", "choice: Presentation2.ChoiceEmbeddedContent", "G", "range: Presentation2.Range", "service: Presentation2.Service", "newService: any", "layer: Presentation2.Layer", "J", "Y", "entity: any", "selector: Presentation2.ContentResourceSelector", "r", "reference: any", "_typeHint?: T", "i", "n", "e", "a", "o", "s", "c", "l", "u", "d", "object: any", "t", "f", "resource: any", "framing: any", "newEntity: any", "p", "state: CompatibleStore", "urlOrResource: any", "parent?: any", "fullEntity: any", "t: any", "emptyAnnotationPage: AnnotationPageNormalized", "u", "emptyCanvas: CanvasNormalized", "emptyCollection: CollectionNormalized", "emptyManifest: ManifestNormalized", "emptyRange: RangeNormalized", "emptyAgent: ResourceProviderNormalized", "emptyService: _ServiceNormalized", "x", "target: W3CAnnotationTarget | W3CAnnotationTarget[]", "options: {\n    typeMap?: Record<string, string>;\n    typeHint?: string;\n  }", "e", "n", "r", "t", "C", "w", "entityOrString: PolyEntity", "type: string", "e", "t", "T", "entities: Record<string, Record<string, NormalizedEntity>>", "topLevel: any", "defaultStringType?: string", "i", "n", "r: T", "context: TraversalContext", "o", "r", "D", "a", "E", "existing: any", "incoming: any", "context?: { parent?: any; isTopLevel?: boolean }", "added: string[]", "unchanged: string[]", "l", "previouslyChangedValues: any", "incomingChangedValues: any", "c", "u", "s", "d", "f", "newHasPart: any[]", "part: any", "r: any", "existing: NormalizedEntity", "O", "mapping: Record<string, string>", "_service: any", "b", "store: CompatibleStore['entities']", "resource: Service", "id: string", "object: any", "k", "resource: T | string", "A", "defaultResource: R", "resource: T", "j", "maybeArray: T | T[]", "M", "annotation: Annotation", "N", "target: string | Reference<any> | SpecificResource | Partial<Canvas>", "selector: Selector | undefined", "P", "range: Range", "manifest: Manifest", "x", "F", "specificResource: SpecificResource", "I", "L", "unknownEntity: unknown", "Y", "g", "_", "h", "m", "v", "y", "R", "fields: Field[] | [string]", "state: CompatibleStore", "subject: Reference", "config: SerializeConfig", "sub: Reference", "parent?: any", "p", "requestToHydrate: Reference | Reference[]", "next: any", "nextList: any[]", "z", "target: undefined | SpecificResource", "resource: any", "B", "value: InternationalString | null | undefined", "V", "target: any", "H", "oneOrArray: T[] | undefined", "U", "service: any", "technicalProperties", "props: Partial<TechnicalProperties>", "type?: string", "descriptiveProperties", "prop: Partial<DescriptiveNormalized>", "linkingProperties", "prop: Partial<LinkingNormalized>", "isSpecificResource", "resource: unknown", "ce", "le", "resource: Reference<any> | SpecificResource", "serializeConfigPresentation2: SerializeConfig", "entity: any", "q", "entity: Partial<TechnicalProperties>", "J", "item?: T[] | typeof UNSET", "item", "service: ImageService3 | ImageService", "X", "services?: any[]", "Z", "entity: Partial<DescriptiveNormalized>", "Q", "entity: Partial<LinkingNormalized>", "serializeConfigPresentation3: SerializeConfig", "context: any", "$", "resolvedBody: any", "fe", "entries: [string, any][]", "item: any", "t", "e", "n", "r", "i", "a", "root", "inverseIdx", "o", "s", "c", "l", "u", "d", "f", "p", "skip: string[]", "e", "t", "n", "r", "i", "a", "o", "c", "e", "i", "o", "s", "r", "l", "u", "d", "a", "t", "n", "r", "e", "t", "n", "c", "i", "l", "a", "o", "s", "u", "d", "f", "p", "val", "m", "h", "result: Record<string, BoxStyle>", "style: BoxStyle", "result: BoxStyle", "g", "_", "v", "y", "b", "x", "S", "C", "w", "T", "E", "D", "O", "k", "A", "j", "M", "prevCmd: 'M' | 'L' | 'H' | 'V' | 'C' | 'S' | 'Q' | 'T' | 'A' | 'Z' | undefined", "quadX: number | undefined", "quadY: number | undefined", "out: NormalizedSvgPathCommand[]", "arcToCurve", "L", "selector: TemporalSelector", "selector: SupportedSelectors", "I", "selectors: SupportedSelectors[]", "points: [number, number][]", "rect: [number, number, number, number] | undefined", "style: SelectorStyle | undefined", "svgShape: SvgShapeType | undefined", "svgElement: SVGElement | null", "N", "F", "sel: SvgSelector", "P", "shapeType: SvgShapeType", "out: [number, number][]", "style: SelectorStyle", "rootElem: SVGElement | null", "R", "z", "t", "e", "n", "r", "i", "a", "o", "s", "motivation: AnyMotivation[]", "target", "z", "n", "e", "t", "r", "i", "a", "o", "s", "c", "l", "u", "f", "found: Reference<'Canvas'>[]", "virtualRoot: Range", "toc: RangeTableOfContentsNode", "foundCanvas: RangeTableOfContentsNode", "z", "d", "canvases: Array<{ canvas: Canvas; path: string[] }>", "details: IsRangeContiguousDetail", "p", "m", "h", "result: IsRangeContiguousDetail", "_", "g", "n", "t", "e", "i", "r", "a", "o", "s", "c", "l", "u", "d", "f", "p", "m", "h", "g", "ordering: number[][]", "currentOrdering: number[]", "createAction: typeof import('typesafe-actions').createAction", "e", "t", "n", "r", "i", "a", "o", "s", "c", "l", "u", "d", "f", "p", "m", "h", "g", "_", "v", "y", "b", "x", "S", "C", "w", "T", "E", "D", "O", "k", "j", "M", "N", "P", "F", "I", "L", "R", "z", "e", "B", "V", "H", "U", "G", "K", "q", "e", "J", "t", "n", "r", "i", "e", "a", "o", "s", "h", "e", "t", "n", "a", "u", "L", "B", "actions: AllActions[]", "p", "k", "d", "O", "V", "H", "g", "_", "v", "y", "r", "i", "fullEntity: any", "o", "f", "b", "x", "s", "l", "m", "N", "j", "M", "cleanupSubscription: (() => void) | undefined", "z", "q", "e", "A", "e", "t", "n", "r", "i", "j", "M", "N", "P", "F", "a", "o", "s", "c", "l", "u", "d", "f", "p", "m", "L", "I", "R", "z", "B", "E", "D", "V", "H", "newResource: any", "added: string[]", "U", "W", "G", "K", "q", "newFromItems: any[]", "itemsToMove: any[]", "h", "toReturn: Entities", "newEntities: any", "entity: any", "J", "Y", "X", "reducers", "nextState: any", "Z", "Q", "$", "createStore", "dv: typeof devtools", "create", "g", "e", "t", "n", "r", "y", "i", "_", "a", "w", "v", "C", "b", "x", "prototype: WrappedObject<OG> & {\n    id: string;\n    type: string;\n    [REFS]: Record<string, any>;\n    [DEFINED]: any[];\n    [PARENT]: null | string;\n    [REACTIVE]: null | (() => void);\n  }", "parent", "S", "o", "T", "E", "ee", "mitt", "q", "G", "state", "ue", "de", "_type: any", "_type", "s", "c", "p", "f", "fn: any", "fn", "initialState: PaginationState", "newState: PaginationState", "errState: PaginationState", "l", "resource", "u", "successState: PaginationState", "d", "D", "n", "r", "D", "e", "i", "E", "t", "Y", "t", "n", "e", "t", "e", "n", "r", "i", "fetcher: Fetcher<SearchServiceAutocompleteResponse>", "a", "s", "c", "abort: AbortController | null", "autocomplete", "l", "options", "o", "searchService: Search1Service | undefined", "e", "t", "n", "r", "items: T[]", "centuries: DateNavigationCentury[]", "o", "i", "s", "c", "l", "u", "d", "a", "f", "p", "m", "h"]
}
