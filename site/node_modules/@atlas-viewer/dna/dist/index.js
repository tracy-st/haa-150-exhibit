'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const hidePointsOutsideRegion = (points, target, buffer) => {
    const len = points.length;
    const ret = buffer ? buffer : dna(len);
    for (let index = 0; index < len; index++) {
        ret[index] =
            index % 5 === 0
                ? points[index + 1] < target[3] &&
                    points[index + 3] > target[1] &&
                    points[index + 2] < target[4] &&
                    points[index + 4] > target[2]
                    ? 1
                    : 0
                : points[index];
    }
    return ret;
};
function dna(buffer, byteOffset, length) {
    return new Float32Array(buffer, byteOffset, length);
}
const getIntersection = (boxA, boxB, buffer) => {
    const intersects = boxA[1] <= boxB[3] &&
        boxA[3] >= boxB[1] &&
        boxA[2] <= boxB[4] &&
        boxA[4] >= boxB[2];
    const mem = buffer ? buffer : dna(5);
    if (!intersects) {
        mem[0] = 0;
        mem[1] = 0;
        mem[2] = 0;
        mem[3] = 0;
        mem[4] = 0;
        return mem;
    }
    mem[0] = 1;
    mem[1] = Math.max(boxA[1], boxB[1]);
    mem[2] = Math.max(boxA[2], boxB[2]);
    mem[3] = Math.min(boxA[3], boxB[3]);
    mem[4] = Math.min(boxA[4], boxB[4]);
    return mem;
};
const dnaLength = (points) => points.length / 5;
const filterPoints = (points) => points.filter((v, index, arr) => arr[index - (index % 5)]);

const compose = (transformA, transformB, buffer) => {
    const mem = buffer ? buffer : dna(9);
    mem[0] = transformA[0] * transformB[0] + transformA[1] * transformB[3] + transformA[2] * transformB[6];
    mem[1] = transformA[0] * transformB[1] + transformA[1] * transformB[4] + transformA[2] * transformB[7];
    mem[2] = transformA[0] * transformB[2] + transformA[1] * transformB[5] + transformA[2] * transformB[8];
    mem[3] = transformA[3] * transformB[0] + transformA[4] * transformB[3] + transformA[5] * transformB[6];
    mem[4] = transformA[3] * transformB[1] + transformA[4] * transformB[4] + transformA[5] * transformB[7];
    mem[5] = transformA[3] * transformB[2] + transformA[4] * transformB[5] + transformA[5] * transformB[8];
    mem[6] = transformA[6] * transformB[0] + transformA[7] * transformB[3] + transformA[8] * transformB[6];
    mem[7] = transformA[6] * transformB[1] + transformA[7] * transformB[4] + transformA[8] * transformB[7];
    mem[8] = transformA[6] * transformB[2] + transformA[7] * transformB[5] + transformA[8] * transformB[8];
    return mem;
};

class DnaFactory {
    constructor(length) {
        this.index = 0;
        this.length = length;
        this.points = dna(this.length);
    }
    static grid(columns = 1, rows = 1) {
        return new DnaFactory(5 * columns * rows);
    }
    static point(x, y) {
        const point = dna(5);
        point[0] = 1;
        point[1] = x;
        point[2] = y;
        point[3] = x;
        point[4] = y;
        return point;
    }
    static positionPair(positionPair) {
        const pair = dna(5);
        pair[0] = 1;
        pair[1] = positionPair.x1;
        pair[2] = positionPair.y1;
        pair[3] = positionPair.x2;
        pair[4] = positionPair.y2;
        return pair;
    }
    static projection(projection) {
        return DnaFactory.singleBox(projection.width, projection.height, projection.x, projection.y);
    }
    static singleBox(width, height, x = 0, y = 0) {
        const box = dna(5);
        box[0] = 1;
        box[1] = x;
        box[2] = y;
        box[3] = width + x;
        box[4] = height + y;
        return box;
    }
    row(func) {
        return func(this);
    }
    addPoints(x1, y1, x2, y2) {
        this.points[this.index] = 1;
        this.points[1 + this.index] = x1;
        this.points[2 + this.index] = y1;
        this.points[3 + this.index] = x2;
        this.points[4 + this.index] = y2;
        this.index += 5;
        return this;
    }
    addBox(x, y, width, height) {
        this.addPoints(x, y, x + width, y + height);
        return this;
    }
    build() {
        return this.points;
    }
}

const invert = (transformation) => {
    const a00 = transformation[0];
    const a01 = transformation[1];
    const a02 = transformation[2];
    const a10 = transformation[3];
    const a11 = transformation[4];
    const a12 = transformation[5];
    const a20 = transformation[6];
    const a21 = transformation[7];
    const a22 = transformation[8];
    const det01 = a22 * a11 - a12 * a21;
    const det11 = -a22 * a10 + a12 * a20;
    const det21 = a21 * a10 - a11 * a20;
    let det = a00 * det01 + a01 * det11 + a02 * det21;
    det = 1.0 / det;
    const inversion = dna(9);
    inversion[0] = det01 * det;
    inversion[1] = (-a22 * a01 + a02 * a21) * det;
    inversion[2] = (a12 * a01 - a02 * a11) * det;
    inversion[3] = det11 * det;
    inversion[4] = (a22 * a00 - a02 * a20) * det;
    inversion[5] = (-a12 * a00 + a02 * a10) * det;
    inversion[6] = det21 * det;
    inversion[7] = (-a21 * a00 + a01 * a20) * det;
    inversion[8] = (a11 * a00 - a01 * a10) * det;
    return inversion;
};

const mutate = (points, transformation) => {
    const len = points.length;
    for (let index = 0; index < len; index++) {
        points[index] =
            index % 5 === 0
                ? transformation[6] * points[index + 1] + transformation[7] * points[index + 2] + transformation[8] * points[index]
                : (index % 5) % 2 === 1
                    ?
                        transformation[0] * points[index] + transformation[1] * points[index + 1] + transformation[2]
                    :
                        transformation[3] * points[index - 1] + transformation[4] * points[index] + transformation[5];
    }
    return points;
};

const scale = (factor) => {
    const scaleTransform = dna(9);
    scaleTransform[0] = factor;
    scaleTransform[4] = factor;
    scaleTransform[8] = 1;
    return scaleTransform;
};

const translate = (x, y) => {
    const translation = dna(9);
    translation[0] = 1;
    translation[2] = x;
    translation[4] = 1;
    translation[5] = y;
    translation[8] = 1;
    return translation;
};

const scaleAtOrigin = (factor, x, y) => compose(translate((1 - factor) * x, (1 - factor) * y), scale(factor));

const transform = (points, transformation, buffer) => {
    const len = points.length;
    const ret = buffer && buffer.length >= len ? buffer.slice(0, len) : dna(len);
    for (let index = 0; index < len; index++) {
        ret[index] =
            index % 5 === 0
                ? transformation[6] * points[index + 1] +
                    transformation[7] * points[index + 2] +
                    transformation[8] * points[index]
                : (index % 5) % 2 === 1
                    ?
                        transformation[0] * points[index] + transformation[1] * points[index + 1] + transformation[2]
                    :
                        transformation[3] * points[index - 1] + transformation[4] * points[index] + transformation[5];
    }
    return ret;
};

const identity = () => {
    const ident = dna(9);
    ident[0] = 1;
    ident[4] = 1;
    ident[8] = 1;
    return ident;
};

exports.DnaFactory = DnaFactory;
exports.compose = compose;
exports.dna = dna;
exports.dnaLength = dnaLength;
exports.filterPoints = filterPoints;
exports.getIntersection = getIntersection;
exports.hidePointsOutsideRegion = hidePointsOutsideRegion;
exports.identity = identity;
exports.invert = invert;
exports.mutate = mutate;
exports.scale = scale;
exports.scaleAtOrigin = scaleAtOrigin;
exports.transform = transform;
exports.translate = translate;
//# sourceMappingURL=index.js.map
