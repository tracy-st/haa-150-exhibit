import { Strand, Projection as Projection$1 } from '@atlas-viewer/dna';
import { ImageService as ImageService$1, ViewingDirection as ViewingDirection$1 } from '@iiif/presentation-3';
import LRUCache from 'lru-cache';
import * as React from 'react';
import React__default, { ReactNode } from 'react';
import { RectReadOnly } from 'react-use-measure';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { CanvasNormalized, ManifestNormalized } from '@iiif/presentation-3-normalized';

declare const supportedEventAttributes: readonly ["onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp", "onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart", "onPointerDown", "onPointerMove", "onPointerUp", "onPointerCancel", "onPointerEnter", "onPointerLeave", "onPointerOver", "onPointerOut", "onScroll", "onWheel", "onClick", "onDragStart", "onDragEnd", "onDragEnter", "onDragExit", "onDrag", "onDragOver", "onContextMenu"];
declare function createDefaultEventMap(): SupportedEventMap;
declare const supportedEventMap: {
    mousedown: keyof SupportedEvents;
    mouseenter: keyof SupportedEvents;
    mouseleave: keyof SupportedEvents;
    mousemove: keyof SupportedEvents;
    mouseout: keyof SupportedEvents;
    mouseover: keyof SupportedEvents;
    mouseup: keyof SupportedEvents;
    touchcancel: keyof SupportedEvents;
    touchend: keyof SupportedEvents;
    touchmove: keyof SupportedEvents;
    touchstart: keyof SupportedEvents;
    pointerdown: keyof SupportedEvents;
    pointermove: keyof SupportedEvents;
    pointerup: keyof SupportedEvents;
    pointercancel: keyof SupportedEvents;
    pointerenter: keyof SupportedEvents;
    pointerleave: keyof SupportedEvents;
    pointerover: keyof SupportedEvents;
    pointerout: keyof SupportedEvents;
    scroll: keyof SupportedEvents;
    wheel: keyof SupportedEvents;
    click: keyof SupportedEvents;
    dragstart: keyof SupportedEvents;
    dragend: keyof SupportedEvents;
    dragenter: keyof SupportedEvents;
    dragexit: keyof SupportedEvents;
    drag: keyof SupportedEvents;
    dragover: keyof SupportedEvents;
    contextmenu: keyof SupportedEvents;
};
type SupportedEvents = {
    onMouseDown(e: any): void;
    onMouseEnter(e: any): void;
    onMouseLeave(e: any): void;
    onMouseMove(e: any): void;
    onMouseOut(e: any): void;
    onMouseOver(e: any): void;
    onMouseUp(e: any): void;
    onTouchCancel(e: any): void;
    onTouchEnd(e: any): void;
    onTouchMove(e: any): void;
    onTouchStart(e: any): void;
    onPointerDown(e: any): void;
    onPointerMove(e: any): void;
    onPointerUp(e: any): void;
    onPointerCancel(e: any): void;
    onPointerEnter(e: any): void;
    onPointerLeave(e: any): void;
    onPointerOver(e: any): void;
    onPointerOut(e: any): void;
    onScroll(e: any): void;
    onWheel(e: any): void;
    onClick(e: any): void;
    onDragStart(e: any): void;
    onDragEnd(e: any): void;
    onDragEnter(e: any): void;
    onDragExit(e: any): void;
    onDrag(e: any): void;
    onDragOver(e: any): void;
    onContextMenu(e: any): void;
};
type SupportedEventNames = 'mousedown' | 'mouseenter' | 'mouseleave' | 'mousemove' | 'mouseout' | 'mouseover' | 'mouseup' | 'touchcancel' | 'touchend' | 'touchmove' | 'touchstart' | 'pointerdown' | 'pointermove' | 'pointerup' | 'pointercancel' | 'pointerenter' | 'pointerleave' | 'pointerover' | 'pointerout' | 'scroll' | 'wheel' | 'click' | 'dragstart' | 'dragend' | 'dragenter' | 'dragexit' | 'drag' | 'dragover' | 'contextmenu';
type SupportedEventMap = {
    [Name in keyof SupportedEvents]: Array<SupportedEvents[Name]>;
};

type Paintable = SpacialContent;
type Paint = [Paintable, Strand, Strand | undefined];

interface AbstractObject {
    id: string;
    height: number;
    width: number;
    layers: Paintable[];
}

interface AtlasObjectModel<Props, SupportedChildElements> {
    applyProps(props: Props): void;
    appendChild(item: SupportedChildElements): void;
    removeChild(item: SupportedChildElements): void;
    insertBefore(item: SupportedChildElements, before: SupportedChildElements): void;
    hideInstance(): void;
}

interface RenderPipeline {
    getAllPointsAt(target: Strand, aggregate: Strand, scale: number): Paint[];
    transform(op: Strand): void;
}

/**
 * @deprecated
 */
interface AbstractWorldObject extends AbstractObject, RenderPipeline {
    x: number;
    y: number;
    scale: number;
    time: WorldTime[];
    points: Strand;
    worldPoints: Strand;
    atScale(factor: number): void;
    translate(x: number, y: number): void;
    getScheduledUpdates(target: Strand, scaleFactor: number): Array<() => Promise<void>>;
}

declare function fromImage(image: {
    src: string;
    height: number;
    width: number;
    target?: {
        width: number;
        height: number;
    };
}): WorldObject;

interface ZoneInterface {
    id: string;
    config: Required<ZoneConfig>;
    objects: WorldObject[];
    points: Strand;
    recalculateBounds(): void;
    getPointsAt(target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
}
type ZoneConfig = {
    margin?: number;
};
declare class Zone implements ZoneInterface {
    id: string;
    config: Required<ZoneConfig>;
    points: Strand;
    objects: WorldObject[];
    constructor(objects: [WorldObject, ...WorldObject[]], config?: ZoneConfig);
    recalculateBounds(): void;
    getPointsAt(target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
}

/**
 * @deprecated
 */
declare abstract class AbstractContent<Props = any, SupportedLayers = never> extends BaseObject<Props, SupportedLayers> implements SpacialContent {
    abstract readonly id: string;
    readonly type: 'spacial-content';
    abstract points: Strand;
    abstract readonly display: DisplayData;
    getAllPointsAt(target: Strand, aggregate?: Strand, scale?: number): Paint[];
}

type RenderOptions = {
    renderSmallestFallback: boolean;
    renderLayers: number;
    minSize: number;
    maxImageSize: number;
    quality: number;
};
type CompositeResourceProps = RenderOptions;
declare class CompositeResource extends AbstractContent implements SpacialContent, AtlasObjectModel<CompositeResourceProps, SpacialContent> {
    readonly id: string;
    readonly display: DisplayData;
    points: Strand;
    images: SpacialContent[];
    allImages: SpacialContent[];
    scaleFactors: number[];
    aggregateBuffer: Float32Array;
    lazyLoader?: () => Promise<SpacialContent[]>;
    isFullyLoaded: boolean;
    maxScaleFactor: number;
    renderOptions: RenderOptions;
    constructor(data: {
        id: string;
        width: number;
        height: number;
        images: SpacialContent[];
        loadFullImages?: () => Promise<SpacialContent[]>;
        renderOptions?: RenderOptions;
    });
    applyProps(props: CompositeResourceProps): void;
    appendChild(item: SpacialContent): void;
    removeChild(item: SpacialContent): void;
    insertBefore(item: SpacialContent, before: SpacialContent): void;
    hideInstance(): void;
    addImages(images: SpacialContent[]): void;
    sortByScales(): void;
    _scheduleSortByScales: boolean;
    _sortByScales: () => void;
    loadFullResource: () => Promise<void>;
    fallback: (() => Promise<void>)[];
    getScheduledUpdates(target: Strand, scaleFactor: number): Array<() => Promise<void>>;
    getAllPointsAt(target: Strand, aggregate?: Strand, scale?: number): Paint[];
}

declare abstract class BaseObject<Props = any, SupportedChildElements = never> implements AtlasObjectModel<Props, SupportedChildElements> {
    __id: string;
    __revision: number;
    __host: any;
    __onCreate?: () => void;
    __parent?: CompositeResource;
    __owner: {
        value: WorldObject | undefined;
    };
    __state: any;
    eventHandlers: SupportedEventMap;
    scale: number;
    layers: SupportedChildElements[];
    time: WorldTime[];
    _crop?: Strand;
    cropData?: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    get crop(): Strand | undefined;
    set crop(crop: Strand | undefined);
    id: string;
    abstract points: Strand;
    getObjectsAt(target: Strand): SupportedChildElements[] | Array<[SupportedChildElements, any[]]>;
    getAllPointsAt(target: Strand, aggregate: Strand, scale: number): Paint[];
    getScheduledUpdates(target: Strand, scaleFactor: number): Array<() => void | Promise<void>>;
    protected constructor();
    addEventListener: <Name extends SupportedEventNames>(name: Name, cb: (e: any) => void, options?: {
        capture: boolean;
        passive: boolean;
    }) => void;
    removeEventListener: <Name extends SupportedEventNames>(name: Name, cb: (e: any) => void) => void;
    dispatchEvent<Name extends keyof SupportedEvents>(name: Name, e: any): boolean;
    get x(): number;
    get y(): number;
    get width(): number;
    get height(): number;
    translate(x: number, y: number): void;
    atScale(factor: number): void;
    transform(op: Strand): void;
    applyProps(props: Props): void;
    appendChild(item: SupportedChildElements): void;
    removeChild(item: SupportedChildElements): void;
    insertBefore(item: SupportedChildElements, before: SupportedChildElements): void;
    hideInstance(): void;
}

type WorldObjectProps = {
    id: string;
    width: number;
    height: number;
    scale?: number;
    x?: number;
    y?: number;
    rotation?: number;
};
declare class WorldObject extends BaseObject<WorldObjectProps, Paintable> {
    id: string;
    type: string;
    scale: number;
    layers: Paintable[];
    /**
     * This position in the world local to the scale of the object.
     * So a 1000x1000 drawn at 0.1 scale at x=5, y=10 on the world would have world points 50,100,1000,1000
     *
     * To get it's world-relative position you need to multiple the scale out.
     */
    points: Strand;
    /**
     * These are relative to where to object is in the world at the scale of the world.
     * So a 1000x1000 drawn at 0.1 scale at x=5, y=10 on the world would have world points 0,0,100,100
     */
    worldPoints: Strand;
    intersectionBuffer: Float32Array;
    aggregateBuffer: Float32Array;
    invertedBuffer: Float32Array;
    rotation: number;
    filteredPointsBuffer: Strand;
    _updatedList: any[];
    geometry?: any;
    constructor(props?: AbstractObject, position?: {
        x: number;
        y: number;
    });
    static createWithProps(props: WorldObjectProps): WorldObject;
    applyProps(props: WorldObjectProps): void;
    appendChild(item: Paintable): void;
    removeChild(item: Paintable): void;
    insertBefore(item: Paintable, before: Paintable): void;
    hideInstance(): void;
    getObjectsAt(target: Strand, all?: boolean): Paintable[];
    applyRotation(target: Strand): Float32Array;
    getAllPointsAt(target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
    addLayers(paintables: Paintable[]): void;
    getScheduledUpdates(target: Strand, scaleFactor: number): Array<() => void | Promise<void>>;
}

type WorldTarget = {
    x: number;
    y: number;
    width?: number;
    height?: number;
};
type WorldProps = {
    width: number;
    height: number;
    viewingDirection: ViewingDirection;
};
declare class World extends BaseObject<WorldProps, WorldObject> {
    id: string;
    _width: number;
    _height: number;
    aspectRatio: number;
    viewingDirection: ViewingDirection;
    aggregateBuffer: Float32Array;
    isDirty: boolean;
    zones: ZoneInterface[];
    filteredPointsBuffer: Strand;
    selectedZone?: number;
    triggerQueue: Array<[string, any]>;
    activatedEvents: string[];
    _updatedList: any[];
    translationBuffer: Float32Array;
    needsRecalculate: boolean;
    emptyPaintables: never[];
    renderOrder: number[];
    get x(): number;
    get y(): number;
    get width(): number;
    get height(): number;
    points: Strand;
    private objects;
    subscriptions: Array<(type: string, changes?: unknown) => void>;
    constructor(width?: number, height?: number, worldObjectCount?: number, viewingDirection?: ViewingDirection);
    static withProps(props: WorldProps): World;
    applyProps(props: WorldProps): void;
    propagateTouchEvent(eventName: string, e: TouchEvent, touchTargets: Array<{
        x: number;
        y: number;
    }>): any[][];
    propagatePointerEvent<Name extends keyof SupportedEvents>(eventName: Name, e: any, x: number, y: number, opts?: {
        bubbles?: boolean;
        cancelable?: boolean;
    }): any[];
    _propagateEventTargets: any[];
    propagateEvent(eventName: string, e: any, worldObjects: [WorldObject, SpacialContent[]][], { bubbles, cancelable }?: {
        bubbles?: boolean;
        cancelable?: boolean;
    }): any[];
    appendChild(item: WorldObject): void;
    removeChild(item: WorldObject): void;
    insertBefore(item: WorldObject, before: WorldObject): void;
    hideInstance(): void;
    asWorldObject(): WorldObject | null;
    addZone(zone: ZoneInterface): void;
    selectZone(id: string | number): void;
    deselectZone(): void;
    getActiveZone(): ZoneInterface | undefined;
    hasActiveZone(): boolean;
    private checkResizeInternalBuffer;
    appendWorldObject(object: WorldObject): number;
    recalculateWorldSize(): boolean;
    /**
     * @deprecated
     */
    addObjectAt(object: AbstractObject, target: WorldTarget): WorldObject;
    scaleWorldObject(index: number, factor: number): void;
    translateWorldObject(index: number, x: number, y: number): void;
    resize(width: number, height: number): this;
    getObjects(): (WorldObject | null)[];
    getPoints(): Float32Array;
    getPointsFromViewer(target: Viewer, aggregate?: Strand): Paint[];
    addLayoutSubscriber(subscription: (type: string, data: unknown) => void): () => void;
    getScheduledUpdates(target: Strand, scaleFactor: number): Array<() => void | Promise<void>>;
    getObjectsAt(target: Strand, all?: boolean): Array<[WorldObject, Paintable[]]>;
    getPointsAt(target: Strand, aggregate?: Strand, scaleFactor?: number): Paint[];
    _alreadyFlushed: any;
    flushSubscriptions(): void;
    trigger<T>(type: string, data?: T): void;
    triggerEventActivation(): void;
    triggerRepaint(): void;
    gotoRegion(data: {
        x: number;
        y: number;
        height: number;
        width: number;
        padding?: number;
        nudge?: boolean;
        immediate?: boolean;
    }): void;
    goHome(immediate?: boolean): void;
    zoomTo(factor: number, point?: {
        x: number;
        y: number;
    }, stream?: boolean): void;
    zoomIn(point?: {
        x: number;
        y: number;
    }): void;
    zoomOut(point?: {
        x: number;
        y: number;
    }): void;
    constraintBounds(immediate?: boolean): void;
}

interface Renderer {
    beforeFrame(world: World, delta: number, target: Strand, options: HookOptions): void;
    paint(paint: SpacialContent, index: number, x: number, y: number, width: number, height: number): void;
    afterFrame(world: World, delta: number, target: Strand, options: HookOptions): void;
    getScale(width: number, height: number, dpi?: boolean): number;
    prepareLayer(paint: SpacialContent, point: Strand): void;
    finishLayer(paint: SpacialContent, point: Strand): void;
    afterPaintLayer(paint: SpacialContent, transform?: Strand): void;
    pendingUpdate(): boolean;
    getPointsAt(world: World, target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
    getViewportBounds(world: World, target: Strand, padding: number): PositionPair | null;
    isReady(): boolean;
    resize(): void;
    resize(width?: number, height?: number): void;
    triggerResize?: () => void;
    reset(): void;
    getRendererScreenPosition(): {
        x: number;
        y: number;
        width: number;
        height: number;
        top: number;
        left: number;
    } | undefined;
}

type EasingFunction = (progress: number) => number;
declare const bounceOut: EasingFunction;
type EasingFunctionNames = 'linear' | 'easeInQuad' | 'easeOutQuad' | 'easeInOutQuad' | 'easeInCubic' | 'easeOutCubic' | 'easeInOutCubic' | 'easeInQuart' | 'easeOutQuart' | 'easeInOutQuart' | 'easeInQuint' | 'easeOutQuint' | 'easeInOutQuint' | 'easeInSine' | 'easeOutSine' | 'easeInOutSine' | 'easeInExpo' | 'easeOutExpo' | 'easeInOutExpo' | 'easeInCirc' | 'easeOutCirc' | 'easeInOutCirc' | 'easeInBack' | 'easeOutBack' | 'easeInOutBack' | 'easeInElastic' | 'easeOutElastic' | 'easeInOutElastic' | 'easeInBounce' | 'easeOutBounce' | 'easeInOutBounce';
declare const easingFunctions: {
    [key in EasingFunctionNames]: EasingFunction;
};

type PendingTransition = {
    from: Strand;
    to: Strand;
    elapsed_time: number;
    total_time: number;
    timingFunction: EasingFunction;
    done: boolean;
    constrain: boolean;
    callback?: () => void;
};
declare class TransitionManager {
    runtime: Runtime;
    readonly pendingTransition: PendingTransition;
    constructor(runtime: Runtime);
    hasPending(): boolean;
    getPendingTransition(): PendingTransition;
    getPendingFrom(): Float32Array;
    customTransition(func: (transition: PendingTransition) => void): void;
    stopTransition(): void;
    runTransition(target: Strand, delta: number): void;
    lastZoomTo: {
        factor: number;
        options: any;
    } | null;
    resumeTransition(): void;
    zoomTo(factor: number, options?: {
        origin?: Position;
        stream?: boolean;
        minZoomFactor?: number;
        transition?: {
            duration?: number;
            easing?: EasingFunction;
        };
    }): void;
    isConstraining: boolean;
    constrainBounds({ transition, panPadding, }?: {
        panPadding?: number;
        transition?: {
            duration?: number;
            easing?: EasingFunction;
        };
    }): void;
    applyTransition(target: Strand, transition?: {
        duration?: number;
        easing?: EasingFunction;
        constrain?: boolean;
    }, defaults?: {
        duration: number;
        easing: EasingFunction;
        constrain?: boolean;
        callback?: () => void;
    }, { stream, }?: {
        stream?: boolean;
    }): void;
    lastGoToRegion: null | {
        target: any;
        options: any;
    };
    goToRegion(target: {
        x: number;
        y: number;
        width: number;
        height: number;
        padding?: number;
    }, { transition, }?: {
        transition?: {
            duration?: number;
            easing?: EasingFunction;
        };
    }): void;
}

type RuntimeHooks = {
    useFrame: Array<(time: number) => void>;
    useBeforeFrame: Array<(time: number) => void>;
    useAfterFrame: Array<(time: number) => void>;
    useAfterPaint: Array<(paint: Paint) => void>;
};
type UnwrapHook<T> = T extends Array<infer R> ? R : never;
type UnwrapHookArg<T> = T extends Array<(arg: infer R) => any> ? R : never;
type ViewerMode = 'static' | 'explore' | 'sketch';
type ViewerFilters = {
    grayscale: number;
    contrast: number;
    brightness: number;
    saturate: number;
    hueRotate: number;
    sepia: number;
    invert: number;
    blur: number;
};
type HookOptions = {
    enableFilters?: boolean;
    filters: ViewerFilters;
};
type RuntimeOptions = {
    visibilityRatio: number;
    maxOverZoom: number;
    maxUnderZoom: number;
};
declare class Runtime {
    id: string;
    ready: boolean;
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
    get x2(): number;
    set x2(x2: number);
    get y2(): number;
    set y2(y2: number);
    get width(): number;
    set width(width: number);
    get height(): number;
    set height(height: number);
    renderer: Renderer;
    world: World;
    target: Strand;
    homePosition: Strand;
    manualHomePosition: boolean;
    manualFocalPosition: boolean;
    focalPosition: Strand;
    transitionManager: TransitionManager;
    aggregate: Strand;
    transformBuffer: Float32Array;
    lastTarget: Float32Array;
    zoomBuffer: Float32Array;
    logNextRender: boolean;
    pendingUpdate: boolean;
    isCommitting: boolean;
    firstRender: boolean;
    lastTime: number;
    stopId?: number;
    mode: ViewerMode;
    controllers: RuntimeController[];
    controllersRunning: boolean;
    controllerStopFunctions: Array<() => void>;
    maxScaleFactor: number;
    _viewerToWorld: {
        x: number;
        y: number;
    };
    _lastGoodScale: number;
    hooks: RuntimeHooks;
    fpsLimit: number | undefined;
    options: RuntimeOptions;
    hookOptions: HookOptions;
    constructor(renderer: Renderer, world: World, target: Viewer, controllers?: RuntimeController[], options?: Partial<RuntimeOptions>);
    setHomePosition(position?: Projection): void;
    startControllers(): void;
    stopControllers(): void;
    updateControllerPosition(): void;
    triggerResize(): void;
    addController(controller: RuntimeController): void;
    cover(): void;
    getRendererScreenPosition(): {
        x: number;
        y: number;
        width: number;
        height: number;
        top: number;
        left: number;
    } | undefined;
    updateRendererScreenPosition(): void;
    setOptions(options: Partial<RuntimeOptions>): void;
    goHome(options?: {
        cover?: boolean;
        position?: Strand;
    }): void;
    /**
     * Resize world
     *
     * This is generally called when the world is re-sized. This recalculates the current target accordingly. It needs to
     * be improved, tested and planned.
     *
     * @param fromWidth
     * @param toWidth
     * @param fromHeight
     * @param toHeight
     */
    resize(fromWidth: number, toWidth: number, fromHeight: number, toHeight: number): void;
    updateFocalPosition(widthDiff?: number, heightDiff?: number): void;
    _viewport: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    /**
     * Get Viewport
     *
     * Returns a projection based on the current target.
     *
     * @todo rename to getProjection.
     * @todo evaluate if we actually need this.
     */
    getViewport(): Projection;
    /**
     * Set Viewport
     *
     * This is a helper for setting the viewport based on x, y, width and height, opposed to the x1, y1, x2, y2 native
     * co-ordinates of the target.
     *
     * @param data
     */
    setViewport: (data: {
        x?: number;
        y?: number;
        width?: number;
        height?: number;
    }) => void;
    constrainBounds(target: Strand, { panPadding, ref }?: {
        ref?: boolean;
        panPadding?: number;
    }): readonly [boolean, Float32Array];
    /**
     * Get bounds
     *
     * Returns the minimum and maximum bounds. This absolutely needs improved. With the addition of zones this is becoming
     * more of an issue. It has to take into account the current layout. There also needs to be a new method for creating
     * a "home" view  that will fit the content to the view.
     */
    getBounds(options: {
        padding: number;
        target?: Strand;
    }): {
        readonly minX: number;
        readonly maxX: number;
        readonly minY: number;
        readonly maxY: number;
    };
    getScaleFactor(dpi?: boolean): number;
    /**
     * Zoom
     */
    getZoomedPosition(factor: number, { origin, fromPos: _fromPos, }: {
        origin?: {
            x: number;
            y: number;
        };
        fromPos?: Strand;
    }): Float32Array;
    clampRegion({ x, y, width, height, padding, }: {
        x: number;
        y: number;
        width: number;
        height: number;
        padding?: number;
    }): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    /**
     * Converts units from the viewer to the world.
     *
     * Needs to be tested, as this will become more important with the event system.
     *
     * @param x
     * @param y
     */
    viewerToWorld(x: number, y: number): {
        x: number;
        y: number;
    };
    /**
     * Converts units from the viewer to the world.
     *
     * Needs to be tested, as this will become more important with the event system.
     *
     * @param x
     * @param y
     * @param width
     * @param height
     */
    worldToViewer(x: number, y: number, width: number, height: number): {
        x: number;
        y: number;
        width: number;
        height: number;
        strand: Float32Array;
    };
    /**
     * Set scale
     *
     * This will set the scale of the target, with an optional origin.
     *
     * @param scaleFactor
     * @param origin
     */
    setScale(scaleFactor: number, origin?: {
        x: number;
        y: number;
    }): void;
    /**
     * Sync runtime instances
     *
     * Allows a single controller to drive 2 runtime instances, or 2 controllers to both
     * control each other.
     *
     * @param runtime
     */
    syncTo(runtime: Runtime): () => void;
    /**
     * Stop the runtime
     *
     * Stops the internal clock, where no more updates will occur. Returns a function to restart it.
     */
    stop(): () => void;
    reset(): void;
    selectZone(zone: number | string): void;
    deselectZone(): void;
    hook<Name extends keyof RuntimeHooks, Arg = UnwrapHookArg<Name>>(name: keyof RuntimeHooks, arg: Arg): void;
    registerHook<Name extends keyof RuntimeHooks, Hook = UnwrapHook<Name>>(name: Name, hook: Hook): () => void;
    /**
     * Render
     *
     * The hottest path in the runtime, called every 16.7ms, if possible in the future be double-timed on 120hz monitors.
     *
     * @   param t
     */
    render: (t: number) => void;
    updateNextFrame(): void;
}

type RuntimeController = {
    start(runtime: Runtime): () => void;
    updatePosition(x: number, y: number, width: number, height: number): void;
};
interface Position {
    x: number;
    y: number;
}
interface PositionPair {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
}
interface SpacialSize {
    width: number;
    height: number;
}
interface Scaled {
    scale: number;
}
interface Projection extends Position, SpacialSize {
}
interface Viewer extends Projection, Scaled {
}
interface DisplayData extends SpacialSize, Position, Scaled {
    points: Strand;
    rotation?: number;
}
interface WorldTime {
    start: number;
    end: number;
}
type ViewingDirection = 'left-to-right' | 'right-to-left' | 'top-to-bottom' | 'bottom-to-top';
/** @internal */
type PointerEvents = {
    onClick(e: any): void;
    onWheel(e: any): void;
    onPointerDown(e: any): void;
    onPointerUp(e: any): void;
    onMouseLeave(e: any): void;
    onMouseMove(e: any): void;
    onTouchCancel(e: any): void;
    onTouchEnd(e: any): void;
    onTouchMove(e: any): void;
    onTouchStart(e: any): void;
};
interface TextWrapperOptions {
    /**
     *  Text style that includes font size (in px), font weight, font family, etc.
     */
    font?: string;
    /**
     * Number - 'n' times font size where 1 is equivalent to '100%'. Also the property can be set in '%' or 'px'.
     */
    lineHeight?: string | number;
    /**
     * Horizontal alignment of each line.
     */
    textAlign?: 'left' | 'center' | 'right';
    /**
     * Vertical alignment of the whole text block.
     */
    verticalAlign?: 'top' | 'middle' | 'bottom';
    /**
     * Horizontal padding (in px) that is equally set on left and right sides.
     */
    paddingX?: number;
    /**
     * Vertical padding (in px) that is equally set on top and bottoms.
     */
    paddingY?: number;
    /**
     * Fit canvas' container size instead of its own size.
     */
    fitParent?: boolean;
    /**
     * "auto" - text goes to the next line on a whole word when there's no room
     * "word" - each next word is placed on a new line
     */
    lineBreak?: 'auto' | 'word';
    /**
     * Ignore given font size and line height and resize text to fill its padded container.
     */
    sizeToFill?: boolean;
    /**
     * If above option is true text won't be bigger than set.
     */
    maxFontSizeToFill?: number;
    /**
     * Allow text outline based on canvas context configuration.
     */
    strokeText?: boolean;
    /**
     * All lines will try to match the same width with flexed spaces between the words.
     */
    justifyLines?: boolean;
    /**
     * Text breaks on a new line character "\n". Supports multiple consecutive new lines.
     */
    allowNewLine?: boolean;
    /**
     * Text is rendered based on device pixel ratio.
     */
    renderHDPI?: boolean;
    /**
     * Text is underlined according to context.strokeStyle and context.lineWidth
     */
    textDecoration?: 'none' | 'underline';
}

type UpdateTextureFunction = () => {
    source: TexImageSource | undefined;
    hash: any;
};
type ImageTextureProps = {
    id: string;
    display?: {
        width: number;
        height: number;
    };
    target: {
        width: number;
        height: number;
    };
    scale?: number;
    getTexture: UpdateTextureFunction;
};
declare class ImageTexture extends BaseObject implements SpacialContent {
    readonly type = "spacial-content";
    id: string;
    uri: string;
    display: DisplayData;
    points: Strand;
    getTexture: UpdateTextureFunction;
    constructor(data?: {
        id?: string;
        uri: string;
        width: number;
        height: number;
        scale?: number;
    });
    applyProps(props: ImageTextureProps): void;
    getAllPointsAt(target: Strand, aggregate?: Strand, scale?: number): Paint[];
}

interface SpacialContent {
    readonly id: string;
    readonly type: 'spacial-content';
    readonly display: DisplayData;
    __id?: string;
    __parent?: CompositeResource;
    __owner: {
        value: WorldObject | undefined;
    };
    __host?: any;
    priority?: boolean;
    points: Strand;
    crop?: Strand;
    cropData?: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    style?: {
        opacity: number;
    };
    getScheduledUpdates(target: Strand, scaleFactor: number): Array<() => void | Promise<void>>;
    getAllPointsAt(target: Strand, aggregate?: Strand, scale?: number): Paint[];
    transform(op: Strand): void;
    loadFullResource?(): Promise<void>;
    dispatchEvent(event: string, e: any): void;
    getImageUrl?: (index: number) => string;
    getTexture?: UpdateTextureFunction;
}

type SingleImageProps = {
    uri: string;
    id?: string;
    display?: {
        width: number;
        height: number;
        rotation?: number;
    };
    target: {
        width: number;
        height: number;
        x?: number;
        y?: number;
    };
    crop?: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    scale?: number;
    priority?: boolean;
    style?: any;
};
declare class SingleImage extends BaseObject implements SpacialContent {
    readonly type = "spacial-content";
    /**
     * An identifier for this image. Will default to the image URI.
     */
    id: string;
    /**
     * The URI of the image being painted.
     */
    uri: string;
    /**
     * The real height and width of the image. For example a 1000x1000 painted at 100x100 would contain
     * the display data for 1000x1000 and `this.points` would scale that down to 100x100. This is used to
     * calculate the scale.
     */
    display: DisplayData;
    /**
     * Points are relative to the world object.
     * Does not change when viewport moves
     * Does not change if world object position changes.
     * */
    points: Strand;
    /**
     * Displayed as priority
     */
    priority?: boolean;
    /**
     * Some simple styling options
     */
    style: {
        opacity: number;
    };
    constructor(data?: {
        id?: string;
        uri: string;
        width: number;
        height: number;
        scale?: number;
        x?: number;
        y?: number;
        rotation?: number;
    });
    applyProps(props: SingleImageProps): void;
    getAllPointsAt(target: Strand, aggregate?: Strand, scale?: number): Paint[];
    static fromSvg(svg: string, target: SpacialSize, display?: SpacialSize, id?: string): SingleImage;
    static fromImage(uri: string, target: SpacialSize, display?: SpacialSize, id?: string): SingleImage;
    getImageUrl(): string;
}

declare class TiledImage extends BaseObject implements SpacialContent {
    readonly id: string;
    readonly type = "spacial-content";
    readonly display: DisplayData;
    tileWidth: number;
    style: {
        opacity: number;
    };
    points: Strand;
    service?: ImageService$1;
    format: string;
    crop2?: Strand;
    version3?: boolean;
    tileUrl: string;
    constructor(data: {
        url: string;
        scaleFactor: number;
        points: Strand;
        displayPoints?: Strand;
        tileWidth: number;
        width: number;
        height: number;
        format?: string;
        id?: string;
        version3?: boolean;
    });
    applyProps(props: any): void;
    static fromTile(url: string, canvas: {
        width: number;
        height: number;
    }, tile: {
        width: number;
        height?: number;
    }, scaleFactor: number, service?: ImageService$1, format?: string, useFloorCalc?: boolean, version3?: boolean): TiledImage;
    getImageUrl(index: number): string;
    getAllPointsAt(target: Strand, aggregate?: Strand, scaleFactor?: number): Paint[];
    transform(op: Strand): void;
    getScheduledUpdates(target: Strand, scaleFactor: number): Array<() => Promise<void>>;
}

type BoxProps = {
    id: string;
    target: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    className?: string;
    href?: string;
    title?: string;
    hrefTarget?: string;
    interactive?: boolean;
    relativeSize?: boolean;
    relativeStyle?: boolean;
    html?: boolean;
    style?: BoxStyle;
    backgroundColor?: string;
    border?: string;
};
type BoxStyle = _BoxStyle & {
    ':hover'?: _BoxStyle;
    ':active'?: _BoxStyle;
};
type _BoxStyle = Partial<{
    backgroundColor: string;
    opacity: number;
    boxShadow: string;
    borderColor: string;
    borderWidth: string;
    borderStyle: string;
    outlineColor: string;
    outlineWidth: string;
    outlineOffset: string;
    outlineStyle: string;
    border: string;
    outline: string;
    background: string;
}>;
declare class Box extends BaseObject<BoxProps> implements SpacialContent {
    id: string;
    type: 'spacial-content';
    points: Strand;
    hoverEvents: boolean;
    activeEvents: boolean;
    display: {
        x: number;
        y: number;
        scale: number;
        width: number;
        height: number;
        points: Float32Array;
    };
    _parsed: {
        border: {
            id: string | null;
            match: string[];
        };
        outline: {
            id: string | null;
            match: string[];
        };
    };
    hovering?: boolean;
    pressing?: boolean;
    props: {
        href?: string;
        hrefTarget?: string;
        title?: string;
        backgroundColor?: string;
        border?: string;
        interactive?: boolean;
        className?: string;
        relativeSize?: boolean;
        relativeStyle?: boolean;
        html?: boolean;
        style?: BoxStyle;
        hoverStyles?: BoxStyle;
        pressStyles?: BoxStyle;
    };
    constructor();
    getAllPointsAt(target: Strand, aggregate: Strand): Paint[];
    addHover: () => void;
    removeHover: () => void;
    addPress: () => void;
    removePress: () => void;
    applyProps(props?: Partial<BoxProps>): void;
}

type TextProps = TextWrapperOptions & {
    id: string;
    text: string;
    target: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    color: string;
    backgroundColor: string;
    fontSize: number;
    fontFamily: string;
    interactive?: boolean;
};
declare class Text extends BaseObject<TextProps> implements SpacialContent {
    type: 'spacial-content';
    id: string;
    points: Strand;
    color: string;
    backgroundColor?: string;
    hovering?: boolean;
    pressing?: boolean;
    text: string;
    display: {
        x: number;
        y: number;
        scale: number;
        width: number;
        height: number;
        points: Float32Array;
    };
    className?: string;
    html?: boolean;
    interactive: boolean;
    props: TextWrapperOptions & {
        title?: string;
        href?: string;
        hrefTarget?: string;
        interactive?: boolean;
        relativeSize?: boolean;
        relativeStyle?: boolean;
        className?: string;
        html?: boolean;
    };
    constructor();
    getAllPointsAt(target: Strand, aggregate: Strand): Paint[];
    applyProps({ id, target, text, color, backgroundColor, fontSize, interactive, fontFamily, ...props }: Partial<TextProps>): void;
}

type GeometryProps = {
    id: string;
    target: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    open?: boolean;
    points: [number, number][];
    className?: string;
    href?: string;
    title?: string;
    hrefTarget?: string;
    interactive?: boolean;
    relativeSize?: boolean;
    relativeStyle?: boolean;
    html?: boolean;
    style?: GeometryStyle;
    backgroundColor?: string;
    border?: string;
};
type GeometryStyle = _GeometryStyle & {
    ':hover'?: _GeometryStyle;
    ':active'?: _GeometryStyle;
};
type _GeometryStyle = Partial<{
    backgroundColor: string;
    opacity: number;
    boxShadow: string;
    borderColor: string;
    borderWidth: string;
    borderStyle: string;
    outlineColor: string;
    outlineWidth: string;
    outlineOffset: string;
    outlineStyle: string;
    border: string;
    outline: string;
    background: string;
}>;
declare class Geometry extends BaseObject<GeometryProps> implements SpacialContent {
    id: string;
    type: 'spacial-content';
    isShape: boolean;
    points: Strand;
    hoverEvents: boolean;
    activeEvents: boolean;
    display: {
        x: number;
        y: number;
        scale: number;
        width: number;
        height: number;
        points: Float32Array;
    };
    boundingBox: {
        x: number;
        y: number;
        width: number;
        height: number;
    } | null;
    _parsed: {
        border: {
            id: string | null;
            match: string[];
        };
        outline: {
            id: string | null;
            match: string[];
        };
    };
    hovering?: boolean;
    pressing?: boolean;
    props: {
        href?: string;
        hrefTarget?: string;
        title?: string;
        backgroundColor?: string;
        border?: string;
        interactive?: boolean;
        open?: boolean;
        className?: string;
        relativeSize?: boolean;
        relativeStyle?: boolean;
        html?: boolean;
        style?: GeometryStyle;
        hoverStyles?: GeometryStyle;
        pressStyles?: GeometryStyle;
    };
    shape: {
        type: 'none';
    } | {
        type: 'polygon';
        points: [number, number][];
        open?: boolean;
    };
    constructor();
    updateBoundingBox(): void;
    intersects(pointer?: [number, number] | null): boolean;
    getAllPointsAt(target: Strand, aggregate: Strand): Paint[];
    addHover: () => void;
    removeHover: () => void;
    addPress: () => void;
    removePress: () => void;
    applyProps(props?: Partial<GeometryProps>): void;
}

declare class CompositeRenderer implements Renderer {
    renderers: Renderer[];
    length: number;
    constructor(renderers: Array<Renderer | undefined>);
    afterFrame(world: World, delta: number, target: Strand, options: HookOptions): void;
    afterPaintLayer(paint: SpacialContent, transform?: Strand): void;
    beforeFrame(world: World, delta: number, target: Strand, options: HookOptions): void;
    triggerResize(): void;
    getPointsAt(world: World, target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
    getScale(width: number, height: number): number;
    getViewportBounds(world: World, target: Strand, padding: number): PositionPair | null;
    getRendererScreenPosition(): {
        x: number;
        y: number;
        width: number;
        height: number;
        top: number;
        left: number;
    } | undefined;
    isReady(): boolean;
    paint(paint: SpacialContent, index: number, x: number, y: number, width: number, height: number): void;
    pendingUpdate(): boolean;
    prepareLayer(paint: SpacialContent, point: Strand): void;
    finishLayer(paint: SpacialContent, point: Strand): void;
    resize(width?: number, height?: number): void;
    reset(): void;
}

declare class GridBuilder {
    autoWidth: boolean;
    autoHeight: boolean;
    width: number;
    height: number;
    world: World;
    content: WorldObject[];
    viewingDirection: ViewingDirection$1;
    rows?: number;
    columns?: number;
    spacing: number;
    reversed: boolean;
    padding: number;
    constructor();
    setViewingDirection(viewingDirection: ViewingDirection$1): void;
    addContent(content: AbstractObject[]): void;
    setWidth(width: number): void;
    setHeight(height: number): void;
    setSpacing(spacing: number): void;
    setPadding(padding: number): void;
    setRows(rows?: number): void;
    setColumns(columns?: number): void;
    recalculate(): void;
    getWorld(): World;
}

type PopmotionControllerConfig = {
    zoomOutFactor?: number;
    zoomInFactor?: number;
    maxZoomFactor?: number;
    minZoomFactor?: number;
    zoomDuration?: number;
    zoomClamp?: number;
    zoomWheelConstant?: number;
    panBounceStiffness?: number;
    panBounceDamping?: number;
    panTimeConstant?: number;
    panPower?: number;
    nudgeDistance?: number;
    panPadding?: number;
    devicePixelRatio?: number;
    enableWheel?: boolean;
    enableClickToZoom?: boolean;
    ignoreSingleFingerTouch?: boolean;
    enablePanOnWait?: boolean;
    requireMetaKeyForWheelZoom?: boolean;
    panOnWaitDelay?: number;
    parentElement?: HTMLElement | null;
    onPanInSketchMode?: () => void;
};
declare const defaultConfig: Required<PopmotionControllerConfig>;
declare const popmotionController: (config?: PopmotionControllerConfig) => RuntimeController;

type GetTile = {
    id: string;
    width: number;
    height: number;
    thumbnail?: {
        id: string;
        width: number;
        height: number;
    };
    imageService: ImageService$1;
};
declare function getId(entity: any): string;

type BrowserEventManagerOptions = {
    /** Default 50ms **/
    simulationRate: number;
};
declare class BrowserEventManager {
    element: HTMLElement;
    runtime: Runtime;
    unsubscribe: () => any;
    activatedEvents: string[];
    eventHandlers: [string, any][];
    bounds: DOMRect;
    listening: boolean;
    static eventPool: {
        atlas: {
            x: number;
            y: number;
        };
    };
    pointerMoveEvent: PointerEvent | undefined;
    pointerEventState: {
        isClicking: boolean;
        isPressed: boolean;
        isDragging: boolean;
        mousedOver: BaseObject[];
        itemsBeingDragged: BaseObject[];
        mouseDownStart: {
            x: number;
            y: number;
        };
        lastTouches: Array<{
            id: number;
            x: number;
            y: number;
        }>;
    };
    options: BrowserEventManagerOptions;
    constructor(element: HTMLElement, runtime: Runtime, options?: Partial<BrowserEventManagerOptions>);
    updateBounds(): void;
    layoutSubscriber(type: string): void;
    assignToEvent(e: any, x: number, y: number): void;
    activateEvents(): void;
    _realPointerMove: (e: PointerEvent) => void;
    onWheelEvent: (e: WheelEvent) => void;
    onContextMenu: (e: MouseEvent) => void;
    onTouchEvent: (e: TouchEvent) => void;
    onPointerEvent: (e: PointerEvent | MouseEvent) => void;
    onPointerDown: (e: PointerEvent | MouseEvent) => void;
    onPointerUp: (e: PointerEvent | MouseEvent) => void;
    onPointerMove: (e: PointerEvent | MouseEvent) => void;
    normalizeEventName(event: string): string;
    stop(): void;
}

type CanvasRendererOptions = {
    beforeFrame?: (delta: number) => void;
    debug?: boolean;
    htmlContainer?: HTMLDivElement;
    crossOrigin?: boolean;
    dpi?: number;
    box?: boolean;
    polygon?: boolean;
    lruCache?: boolean;
};
type ImageBuffer = {
    canvas: HTMLCanvasElement;
    canvases: string[];
    indices: number[];
    loaded: number[];
    fallback?: ImageBuffer;
    loading: boolean;
};
declare class CanvasRenderer implements Renderer {
    /**
     * The primary viewing space for the viewer.
     */
    canvas: HTMLCanvasElement;
    /**
     * Canvas context for `this.canvas`
     */
    ctx: CanvasRenderingContext2D;
    /**
     * Rendering options added in the constructor.
     */
    options: CanvasRendererOptions;
    /**
     * Number of images loading.
     */
    imagesPending: number;
    /**
     * Number of completed images, used to calculate pending images.
     */
    imagesLoaded: number;
    /**
     * The ids of the completed images, use to dedupe
     */
    imageIdsLoaded: string[];
    /**
     * Can be used to avoid or stop work when frame is or isn't rendering outside of the main loop.
     */
    frameIsRendering: boolean;
    pendingDrawCall: boolean;
    firstMeaningfulPaint: boolean;
    parallelTasks: number;
    frameTasks: number;
    loadingQueueOrdered: boolean;
    loadingQueue: Array<{
        id: string;
        scale: number;
        network?: boolean;
        distance: number;
        shifted?: boolean;
        task: () => Promise<any>;
    }>;
    currentTask: Promise<any>;
    tasksRunning: number;
    stats?: any;
    averageJobTime: number;
    lastKnownScale: number;
    visible: Array<SpacialContent>;
    previousVisible: Array<SpacialContent>;
    rendererPosition: DOMRect;
    dpi: number;
    drawCalls: Array<() => void>;
    lastPaintedObject?: WorldObject;
    hostCache: LRUCache<string, HTMLCanvasElement>;
    invalidated: string[];
    constructor(canvas: HTMLCanvasElement, options?: CanvasRendererOptions);
    getCanvasDims(): {
        width: number;
        height: number;
    };
    resize(): void;
    isReady(): boolean;
    afterFrame(world: World): void;
    doOffscreenWork(): void;
    _worker: () => void;
    _scheduled: any;
    _doWork: () => void;
    getScale(width: number, height: number, dpi?: boolean): number;
    beforeFrame(world: World, delta: number, target: Strand, options: HookOptions): void;
    applyTransform(paint: Paintable, x: number, y: number, width: number, height: number): void;
    clearTransform(): void;
    paint(paint: SpacialContent | Text | Box, index: number, x: number, y: number, width: number, height: number): void;
    loadImage(url: string, callback: (image: HTMLImageElement) => void, err: (e: any) => void, retry?: boolean): void;
    schedulePaintToCanvas(imageBuffer: ImageBuffer, paint: SingleImage | TiledImage, index: number, priority: number): void;
    afterPaintLayer(paint: SpacialContent, transform: Strand): void;
    prepareLayer(paint: SpacialContent, points: Strand): void;
    finishLayer(): void;
    createImageHost(paint: SingleImage | TiledImage): void;
    getPointsAt(world: World, target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
    getViewportBounds(world: World, target: Strand, padding: number): PositionPair | null;
    pendingUpdate(): boolean;
    getRendererScreenPosition(): DOMRect;
    reset(): void;
}

declare class DebugRenderer implements Renderer {
    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;
    heightRatio: number;
    widthRatio: number;
    target: Float32Array;
    initialWidth: number;
    initialHeight: number;
    bounds: Strand | undefined;
    aggregate: Strand;
    delta: number;
    renderNextFrame: boolean;
    constructor(canvas: HTMLCanvasElement);
    isReady(): boolean;
    resize(): void;
    afterFrame(world: World, delta: number, target: Float32Array): void;
    getActiveZone(world: World): ZoneInterface | null;
    getPointsAt(world: World, target: Float32Array, aggregate: Float32Array, scaleFactor: number): Paint[];
    getScale(width: number, height: number): number;
    beforeFrame(world: World, delta: number): void;
    drawImage(): void;
    afterPaintLayer(paint: SpacialContent, transform?: Float32Array): void;
    paint(paint: SpacialContent, index: number, x: number, y: number, width: number, height: number): void;
    prepareLayer(paint: SpacialContent): void;
    pendingUpdate(): boolean;
    hasActiveZone(): boolean;
    getViewportBounds(world: World, target: Float32Array, padding: number): PositionPair | null;
    getRendererScreenPosition(): DOMRect;
    finishLayer(): void;
    reset(): void;
}

type Preset = {
    name: string;
    runtime: Runtime;
    renderer: Renderer;
    controller?: RuntimeController;
    em?: BrowserEventManager;
    ready?: boolean;
    unmount(): void;
    canvas?: HTMLCanvasElement;
    overlay?: HTMLDivElement;
    container?: HTMLDivElement;
    navigator?: HTMLCanvasElement;
};
type PresetArgs = {
    viewport: Viewer;
    forceRefresh: () => void;
    runtimeOptions?: RuntimeOptions;
    containerElement?: HTMLDivElement;
    canvasElement?: HTMLCanvasElement;
    overlayElement?: HTMLDivElement;
    navigatorElement?: HTMLCanvasElement;
};

type DefaultPresetName = 'default-preset';
type DefaultPresetOptions = {
    controllerConfig?: any;
    unstable_webglRenderer?: boolean;
    interactive?: boolean;
    dpi?: number;
    debug?: boolean;
    canvasBox?: boolean;
    polygon?: boolean;
};
declare function defaultPreset({ interactive, viewport, forceRefresh, canvasElement, overlayElement, controllerConfig, unstable_webglRenderer, dpi, debug, canvasBox, polygon, navigatorElement, runtimeOptions, }: PresetArgs & DefaultPresetOptions): Preset;

type StaticPresetName = 'static-preset';
type StaticPresetOptions = {
    controllerConfig?: any;
    interactive?: boolean;
};
declare function staticPreset({ interactive, viewport, forceRefresh, containerElement, overlayElement, controllerConfig, }: PresetArgs & StaticPresetOptions): Preset;

declare const presets: {
    [key in PresetNames]: (options: any) => Preset;
};
type PresetNames = DefaultPresetName | StaticPresetName;
type Presets = readonly [DefaultPresetName, DefaultPresetOptions] | readonly [StaticPresetName, StaticPresetOptions];

type AtlasProps$1 = {
    debug?: boolean;
    mode?: ViewerMode;
    onCreated?: (ctx: Preset) => void | Promise<void>;
    resetWorldOnChange?: boolean;
    unstable_webglRenderer?: boolean;
    unstable_noReconciler?: boolean;
    overlayStyle?: any;
    containerStyle?: any;
    containerProps?: any;
    controllerConfig?: PopmotionControllerConfig;
    renderPreset?: PresetNames | Presets;
    hideInlineStyle?: boolean;
    homeCover?: true | false | 'start' | 'end';
    homeOnResize?: boolean;
    homePosition?: Projection$1;
    className?: string;
    background?: string;
    enableNavigator?: boolean;
    htmlChildren?: ReactNode;
    children: ReactNode;
    runtimeOptions?: Partial<RuntimeOptions>;
    filters?: Partial<ViewerFilters>;
};
declare const Atlas: React__default.FC<AtlasProps$1 & {
    width: number;
    height: number;
}>;

declare function applyProps(instance: any, oldProps: any, newProps: any): void;
declare function activateEvents(world: World, props: any): void;
declare function unmountComponentAtNode(runtime: Runtime, callback?: (runtime: any) => void): void;
declare const ReactAtlas: {
    render(whatToRender: any, runtime: any): void;
    unmountComponentAtNode(runtime: Runtime, callback?: (runtime: any) => void): void;
};

declare const AtlasAuto: React__default.FC<AtlasProps$1 & {
    height?: number | string;
    width?: number | string;
    resizeHash?: number;
    containerProps?: any;
    aspectRatio?: number;
}>;

declare const AtlasContext: React__default.Context<Preset | null>;
declare const BoundsContext: React__default.Context<RectReadOnly | null>;

declare const DrawBox: React__default.FC<{
    children?: ReactNode;
    onCreate: (bounds: {
        x: number;
        y: number;
        width: number;
        height: number;
    }) => void;
}>;

declare const HTMLPortal: React__default.FC<{
    children?: ReactNode;
    backgroundColor?: string;
    interactive?: boolean;
    relative?: boolean;
    target?: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
} & React__default.RefAttributes<Box>>;

type RegionHighlightType = {
    id: any;
    x: number;
    y: number;
    width: number;
    height: number;
};
type RegionHighlightProps = {
    id?: string;
    region: RegionHighlightType;
    isEditing: boolean;
    rotation?: number;
    onSave: (annotation: RegionHighlightType) => void;
    onClick: (annotation: RegionHighlightType) => void;
    interactive?: boolean;
    maintainAspectRatio?: boolean;
    disableCardinalControls?: boolean;
    style?: BoxStyle;
    children?: ReactNode;
};
declare function RegionHighlight({ interactive, region, onClick, onSave, maintainAspectRatio, disableCardinalControls, isEditing, rotation, style, }: RegionHighlightProps): react_jsx_runtime.JSX.Element;

type ResizeWorldItemProps = JSX.IntrinsicElements['worldObject'] & {
    handleSize?: number;
    resizable?: boolean;
    rotation?: number;
    onSave: (pos: Partial<{
        x: number;
        y: number;
        width: number;
        height: number;
    }>) => void;
    children?: ReactNode;
    maintainAspectRatio?: boolean;
    disableCardinalControls?: boolean;
};
declare function ResizeWorldItem({ handleSize: _handleSize, resizable, onSave, children, maintainAspectRatio, disableCardinalControls, ...props }: ResizeWorldItemProps): react_jsx_runtime.JSX.Element;

declare const TileSet: React__default.FC<{
    tiles: GetTile;
    x?: number;
    y?: number;
    width: number;
    height: number;
    rotation?: number;
    crop?: any;
    children?: ReactNode;
    enableThumbnail?: boolean;
    enableSizes?: boolean;
    onClick?: (e: any) => void;
    renderOptions?: CompositeResourceProps;
}>;

declare const ImageService: React__default.FC<{
    id: string;
    width: number;
    height: number;
    x?: number;
    y?: number;
    rotation?: number;
    scale?: number;
    children?: ReactNode;
    crop?: any;
    enableSizes?: boolean;
    enableThumbnail?: boolean;
    renderOptions?: CompositeResourceProps;
}>;

declare const useAfterFrame: (callback: (time: number) => void, deps?: any[]) => void;

declare const useAfterPaint: (callback: (paint: Paintable) => void, deps?: any[]) => void;

declare const useAtlas: () => Preset | null;

type AtlasProps = {
    width: number;
    height: number;
    mode?: ViewerMode;
    onCreated?: (ctx: Preset) => void | Promise<void>;
    containerRef?: {
        current?: HTMLElement;
    };
    cover?: boolean;
    resetWorldOnChange?: boolean;
};
declare const useAtlasImage: (children: any, options: AtlasProps) => {
    uri: string | undefined;
    loading?: boolean;
    imageError?: string;
};

declare const useBeforeFrame: (callback: (time: number) => void, deps?: any[]) => void;

declare const useCanvas: () => HTMLCanvasElement | undefined;

declare const useControlledAnnotationList: (initialList?: Array<{
    x: number;
    y: number;
    width: number;
    height: number;
    id: any;
}>) => {
    isEditing: boolean;
    onDeselect: () => void;
    selectedAnnotation: string | undefined;
    onCreateNewAnnotation: (bounds: {
        x: number;
        y: number;
        width: number;
        height: number;
    }) => void;
    annotations: {
        x: number;
        y: number;
        width: number;
        height: number;
        id: any;
    }[];
    onUpdateAnnotation: (newAnno: any) => void;
    setIsEditing: React.Dispatch<React.SetStateAction<boolean>>;
    setSelectedAnnotation: React.Dispatch<React.SetStateAction<string | undefined>>;
    editAnnotation: (id: string) => void;
    addNewAnnotation: () => void;
};

declare const useFrame: (callback: (time: number) => void, deps?: any[]) => void;

declare const ModeContext: React__default.Context<ViewerMode>;
declare const useMode: () => ViewerMode;
declare function ModeProvider(props: {
    mode: ViewerMode;
    children: React__default.ReactNode;
}): react_jsx_runtime.JSX.Element;

declare const useResizeWorldItem: (props: {
    x: number;
    y: number;
    width: number;
    height: number;
    maintainAspectRatio?: boolean;
    aspectRatio?: number;
}, onSave: (item: {
    x: number;
    y: number;
    width: number;
    height: number;
}) => void) => {
    portalRef: React.MutableRefObject<Box | null>;
    mode: ViewerMode;
    mouseEvent: (direction: string) => (e: any) => void;
    onPointerMoveCallback: (e: any) => void;
    isEditing: boolean;
};

declare const useRuntime: () => Runtime | undefined;

declare const useWorldEvent: <Name extends SupportedEventNames>(name: Name, cb: (e: any) => void, deps?: any[]) => void;

declare function canDrag(ref: {
    current: ViewerMode;
}): boolean;

type AtlasEvent<BaseEvent extends Event> = BaseEvent & {
    atlas: {
        x: number;
        y: number;
    };
    cancelled?: boolean;
};
type SupportedEventFunctions = {
    onMouseDown(e: AtlasEvent<MouseEvent>): void;
    onMouseEnter(e: AtlasEvent<MouseEvent>): void;
    onMouseLeave(e: AtlasEvent<MouseEvent>): void;
    onMouseMove(e: AtlasEvent<MouseEvent>): void;
    onMouseOut(e: AtlasEvent<MouseEvent>): void;
    onMouseOver(e: AtlasEvent<MouseEvent>): void;
    onMouseUp(e: AtlasEvent<MouseEvent>): void;
    onTouchCancel(e: AtlasEvent<TouchEvent>): void;
    onTouchEnd(e: AtlasEvent<TouchEvent>): void;
    onTouchMove(e: AtlasEvent<TouchEvent>): void;
    onTouchStart(e: AtlasEvent<TouchEvent>): void;
    onPointerDown(e: AtlasEvent<PointerEvent>): void;
    onPointerMove(e: AtlasEvent<PointerEvent>): void;
    onPointerUp(e: AtlasEvent<PointerEvent>): void;
    onPointerCancel(e: AtlasEvent<PointerEvent>): void;
    onPointerEnter(e: AtlasEvent<PointerEvent>): void;
    onPointerLeave(e: AtlasEvent<PointerEvent>): void;
    onPointerOver(e: AtlasEvent<PointerEvent>): void;
    onPointerOut(e: AtlasEvent<PointerEvent>): void;
    onDragStart(e: AtlasEvent<DragEvent>): void;
    onDragEnd(e: AtlasEvent<DragEvent>): void;
    onDragEnter(e: AtlasEvent<DragEvent>): void;
    onDragExit(e: AtlasEvent<DragEvent>): void;
    onDrag(e: AtlasEvent<DragEvent>): void;
    onDragOver(e: AtlasEvent<DragEvent>): void;
    onScroll(e: AtlasEvent<UIEvent>): void;
    onWheel(e: AtlasEvent<WheelEvent>): void;
    onClick(e: AtlasEvent<MouseEvent>): void;
    onContextMenu(e: AtlasEvent<MouseEvent>): void;
    onUpdate(e: {
        props: any;
    }): void;
};
type EventListenerProps = Partial<SupportedEventFunctions>;

type BaseElement = {
    id?: string;
    ref?: any;
    key?: string | number;
    priority?: boolean;
};
type AllEvents = EventListenerProps;
declare global {
    namespace JSX {
        interface IntrinsicElements {
            world: BaseElement & {
                width?: number;
                height?: number;
                children?: React__default.ReactNode;
            } & AllEvents;
            worldObject: BaseElement & {
                children?: React__default.ReactNode;
                height: number;
                scale?: number;
                width: number;
                x?: number;
                y?: number;
            } & AllEvents;
            ['world-object']: BaseElement & {
                children?: React__default.ReactNode;
                height: number;
                scale?: number;
                width: number;
                x?: number;
                y?: number;
                rotation?: number;
            } & AllEvents;
            worldImage: BaseElement & {
                uri: string;
                target: any;
                display: any;
            } & AllEvents;
            ['world-image']: BaseElement & {
                uri: string;
                target: any;
                display: any;
                crop: any;
            } & AllEvents;
            texture: BaseElement & {
                getTexture: UpdateTextureFunction;
                target: any;
                display: any;
            } & AllEvents;
            compositeImage: BaseElement & {
                id?: string;
                width: number;
                height: number;
                children?: React__default.ReactNode;
            };
            shape: BaseElement & GeometryProps;
            ['composite-image']: BaseElement & {
                id?: string;
                width: number;
                height: number;
                children?: React__default.ReactNode;
                crop?: any;
                renderOptions?: CompositeResourceProps;
            } & AllEvents;
            tiledImage: BaseElement & {
                uri: string;
                display: {
                    width: number;
                    height: number;
                };
                tile: {
                    width: number;
                    height?: number;
                };
                scaleFactor: number;
            } & AllEvents;
            ['tiled-image']: BaseElement & {
                uri: string;
                display: {
                    width: number;
                    height: number;
                };
                tile: {
                    width: number;
                    height?: number;
                };
                scaleFactor: number;
                crop: any;
                version3?: boolean;
            } & AllEvents;
            box: BaseElement & {
                interactive?: boolean;
                backgroundColor?: string;
                className?: string;
                border?: string;
                target?: {
                    x?: number;
                    y?: number;
                    width: number;
                    height: number;
                };
                style?: BoxStyle;
                relativeSize?: boolean;
                relativeStyle?: boolean;
                html?: boolean;
            } & AllEvents;
            paragraph: BaseElement & {
                interactive?: boolean;
                id?: string;
                color?: string;
                textAlign?: string;
                lineHeight?: number;
                backgroundColor?: string;
                target?: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                };
                children?: string;
                paddingX?: number;
                paddingY?: number;
                fontSize?: number;
                fontFamily?: string;
            } & AllEvents;
        }
    }
}

declare function getTileFromImageService(infoJsonId: string, width: number, height: number): Promise<GetTile>;
declare function getTileFromCanvas(canvas: CanvasNormalized, thumbnailSize?: number): Promise<GetTile[]>;
declare function getTilesFromManifest(manifest: ManifestNormalized): Promise<any[]>;
declare function getTiles(manifestId: string): Promise<Array<GetTile>>;

declare class Stylesheet {
    $element: HTMLStyleElement;
    stylesheetClasses: string[];
    activeStylesheetClasses: string[];
    sheetsDidUpdate: boolean;
    sheetPrefix: string;
    stylesheetEntries: Record<string, string>;
    constructor(options?: {
        sheetPrefix?: string;
    });
    getElement(): HTMLStyleElement;
    addStylesheet(_sheet: string): string;
    removeStylesheet(obj: any): void;
    clearClasses(): void;
    didUpdateActive(): boolean;
    updateSheet(): void;
}

type OverlayRendererOptions = {
    sheetPrefix: string;
    box: boolean;
    text: boolean;
    inlineStyles: boolean;
    triggerResize: () => void;
    background: string;
};
declare class OverlayRenderer implements Renderer {
    htmlContainer: HTMLDivElement;
    visible: Array<Text | Box | SpacialContent>;
    previousVisible: Array<Text | Box | SpacialContent>;
    htmlIds: string[];
    firstMeaningfulPaint: boolean;
    rendererPosition: DOMRect;
    stylesheet: Stylesheet;
    options: OverlayRendererOptions;
    paintTx: number;
    zIndex: number;
    classes: {
        hostClassName: string;
        interactive: string;
        nonInteractive: string;
    };
    constructor(htmlContainer: HTMLDivElement, options?: Partial<OverlayRendererOptions>);
    createHtmlHost(paint: Text | Box): void;
    triggerResize(): void;
    updateHtmlHost(paint: Text | Box, width?: number, height?: number): void;
    afterFrame(world: World, delta: number, target: Strand): void;
    afterPaintLayer(paint: SpacialContent, transform?: Strand): void;
    beforeFrame(world: World, delta: number, target: Strand): void;
    getPointsAt(world: World, target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
    getScale(width: number, height: number): number;
    getViewportBounds(world: World, target: Strand, padding: number): PositionPair | null;
    isReady(): boolean;
    paint(paint: SpacialContent, index: number, x: number, y: number, width: number, height: number): void;
    pendingUpdate(): boolean;
    prepareLayer(paint: SpacialContent): void;
    resize(width?: number, height?: number): void;
    getRendererScreenPosition(): DOMRect;
    finishLayer(): void;
    reset(): void;
}

type StaticRendererOptions = {
    imageClass: string;
    addPart: boolean;
    setDraggableFalse: boolean;
    widthStylesheet: boolean;
    sheetPrefix: string;
    background: string;
};
declare class StaticRenderer implements Renderer {
    container: HTMLElement;
    width: number;
    height: number;
    pending: boolean;
    options: StaticRendererOptions;
    stylesheet: Stylesheet;
    zIndex: number;
    lastKnownScale: number;
    rendererPosition: DOMRect;
    constructor(container: HTMLElement, options?: Partial<StaticRendererOptions>);
    isReady(): boolean;
    resize(): void;
    getRendererScreenPosition(): DOMRect;
    afterFrame(world: World, delta: number, target: Strand): void;
    afterPaintLayer(paint: SpacialContent, transform?: Strand): void;
    beforeFrame(world: World, delta: number, target: Strand): void;
    getPointsAt(world: World, target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
    getScale(width: number, height: number): number;
    getViewportBounds(world: World, target: Strand, padding: number): PositionPair | null;
    currentlyVisible: HTMLElement[];
    previouslyVisible: HTMLElement[];
    createImage(): HTMLImageElement;
    paint(paint: SpacialContent, index: number, x: number, y: number, width: number, height: number): void;
    pendingUpdate(): boolean;
    prepareLayer(paint: SpacialContent): void;
    finishLayer(paint: SpacialContent): void;
    reset(): void;
}

type WebGLRendererOptions = {
    dpi?: number;
};
declare class WebGLRenderer implements Renderer {
    canvas: HTMLCanvasElement;
    gl: WebGL2RenderingContext;
    program: WebGLProgram;
    fragmentShader: WebGLShader;
    vertexShader: WebGLShader;
    rectBuffer: Float32Array;
    fragmentShaderSource: string;
    vertexShaderSource: string;
    attributes: {
        position: number;
        texCoord: number;
    };
    uniforms: {
        resolution: WebGLUniformLocation | null;
        texture: WebGLUniformLocation | null;
    };
    buffers: {
        position: WebGLBuffer;
        texCoord: WebGLBuffer;
    };
    rendererPosition: DOMRect;
    dpi: number;
    constructor(canvas: HTMLCanvasElement, options?: WebGLRendererOptions);
    resize(): void;
    isReady(): boolean;
    beforeFrame(world: World, delta: number, target: Strand): void;
    lastResize: number;
    prepareLayer(paint: SpacialContent): void;
    createTextureHost(paint: ImageTexture | Box): void;
    createImageHost(paint: SingleImage | TiledImage): void;
    paint(paint: SpacialContent, index: number, x: number, y: number, width: number, height: number): void;
    afterPaintLayer(paint: SpacialContent, transform?: Strand): void;
    pendingUpdate(): boolean;
    getPointsAt(world: World, target: Strand, aggregate: Strand, scaleFactor: number): Paint[];
    afterFrame(): void;
    lastKnownScale: number;
    getScale(width: number, height: number, dpi?: boolean): number;
    getCanvasDims(): {
        width: number;
        height: number;
    };
    getViewportBounds(world: World, target: Strand, padding: number): PositionPair | null;
    createShader(type: number, source: string): WebGLShader;
    createProgram(vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram;
    resizeCanvasToDisplaySize(): boolean;
    createArrayBuffer(data?: Float32Array): WebGLBuffer;
    setRectangle(x: number, y: number, width: number, height: number): void;
    getRectangle(x: number, y: number, width: number, height: number): Float32Array;
    getRendererScreenPosition(): DOMRect;
    finishLayer(): void;
    reset(): void;
}

declare function mergeStyles(defaultStyle?: BoxStyle, style?: BoxStyle): BoxStyle | undefined;

export { type AbstractObject, type AbstractWorldObject, type AllEvents, Atlas, AtlasAuto, AtlasContext, type AtlasProps$1 as AtlasProps, BoundsContext, Box, type BoxProps, type BoxStyle, BrowserEventManager, type BrowserEventManagerOptions, CanvasRenderer, type CanvasRendererOptions, CompositeRenderer, CompositeResource, type CompositeResourceProps, DebugRenderer, type DefaultPresetName, type DefaultPresetOptions, type DisplayData, DrawBox, type EasingFunction, type EasingFunctionNames, Geometry, type GeometryProps, type GeometryStyle, type GetTile, GridBuilder, HTMLPortal, type HookOptions, type ImageBuffer, ImageService, ImageTexture, type ImageTextureProps, ModeContext, ModeProvider, OverlayRenderer, type OverlayRendererOptions, type Paint, type Paintable, type PointerEvents, type PopmotionControllerConfig, type Position, type PositionPair, type Preset, type PresetArgs, type PresetNames, type Presets, type Projection, ReactAtlas, RegionHighlight, type RegionHighlightProps, type Renderer, ResizeWorldItem, Runtime, type RuntimeController, type RuntimeHooks, type RuntimeOptions, type Scaled, SingleImage, type SpacialContent, type SpacialSize, type StaticPresetName, type StaticPresetOptions, StaticRenderer, type SupportedEventMap, type SupportedEventNames, type SupportedEvents, Text, type TextProps, type TextWrapperOptions, TileSet, TiledImage, type UpdateTextureFunction, type Viewer, type ViewerFilters, type ViewerMode, type ViewingDirection, WebGLRenderer, type WebGLRendererOptions, World, WorldObject, type WorldTime, Zone, type ZoneConfig, type ZoneInterface, activateEvents, applyProps, bounceOut, canDrag, createDefaultEventMap, defaultConfig, defaultPreset, easingFunctions, fromImage, getId, getTileFromCanvas, getTileFromImageService, getTiles, getTilesFromManifest, mergeStyles, popmotionController, presets, staticPreset, supportedEventAttributes, supportedEventMap, unmountComponentAtNode, useAfterFrame, useAfterPaint, useAtlas, useAtlasImage, useBeforeFrame, useCanvas, useControlledAnnotationList, useFrame, useMode, useResizeWorldItem, useRuntime, useWorldEvent };
